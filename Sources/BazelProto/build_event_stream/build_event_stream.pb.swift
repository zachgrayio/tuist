// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: build_event_stream/build_event_stream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enumeration type characterizing the size of a test, as specified by the
/// test rule.
public enum BuildEventStream_TestSize: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case small // = 1
  case medium // = 2
  case large // = 3
  case enormous // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .small
    case 2: self = .medium
    case 3: self = .large
    case 4: self = .enormous
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .small: return 1
    case .medium: return 2
    case .large: return 3
    case .enormous: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestSize: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestSize] = [
    .unknown,
    .small,
    .medium,
    .large,
    .enormous,
  ]
}

#endif  // swift(>=4.2)

public enum BuildEventStream_TestStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case noStatus // = 0
  case passed // = 1
  case flaky // = 2
  case timeout // = 3
  case failed // = 4
  case incomplete // = 5
  case remoteFailure // = 6
  case failedToBuild // = 7
  case toolHaltedBeforeTesting // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .noStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noStatus
    case 1: self = .passed
    case 2: self = .flaky
    case 3: self = .timeout
    case 4: self = .failed
    case 5: self = .incomplete
    case 6: self = .remoteFailure
    case 7: self = .failedToBuild
    case 8: self = .toolHaltedBeforeTesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .noStatus: return 0
    case .passed: return 1
    case .flaky: return 2
    case .timeout: return 3
    case .failed: return 4
    case .incomplete: return 5
    case .remoteFailure: return 6
    case .failedToBuild: return 7
    case .toolHaltedBeforeTesting: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension BuildEventStream_TestStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_TestStatus] = [
    .noStatus,
    .passed,
    .flaky,
    .timeout,
    .failed,
    .incomplete,
    .remoteFailure,
    .failedToBuild,
    .toolHaltedBeforeTesting,
  ]
}

#endif  // swift(>=4.2)

/// Identifier for a build event. It is deliberately structured to also provide
/// information about which build target etc the event is related to.
///
/// Events are chained via the event id as follows: each event has an id and a
/// set of ids of children events such that apart from the initial event each
/// event has an id that is mentioned as child id in an earlier event and a build
/// invocation is complete if and only if all direct and indirect children of the
/// initial event have been posted.
public struct BuildEventStream_BuildEventId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId.OneOf_ID? = nil

  public var unknown: BuildEventStream_BuildEventId.UnknownBuildEventId {
    get {
      if case .unknown(let v)? = id {return v}
      return BuildEventStream_BuildEventId.UnknownBuildEventId()
    }
    set {id = .unknown(newValue)}
  }

  public var progress: BuildEventStream_BuildEventId.ProgressId {
    get {
      if case .progress(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ProgressId()
    }
    set {id = .progress(newValue)}
  }

  public var started: BuildEventStream_BuildEventId.BuildStartedId {
    get {
      if case .started(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildStartedId()
    }
    set {id = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_BuildEventId.UnstructuredCommandLineId {
    get {
      if case .unstructuredCommandLine(let v)? = id {return v}
      return BuildEventStream_BuildEventId.UnstructuredCommandLineId()
    }
    set {id = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: BuildEventStream_BuildEventId.StructuredCommandLineId {
    get {
      if case .structuredCommandLine(let v)? = id {return v}
      return BuildEventStream_BuildEventId.StructuredCommandLineId()
    }
    set {id = .structuredCommandLine(newValue)}
  }

  public var workspaceStatus: BuildEventStream_BuildEventId.WorkspaceStatusId {
    get {
      if case .workspaceStatus(let v)? = id {return v}
      return BuildEventStream_BuildEventId.WorkspaceStatusId()
    }
    set {id = .workspaceStatus(newValue)}
  }

  public var optionsParsed: BuildEventStream_BuildEventId.OptionsParsedId {
    get {
      if case .optionsParsed(let v)? = id {return v}
      return BuildEventStream_BuildEventId.OptionsParsedId()
    }
    set {id = .optionsParsed(newValue)}
  }

  public var fetch: BuildEventStream_BuildEventId.FetchId {
    get {
      if case .fetch(let v)? = id {return v}
      return BuildEventStream_BuildEventId.FetchId()
    }
    set {id = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {
      if case .configuration(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ConfigurationId()
    }
    set {id = .configuration(newValue)}
  }

  public var targetConfigured: BuildEventStream_BuildEventId.TargetConfiguredId {
    get {
      if case .targetConfigured(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TargetConfiguredId()
    }
    set {id = .targetConfigured(newValue)}
  }

  public var pattern: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .pattern(let v)? = id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {id = .pattern(newValue)}
  }

  public var patternSkipped: BuildEventStream_BuildEventId.PatternExpandedId {
    get {
      if case .patternSkipped(let v)? = id {return v}
      return BuildEventStream_BuildEventId.PatternExpandedId()
    }
    set {id = .patternSkipped(newValue)}
  }

  public var namedSet: BuildEventStream_BuildEventId.NamedSetOfFilesId {
    get {
      if case .namedSet(let v)? = id {return v}
      return BuildEventStream_BuildEventId.NamedSetOfFilesId()
    }
    set {id = .namedSet(newValue)}
  }

  public var targetCompleted: BuildEventStream_BuildEventId.TargetCompletedId {
    get {
      if case .targetCompleted(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TargetCompletedId()
    }
    set {id = .targetCompleted(newValue)}
  }

  public var actionCompleted: BuildEventStream_BuildEventId.ActionCompletedId {
    get {
      if case .actionCompleted(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ActionCompletedId()
    }
    set {id = .actionCompleted(newValue)}
  }

  public var unconfiguredLabel: BuildEventStream_BuildEventId.UnconfiguredLabelId {
    get {
      if case .unconfiguredLabel(let v)? = id {return v}
      return BuildEventStream_BuildEventId.UnconfiguredLabelId()
    }
    set {id = .unconfiguredLabel(newValue)}
  }

  public var configuredLabel: BuildEventStream_BuildEventId.ConfiguredLabelId {
    get {
      if case .configuredLabel(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ConfiguredLabelId()
    }
    set {id = .configuredLabel(newValue)}
  }

  public var testResult: BuildEventStream_BuildEventId.TestResultId {
    get {
      if case .testResult(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TestResultId()
    }
    set {id = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_BuildEventId.TestSummaryId {
    get {
      if case .testSummary(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TestSummaryId()
    }
    set {id = .testSummary(newValue)}
  }

  public var targetSummary: BuildEventStream_BuildEventId.TargetSummaryId {
    get {
      if case .targetSummary(let v)? = id {return v}
      return BuildEventStream_BuildEventId.TargetSummaryId()
    }
    set {id = .targetSummary(newValue)}
  }

  public var buildFinished: BuildEventStream_BuildEventId.BuildFinishedId {
    get {
      if case .buildFinished(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildFinishedId()
    }
    set {id = .buildFinished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildEventId.BuildToolLogsId {
    get {
      if case .buildToolLogs(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildToolLogsId()
    }
    set {id = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildEventId.BuildMetricsId {
    get {
      if case .buildMetrics(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildMetricsId()
    }
    set {id = .buildMetrics(newValue)}
  }

  public var workspace: BuildEventStream_BuildEventId.WorkspaceConfigId {
    get {
      if case .workspace(let v)? = id {return v}
      return BuildEventStream_BuildEventId.WorkspaceConfigId()
    }
    set {id = .workspace(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildEventId.BuildMetadataId {
    get {
      if case .buildMetadata(let v)? = id {return v}
      return BuildEventStream_BuildEventId.BuildMetadataId()
    }
    set {id = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId {
    get {
      if case .convenienceSymlinksIdentified(let v)? = id {return v}
      return BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId()
    }
    set {id = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ID: Equatable {
    case unknown(BuildEventStream_BuildEventId.UnknownBuildEventId)
    case progress(BuildEventStream_BuildEventId.ProgressId)
    case started(BuildEventStream_BuildEventId.BuildStartedId)
    case unstructuredCommandLine(BuildEventStream_BuildEventId.UnstructuredCommandLineId)
    case structuredCommandLine(BuildEventStream_BuildEventId.StructuredCommandLineId)
    case workspaceStatus(BuildEventStream_BuildEventId.WorkspaceStatusId)
    case optionsParsed(BuildEventStream_BuildEventId.OptionsParsedId)
    case fetch(BuildEventStream_BuildEventId.FetchId)
    case configuration(BuildEventStream_BuildEventId.ConfigurationId)
    case targetConfigured(BuildEventStream_BuildEventId.TargetConfiguredId)
    case pattern(BuildEventStream_BuildEventId.PatternExpandedId)
    case patternSkipped(BuildEventStream_BuildEventId.PatternExpandedId)
    case namedSet(BuildEventStream_BuildEventId.NamedSetOfFilesId)
    case targetCompleted(BuildEventStream_BuildEventId.TargetCompletedId)
    case actionCompleted(BuildEventStream_BuildEventId.ActionCompletedId)
    case unconfiguredLabel(BuildEventStream_BuildEventId.UnconfiguredLabelId)
    case configuredLabel(BuildEventStream_BuildEventId.ConfiguredLabelId)
    case testResult(BuildEventStream_BuildEventId.TestResultId)
    case testSummary(BuildEventStream_BuildEventId.TestSummaryId)
    case targetSummary(BuildEventStream_BuildEventId.TargetSummaryId)
    case buildFinished(BuildEventStream_BuildEventId.BuildFinishedId)
    case buildToolLogs(BuildEventStream_BuildEventId.BuildToolLogsId)
    case buildMetrics(BuildEventStream_BuildEventId.BuildMetricsId)
    case workspace(BuildEventStream_BuildEventId.WorkspaceConfigId)
    case buildMetadata(BuildEventStream_BuildEventId.BuildMetadataId)
    case convenienceSymlinksIdentified(BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEventId.OneOf_ID, rhs: BuildEventStream_BuildEventId.OneOf_ID) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.unknown, .unknown): return {
        guard case .unknown(let l) = lhs, case .unknown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.progress, .progress): return {
        guard case .progress(let l) = lhs, case .progress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.started, .started): return {
        guard case .started(let l) = lhs, case .started(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unstructuredCommandLine, .unstructuredCommandLine): return {
        guard case .unstructuredCommandLine(let l) = lhs, case .unstructuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.structuredCommandLine, .structuredCommandLine): return {
        guard case .structuredCommandLine(let l) = lhs, case .structuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceStatus, .workspaceStatus): return {
        guard case .workspaceStatus(let l) = lhs, case .workspaceStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optionsParsed, .optionsParsed): return {
        guard case .optionsParsed(let l) = lhs, case .optionsParsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fetch, .fetch): return {
        guard case .fetch(let l) = lhs, case .fetch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuration, .configuration): return {
        guard case .configuration(let l) = lhs, case .configuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetConfigured, .targetConfigured): return {
        guard case .targetConfigured(let l) = lhs, case .targetConfigured(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pattern, .pattern): return {
        guard case .pattern(let l) = lhs, case .pattern(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.patternSkipped, .patternSkipped): return {
        guard case .patternSkipped(let l) = lhs, case .patternSkipped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.namedSet, .namedSet): return {
        guard case .namedSet(let l) = lhs, case .namedSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetCompleted, .targetCompleted): return {
        guard case .targetCompleted(let l) = lhs, case .targetCompleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionCompleted, .actionCompleted): return {
        guard case .actionCompleted(let l) = lhs, case .actionCompleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unconfiguredLabel, .unconfiguredLabel): return {
        guard case .unconfiguredLabel(let l) = lhs, case .unconfiguredLabel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuredLabel, .configuredLabel): return {
        guard case .configuredLabel(let l) = lhs, case .configuredLabel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testResult, .testResult): return {
        guard case .testResult(let l) = lhs, case .testResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testSummary, .testSummary): return {
        guard case .testSummary(let l) = lhs, case .testSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetSummary, .targetSummary): return {
        guard case .targetSummary(let l) = lhs, case .targetSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildFinished, .buildFinished): return {
        guard case .buildFinished(let l) = lhs, case .buildFinished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildToolLogs, .buildToolLogs): return {
        guard case .buildToolLogs(let l) = lhs, case .buildToolLogs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetrics, .buildMetrics): return {
        guard case .buildMetrics(let l) = lhs, case .buildMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspace, .workspace): return {
        guard case .workspace(let l) = lhs, case .workspace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetadata, .buildMetadata): return {
        guard case .buildMetadata(let l) = lhs, case .buildMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.convenienceSymlinksIdentified, .convenienceSymlinksIdentified): return {
        guard case .convenienceSymlinksIdentified(let l) = lhs, case .convenienceSymlinksIdentified(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Generic identifier for a build event. This is the default type of
  /// BuildEventId, but should not be used outside testing; nevertheless,
  /// tools should handle build events with this kind of id gracefully.
  public struct UnknownBuildEventId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting progress. Those events are also used to
  /// chain in events that come early.
  public struct ProgressId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique identifier. No assumption should be made about how the ids are
    /// assigned; the only meaningful operation on this field is test for
    /// equality.
    public var opaqueCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the beginning of a build; this will
  /// normally be the first event.
  public struct BuildStartedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event indicating the original commandline received by
  /// the bazel server.
  public struct UnstructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event describing the commandline received by Bazel.
  public struct StructuredCommandLineId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A title for this command line value, as there may be multiple.
    /// For example, a single invocation may wish to report both the literal and
    /// canonical command lines, and this label would be used to differentiate
    /// between both versions.
    public var commandLineLabel: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating the workspace status.
  public struct WorkspaceStatusId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier on an event reporting on the options included in the command
  /// line, both explicitly and implicitly.
  public struct OptionsParsedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting that an external resource was fetched
  /// from.
  public struct FetchId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The external resource that was fetched from.
    public var url: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target pattern has been expanded
  /// further.
  /// Messages of this shape are also used to describe parts of a pattern that
  /// have been skipped for some reason, if the actual expansion was still
  /// carried out (e.g., if keep_going is set). In this case, the
  /// pattern_skipped choice in the id field is to be made.
  public struct PatternExpandedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pattern: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WorkspaceConfigId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct BuildMetadataId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target has been expanded by
  /// identifying for which configurations it should be build.
  public struct TargetConfiguredId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    /// If empty, the id refers to the expansion of the target. If not-empty,
    /// the id refers to the expansion of an aspect applied to the (already
    /// expanded) target.
    ///
    /// For example, when building an apple_binary that depends on proto_library
    /// "//:foo_proto", there will be two TargetConfigured events for
    /// "//:foo_proto":
    ///
    /// 1. An event with an empty aspect, corresponding to actions producing
    /// language-agnostic outputs from the proto_library; and
    /// 2. An event with aspect "ObjcProtoAspect", corresponding to Objective-C
    /// code generation.
    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a named set of files (usually artifacts)
  /// to be referred to in later messages.
  public struct NamedSetOfFilesId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the file set; this is an opaque string valid only for the
    /// particular instance of the event stream.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event introducing a configuration.
  public struct ConfigurationId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier of the configuration; users of the protocol should not make
    /// any assumptions about it having any structure, or equality of the
    /// identifier between different streams.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event indicating that a target was built completely; this
  /// does not include running the test if the target is a test target.
  public struct TargetCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    /// The configuration for which the target was built.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    /// If empty, the id refers to the completion of the target. If not-empty,
    /// the id refers to the completion of an aspect applied to the (already
    /// completed) target.
    ///
    /// For example, when building an apple_binary that depends on proto_library
    /// "//:foo_proto", there will be two TargetCompleted events for
    /// "//:foo_proto":
    ///
    /// 1. An event with an empty aspect, corresponding to actions producing
    /// language-agnostic outputs from the proto_library; and
    /// 2. An event with aspect "ObjcProtoAspect", corresponding to Objective-C
    /// code generation.
    public var aspect: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting that an action was completed (not all
  /// actions are reported, only the ones that can be considered important;
  /// this includes all failed actions).
  public struct ActionCompletedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var primaryOutput: String = String()

    /// Optional, the label of the owner of the action, for reference.
    public var label: String = String()

    /// Optional, the id of the configuration of the action owner.
    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting an event associated with an unconfigured
  /// label. Usually, this indicates a failure due to a missing input file. In
  /// any case, it will report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier. The
  /// purpose of those events is to serve as the root cause of a failed target.
  public struct UnconfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event reporting an event associated with a configured
  /// label, usually a visibility error. In any case, an event with such an
  /// id will always report some form of error (i.e., the payload will be an
  /// Aborted event); there are no regular events using this identifier.
  public struct ConfiguredLabelId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting on an individual test run. The label
  /// identifies the test that is reported about, the remaining fields are
  /// in such a way as to uniquely identify the action within a build. In fact,
  /// attempts for the same test, run, shard triple are counted sequentially,
  /// starting with 1.
  public struct TestResultId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var run: Int32 = 0

    public var shard: Int32 = 0

    public var attempt: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting the summary of a test.
  public struct TestSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of an event reporting the summary of a target.
  public struct TargetSummaryId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var label: String = String()

    public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
      get {return _configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
      set {_configuration = newValue}
    }
    /// Returns true if `configuration` has been explicitly set.
    public var hasConfiguration: Bool {return self._configuration != nil}
    /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
    public mutating func clearConfiguration() {self._configuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
  }

  /// Identifier of the BuildFinished event, indicating the end of a build.
  public struct BuildFinishedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing additional logs/statistics after
  /// completion of the build.
  public struct BuildToolLogsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing build metrics after completion
  /// of the build.
  public struct BuildMetricsId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Identifier of an event providing convenience symlinks information.
  public struct ConvenienceSymlinksIdentifiedId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of an event summarizing the progress of the build so far. Those
/// events are also used to be parents of events where the more logical parent
/// event cannot be posted yet as the needed information is not yet complete.
public struct BuildEventStream_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The next chunk of stdout that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stdout: String = String()

  /// The next chunk of stderr that bazel produced since the last progress event
  /// or the beginning of the build.
  public var stderr: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event indicating that an expected event will not come, as
/// the build is aborted prematurely for some reason.
public struct BuildEventStream_Aborted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: BuildEventStream_Aborted.AbortReason = .unknown

  /// A human readable description with more details about there reason, where
  /// available and useful.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AbortReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// The user requested the build to be aborted (e.g., by hitting Ctl-C).
    case userInterrupted // = 1

    /// The user requested that no analysis be performed.
    case noAnalyze // = 8

    /// The user requested that no build be carried out.
    case noBuild // = 9

    /// The build or target was aborted as a timeout was exceeded.
    case timeOut // = 2

    /// The build or target was aborted as some remote environment (e.g., for
    /// remote execution of actions) was not available in the expected way.
    case remoteEnvironmentFailure // = 3

    /// Failure due to reasons entirely internal to the build tool, i.e. an
    /// unexpected crash due to programmer error.
    case `internal` // = 4

    /// A Failure occurred in the loading phase of a target.
    case loadingFailure // = 5

    /// A Failure occurred in the analysis phase of a target.
    case analysisFailure // = 6

    /// Target build was skipped (e.g. due to incompatible CPU constraints).
    case skipped // = 7

    /// Build incomplete due to an earlier build failure (e.g. --keep_going was
    /// set to false causing the build be ended upon failure).
    case incomplete // = 10

    /// The build tool ran out of memory and crashed.
    case outOfMemory // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .userInterrupted
      case 2: self = .timeOut
      case 3: self = .remoteEnvironmentFailure
      case 4: self = .internal
      case 5: self = .loadingFailure
      case 6: self = .analysisFailure
      case 7: self = .skipped
      case 8: self = .noAnalyze
      case 9: self = .noBuild
      case 10: self = .incomplete
      case 11: self = .outOfMemory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .userInterrupted: return 1
      case .timeOut: return 2
      case .remoteEnvironmentFailure: return 3
      case .internal: return 4
      case .loadingFailure: return 5
      case .analysisFailure: return 6
      case .skipped: return 7
      case .noAnalyze: return 8
      case .noBuild: return 9
      case .incomplete: return 10
      case .outOfMemory: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_Aborted.AbortReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_Aborted.AbortReason] = [
    .unknown,
    .userInterrupted,
    .noAnalyze,
    .noBuild,
    .timeOut,
    .remoteEnvironmentFailure,
    .internal,
    .loadingFailure,
    .analysisFailure,
    .skipped,
    .incomplete,
    .outOfMemory,
  ]
}

#endif  // swift(>=4.2)

/// Payload of an event indicating the beginning of a new build. Usually, events
/// of those type start a new build-event stream. The target pattern requested
/// to be build is contained in one of the announced child events; it is an
/// invariant that precisely one of the announced child events has a non-empty
/// target pattern.
public struct BuildEventStream_BuildStarted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  /// Start of the build in ms since the epoch.
  ///
  /// Deprecated, use `start_time` instead.
  ///
  /// TODO(yannic): Remove.
  public var startTimeMillis: Int64 = 0

  /// Start of the build.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Version of the build tool that is running.
  public var buildToolVersion: String = String()

  /// A human-readable description of all the non-default option settings
  public var optionsDescription: String = String()

  /// The name of the command that the user invoked.
  public var command: String = String()

  /// The working directory from which the build tool was invoked.
  public var workingDirectory: String = String()

  /// The directory of the workspace.
  public var workspaceDirectory: String = String()

  /// The process ID of the Bazel server.
  public var serverPid: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Configuration related to the blaze workspace and output tree.
public struct BuildEventStream_WorkspaceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The root of the local blaze exec root. All output files live underneath
  /// this at "blaze-out/".
  public var localExecRoot: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the command-line of the invocation as
/// originally received by the server. Note that this is not the command-line
/// given by the user, as the client adds information about the invocation,
/// like name and relevant entries of rc-files and client environment variables.
/// However, it does contain enough information to reproduce the build
/// invocation.
public struct BuildEventStream_UnstructuredCommandLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting on the parsed options, grouped in various ways.
public struct BuildEventStream_OptionsParsed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var startupOptions: [String] = []

  public var explicitStartupOptions: [String] = []

  public var cmdLine: [String] = []

  public var explicitCmdLine: [String] = []

  public var invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy {
    get {return _invocationPolicy ?? Blaze_InvocationPolicy_InvocationPolicy()}
    set {_invocationPolicy = newValue}
  }
  /// Returns true if `invocationPolicy` has been explicitly set.
  public var hasInvocationPolicy: Bool {return self._invocationPolicy != nil}
  /// Clears the value of `invocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInvocationPolicy() {self._invocationPolicy = nil}

  public var toolTag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _invocationPolicy: Blaze_InvocationPolicy_InvocationPolicy? = nil
}

/// Payload of an event indicating that an external resource was fetched. This
/// event will only occur in streams where an actual fetch happened, not in ones
/// where a cached copy of the entity to be fetched was used.
public struct BuildEventStream_Fetch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting the workspace status. Key-value pairs can be
/// provided by specifying the workspace_status_command to an executable that
/// returns one key-value pair per line of output (key and value separated by a
/// space).
public struct BuildEventStream_WorkspaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var item: [BuildEventStream_WorkspaceStatus.Item] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Item {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of an event reporting custom key-value metadata associated with the
/// build.
public struct BuildEventStream_BuildMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Custom metadata for the build.
  public var metadata: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of an event reporting details of a given configuration.
public struct BuildEventStream_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mnemonic: String = String()

  public var platformName: String = String()

  public var cpu: String = String()

  public var makeVariable: Dictionary<String,String> = [:]

  /// Whether this configuration is used for building tools.
  public var isTool: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the expansion of a target pattern.
/// The main information is in the chaining part: the id will contain the
/// target pattern that was expanded and the children id will contain the
/// target or target pattern it was expanded to.
public struct BuildEventStream_PatternExpanded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All test suites requested via top-level target patterns. Does not include
  /// test suites whose label matched a negative pattern.
  public var testSuiteExpansions: [BuildEventStream_PatternExpanded.TestSuiteExpansion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents a test_suite target and the tests that it expanded to. Nested
  /// test suites are recursively expanded. The test labels only contain the
  /// final test targets, not any nested suites.
  public struct TestSuiteExpansion {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The label of the test_suite rule.
    public var suiteLabel: String = String()

    /// Labels of the test targets included in the suite. Includes all tests in
    /// the suite regardless of any filters or negative patterns which may result
    /// in the test not actually being run.
    public var testLabels: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Payload of the event indicating that the configurations for a target have
/// been identified. As with pattern expansion the main information is in the
/// chaining part: the id will contain the target that was configured and the
/// children id will contain the configured targets it was configured to.
public struct BuildEventStream_TargetConfigured {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// List of all tags associated with this target (for all possible
  /// configurations).
  public var tag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BuildEventStream_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sequence of prefixes to apply to the file name to construct a full path.
  /// In most but not all cases, there will be 3 entries:
  ///  1. A root output directory, eg "bazel-out"
  ///  2. A configuration mnemonic, eg "k8-fastbuild"
  ///  3. An output category, eg "genfiles"
  public var pathPrefix: [String] = []

  /// identifier indicating the nature of the file (e.g., "stdout", "stderr")
  public var name: String = String()

  public var file: BuildEventStream_File.OneOf_File? = nil

  /// A location where the contents of the file can be found. The string is
  /// encoded according to RFC2396.
  public var uri: String {
    get {
      if case .uri(let v)? = file {return v}
      return String()
    }
    set {file = .uri(newValue)}
  }

  /// The contents of the file, if they are guaranteed to be short.
  public var contents: Data {
    get {
      if case .contents(let v)? = file {return v}
      return Data()
    }
    set {file = .contents(newValue)}
  }

  /// Digest of the file, using the build tool's configured digest algorithm,
  /// hex-encoded.
  public var digest: String = String()

  /// Length of the file in bytes.
  public var length: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_File: Equatable {
    /// A location where the contents of the file can be found. The string is
    /// encoded according to RFC2396.
    case uri(String)
    /// The contents of the file, if they are guaranteed to be short.
    case contents(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_File.OneOf_File, rhs: BuildEventStream_File.OneOf_File) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uri, .uri): return {
        guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contents, .contents): return {
        guard case .contents(let l) = lhs, case .contents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Payload of a message to describe a set of files, usually build artifacts, to
/// be referred to later by their name. In this way, files that occur identically
/// as outputs of several targets have to be named only once.
public struct BuildEventStream_NamedSetOfFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Files that belong to this named set of files.
  public var files: [BuildEventStream_File] = []

  /// Other named sets whose members also belong to this set.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of an action. The main purpose
/// of posting those events is to provide details on the root cause for a target
/// failing; however, consumers of the build-event protocol must not assume
/// that only failed actions are posted.
public struct BuildEventStream_ActionExecuted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool {
    get {return _storage._success}
    set {_uniqueStorage()._success = newValue}
  }

  /// The mnemonic of the action that was executed
  public var type: String {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// The exit code of the action, if it is available.
  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  /// Location where to find the standard output of the action
  /// (e.g., a file path).
  public var stdout: BuildEventStream_File {
    get {return _storage._stdout ?? BuildEventStream_File()}
    set {_uniqueStorage()._stdout = newValue}
  }
  /// Returns true if `stdout` has been explicitly set.
  public var hasStdout: Bool {return _storage._stdout != nil}
  /// Clears the value of `stdout`. Subsequent reads from it will return its default value.
  public mutating func clearStdout() {_uniqueStorage()._stdout = nil}

  /// Location where to find the standard error of the action
  /// (e.g., a file path).
  public var stderr: BuildEventStream_File {
    get {return _storage._stderr ?? BuildEventStream_File()}
    set {_uniqueStorage()._stderr = newValue}
  }
  /// Returns true if `stderr` has been explicitly set.
  public var hasStderr: Bool {return _storage._stderr != nil}
  /// Clears the value of `stderr`. Subsequent reads from it will return its default value.
  public mutating func clearStderr() {_uniqueStorage()._stderr = nil}

  /// Deprecated. This field is now present on ActionCompletedId.
  public var label: String {
    get {return _storage._label}
    set {_uniqueStorage()._label = newValue}
  }

  /// Deprecated. This field is now present on ActionCompletedId.
  public var configuration: BuildEventStream_BuildEventId.ConfigurationId {
    get {return _storage._configuration ?? BuildEventStream_BuildEventId.ConfigurationId()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  /// Primary output; only provided for successful actions.
  public var primaryOutput: BuildEventStream_File {
    get {return _storage._primaryOutput ?? BuildEventStream_File()}
    set {_uniqueStorage()._primaryOutput = newValue}
  }
  /// Returns true if `primaryOutput` has been explicitly set.
  public var hasPrimaryOutput: Bool {return _storage._primaryOutput != nil}
  /// Clears the value of `primaryOutput`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryOutput() {_uniqueStorage()._primaryOutput = nil}

  /// The command-line of the action, if the action is a command.
  public var commandLine: [String] {
    get {return _storage._commandLine}
    set {_uniqueStorage()._commandLine = newValue}
  }

  /// List of paths to log files
  public var actionMetadataLogs: [BuildEventStream_File] {
    get {return _storage._actionMetadataLogs}
    set {_uniqueStorage()._actionMetadataLogs = newValue}
  }

  /// Only populated if success = false, and sometimes not even then.
  public var failureDetail: FailureDetails_FailureDetail {
    get {return _storage._failureDetail ?? FailureDetails_FailureDetail()}
    set {_uniqueStorage()._failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return _storage._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {_uniqueStorage()._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Collection of all output files belonging to that output group.
public struct BuildEventStream_OutputGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the output group
  public var name: String = String()

  /// List of file sets that belong to this output group as well.
  public var fileSets: [BuildEventStream_BuildEventId.NamedSetOfFilesId] = []

  /// Indicates that one or more of the output group's files were not built
  /// successfully (the generating action failed).
  public var incomplete: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Payload of the event indicating the completion of a target. The target is
/// specified in the id. If the target failed the root causes are provided as
/// children events.
public struct BuildEventStream_TargetComplete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  /// The kind of target (e.g.,  e.g. "cc_library rule", "source file",
  /// "generated file") where the completion is reported.
  /// Deprecated: use the target_kind field in TargetConfigured instead.
  public var targetKind: String = String()

  /// The size of the test, if the target is a test target. Unset otherwise.
  /// Deprecated: use the test_size field in TargetConfigured instead.
  public var testSize: BuildEventStream_TestSize = .unknown

  /// The output files are arranged by their output group. If an output file
  /// is part of multiple output groups, it appears once in each output
  /// group.
  public var outputGroup: [BuildEventStream_OutputGroup] = []

  /// Temporarily, also report the important outputs directly. This is only to
  /// allow existing clients help transition to the deduplicated representation;
  /// new clients should not use it.
  public var importantOutput: [BuildEventStream_File] = []

  /// Report output artifacts (referenced transitively via output_group) which
  /// emit directories instead of singleton files. These directory_output entries
  /// will never include a uri.
  public var directoryOutput: [BuildEventStream_File] = []

  /// List of tags associated with this configured target.
  public var tag: [String] = []

  /// The timeout specified for test actions under this configured target.
  ///
  /// Deprecated, use `test_timeout` instead.
  ///
  /// TODO(yannic): Remove.
  public var testTimeoutSeconds: Int64 = 0

  /// The timeout specified for test actions under this configured target.
  public var testTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _testTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_testTimeout = newValue}
  }
  /// Returns true if `testTimeout` has been explicitly set.
  public var hasTestTimeout: Bool {return self._testTimeout != nil}
  /// Clears the value of `testTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearTestTimeout() {self._testTimeout = nil}

  /// Failure information about the target, only populated if success is false,
  /// and sometimes not even then. Equal to one of the ActionExecuted
  /// failure_detail fields for one of the root cause ActionExecuted events.
  public var failureDetail: FailureDetails_FailureDetail {
    get {return _failureDetail ?? FailureDetails_FailureDetail()}
    set {_failureDetail = newValue}
  }
  /// Returns true if `failureDetail` has been explicitly set.
  public var hasFailureDetail: Bool {return self._failureDetail != nil}
  /// Clears the value of `failureDetail`. Subsequent reads from it will return its default value.
  public mutating func clearFailureDetail() {self._failureDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _testTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _failureDetail: FailureDetails_FailureDetail? = nil
}

/// Payload on events reporting about individual test action.
public struct BuildEventStream_TestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status of this test.
  public var status: BuildEventStream_TestStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Additional details about the status of the test. This is intended for
  /// user display and must not be parsed.
  public var statusDetails: String {
    get {return _storage._statusDetails}
    set {_uniqueStorage()._statusDetails = newValue}
  }

  /// True, if the reported attempt is taken from the tool's local cache.
  public var cachedLocally: Bool {
    get {return _storage._cachedLocally}
    set {_uniqueStorage()._cachedLocally = newValue}
  }

  /// Time in milliseconds since the epoch at which the test attempt was started.
  /// Note: for cached test results, this is time can be before the start of the
  /// build.
  ///
  /// Deprecated, use `test_attempt_start` instead.
  ///
  /// TODO(yannic): Remove.
  public var testAttemptStartMillisEpoch: Int64 {
    get {return _storage._testAttemptStartMillisEpoch}
    set {_uniqueStorage()._testAttemptStartMillisEpoch = newValue}
  }

  /// Time at which the test attempt was started.
  /// Note: for cached test results, this is time can be before the start of the
  /// build.
  public var testAttemptStart: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._testAttemptStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._testAttemptStart = newValue}
  }
  /// Returns true if `testAttemptStart` has been explicitly set.
  public var hasTestAttemptStart: Bool {return _storage._testAttemptStart != nil}
  /// Clears the value of `testAttemptStart`. Subsequent reads from it will return its default value.
  public mutating func clearTestAttemptStart() {_uniqueStorage()._testAttemptStart = nil}

  /// Time the test took to run. For locally cached results, this is the time
  /// the cached invocation took when it was invoked.
  ///
  /// Deprecated, use `test_attempt_duration` instead.
  ///
  /// TODO(yannic): Remove.
  public var testAttemptDurationMillis: Int64 {
    get {return _storage._testAttemptDurationMillis}
    set {_uniqueStorage()._testAttemptDurationMillis = newValue}
  }

  /// Time the test took to run. For locally cached results, this is the time
  /// the cached invocation took when it was invoked.
  public var testAttemptDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._testAttemptDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._testAttemptDuration = newValue}
  }
  /// Returns true if `testAttemptDuration` has been explicitly set.
  public var hasTestAttemptDuration: Bool {return _storage._testAttemptDuration != nil}
  /// Clears the value of `testAttemptDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTestAttemptDuration() {_uniqueStorage()._testAttemptDuration = nil}

  /// Files (logs, test.xml, undeclared outputs, etc) generated by that test
  /// action.
  public var testActionOutput: [BuildEventStream_File] {
    get {return _storage._testActionOutput}
    set {_uniqueStorage()._testActionOutput = newValue}
  }

  /// Warnings generated by that test action.
  public var warning: [String] {
    get {return _storage._warning}
    set {_uniqueStorage()._warning = newValue}
  }

  public var executionInfo: BuildEventStream_TestResult.ExecutionInfo {
    get {return _storage._executionInfo ?? BuildEventStream_TestResult.ExecutionInfo()}
    set {_uniqueStorage()._executionInfo = newValue}
  }
  /// Returns true if `executionInfo` has been explicitly set.
  public var hasExecutionInfo: Bool {return _storage._executionInfo != nil}
  /// Clears the value of `executionInfo`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionInfo() {_uniqueStorage()._executionInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message providing optional meta data on the execution of the test action,
  /// if available.
  public struct ExecutionInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated, use TargetComplete.test_timeout instead.
    public var timeoutSeconds: Int32 = 0

    /// Name of the strategy to execute this test action (e.g., "local",
    /// "remote")
    public var strategy: String = String()

    /// True, if the reported attempt was a cache hit in a remote cache.
    public var cachedRemotely: Bool = false

    /// The exit code of the test action.
    public var exitCode: Int32 = 0

    /// The hostname of the machine where the test action was executed (in case
    /// of remote execution), if known.
    public var hostname: String = String()

    public var timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown {
      get {return _timingBreakdown ?? BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown()}
      set {_timingBreakdown = newValue}
    }
    /// Returns true if `timingBreakdown` has been explicitly set.
    public var hasTimingBreakdown: Bool {return self._timingBreakdown != nil}
    /// Clears the value of `timingBreakdown`. Subsequent reads from it will return its default value.
    public mutating func clearTimingBreakdown() {self._timingBreakdown = nil}

    public var resourceUsage: [BuildEventStream_TestResult.ExecutionInfo.ResourceUsage] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents a hierarchical timing breakdown of an activity.
    /// The top level time should be the total time of the activity.
    /// Invariant: `time` >= sum of `time`s of all direct children.
    public struct TimingBreakdown {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var child: [BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown] = []

      public var name: String = String()

      /// Deprecated, use `time` instead.
      ///
      /// TODO(yannic): Remove.
      public var timeMillis: Int64 = 0

      public var time: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _time ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_time = newValue}
      }
      /// Returns true if `time` has been explicitly set.
      public var hasTime: Bool {return self._time != nil}
      /// Clears the value of `time`. Subsequent reads from it will return its default value.
      public mutating func clearTime() {self._time = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _time: SwiftProtobuf.Google_Protobuf_Duration? = nil
    }

    public struct ResourceUsage {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var value: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _timingBreakdown: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of the event summarizing a test.
public struct BuildEventStream_TestSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Wrapper around BlazeTestStatus to support importing that enum to proto3.
  /// Overall status of test, accumulated over all runs, shards, and attempts.
  public var overallStatus: BuildEventStream_TestStatus {
    get {return _storage._overallStatus}
    set {_uniqueStorage()._overallStatus = newValue}
  }

  /// Total number of shard attempts.
  /// E.g., if a target has 4 runs, 3 shards, each with 2 attempts,
  /// then total_run_count will be 4*3*2 = 24.
  public var totalRunCount: Int32 {
    get {return _storage._totalRunCount}
    set {_uniqueStorage()._totalRunCount = newValue}
  }

  /// Value of runs_per_test for the test.
  public var runCount: Int32 {
    get {return _storage._runCount}
    set {_uniqueStorage()._runCount = newValue}
  }

  /// Number of attempts.
  /// If there are a different number of attempts per shard, the highest attempt
  /// count across all shards for each run is used.
  public var attemptCount: Int32 {
    get {return _storage._attemptCount}
    set {_uniqueStorage()._attemptCount = newValue}
  }

  /// Number of shards.
  public var shardCount: Int32 {
    get {return _storage._shardCount}
    set {_uniqueStorage()._shardCount = newValue}
  }

  /// Path to logs of passed runs.
  public var passed: [BuildEventStream_File] {
    get {return _storage._passed}
    set {_uniqueStorage()._passed = newValue}
  }

  /// Path to logs of failed runs;
  public var failed: [BuildEventStream_File] {
    get {return _storage._failed}
    set {_uniqueStorage()._failed = newValue}
  }

  /// Total number of cached test actions
  public var totalNumCached: Int32 {
    get {return _storage._totalNumCached}
    set {_uniqueStorage()._totalNumCached = newValue}
  }

  /// When the test first started running.
  ///
  /// Deprecated, use `first_start_time` instead.
  ///
  /// TODO(yannic): Remove.
  public var firstStartTimeMillis: Int64 {
    get {return _storage._firstStartTimeMillis}
    set {_uniqueStorage()._firstStartTimeMillis = newValue}
  }

  /// When the test first started running.
  public var firstStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._firstStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._firstStartTime = newValue}
  }
  /// Returns true if `firstStartTime` has been explicitly set.
  public var hasFirstStartTime: Bool {return _storage._firstStartTime != nil}
  /// Clears the value of `firstStartTime`. Subsequent reads from it will return its default value.
  public mutating func clearFirstStartTime() {_uniqueStorage()._firstStartTime = nil}

  /// When the last test action completed.
  ///
  /// Deprecated, use `last_stop_time` instead.
  ///
  /// TODO(yannic): Remove.
  public var lastStopTimeMillis: Int64 {
    get {return _storage._lastStopTimeMillis}
    set {_uniqueStorage()._lastStopTimeMillis = newValue}
  }

  /// When the test first started running.
  public var lastStopTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastStopTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastStopTime = newValue}
  }
  /// Returns true if `lastStopTime` has been explicitly set.
  public var hasLastStopTime: Bool {return _storage._lastStopTime != nil}
  /// Clears the value of `lastStopTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastStopTime() {_uniqueStorage()._lastStopTime = nil}

  /// The total runtime of the test.
  ///
  /// Deprecated, use `total_run` instead.
  ///
  /// TODO(yannic): Remove.
  public var totalRunDurationMillis: Int64 {
    get {return _storage._totalRunDurationMillis}
    set {_uniqueStorage()._totalRunDurationMillis = newValue}
  }

  /// The total runtime of the test.
  public var totalRunDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._totalRunDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._totalRunDuration = newValue}
  }
  /// Returns true if `totalRunDuration` has been explicitly set.
  public var hasTotalRunDuration: Bool {return _storage._totalRunDuration != nil}
  /// Clears the value of `totalRunDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTotalRunDuration() {_uniqueStorage()._totalRunDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Payload of the event summarizing a target (test or non-test).
public struct BuildEventStream_TargetSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Conjunction of TargetComplete events for this target, including aspects.
  public var overallBuildSuccess: Bool = false

  /// Repeats TestSummary's overall_status if available.
  public var overallTestStatus: BuildEventStream_TestStatus = .noStatus

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event indicating the end of a build.
public struct BuildEventStream_BuildFinished {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the build succeeded or failed.
  public var overallSuccess: Bool = false

  /// The overall status of the build. A build was successful iff
  /// ExitCode.code equals 0.
  public var exitCode: BuildEventStream_BuildFinished.ExitCode {
    get {return _exitCode ?? BuildEventStream_BuildFinished.ExitCode()}
    set {_exitCode = newValue}
  }
  /// Returns true if `exitCode` has been explicitly set.
  public var hasExitCode: Bool {return self._exitCode != nil}
  /// Clears the value of `exitCode`. Subsequent reads from it will return its default value.
  public mutating func clearExitCode() {self._exitCode = nil}

  /// End of the build in ms since the epoch.
  ///
  /// Deprecated, use `finish_time` instead.
  ///
  /// TODO(yannic): Remove.
  public var finishTimeMillis: Int64 = 0

  /// End of the build.
  public var finishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _finishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_finishTime = newValue}
  }
  /// Returns true if `finishTime` has been explicitly set.
  public var hasFinishTime: Bool {return self._finishTime != nil}
  /// Clears the value of `finishTime`. Subsequent reads from it will return its default value.
  public mutating func clearFinishTime() {self._finishTime = nil}

  public var anomalyReport: BuildEventStream_BuildFinished.AnomalyReport {
    get {return _anomalyReport ?? BuildEventStream_BuildFinished.AnomalyReport()}
    set {_anomalyReport = newValue}
  }
  /// Returns true if `anomalyReport` has been explicitly set.
  public var hasAnomalyReport: Bool {return self._anomalyReport != nil}
  /// Clears the value of `anomalyReport`. Subsequent reads from it will return its default value.
  public mutating func clearAnomalyReport() {self._anomalyReport = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Exit code of a build. The possible values correspond to the predefined
  /// codes in bazel's lib.ExitCode class, as well as any custom exit code a
  /// module might define. The predefined exit codes are subject to change (but
  /// rarely do) and are not part of the public API.
  ///
  /// A build was successful iff ExitCode.code equals 0.
  public struct ExitCode {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the exit code.
    public var name: String = String()

    /// The exit code.
    public var code: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Things that happened during the build that could be of interest.
  public struct AnomalyReport {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Was the build suspended at any time during the build.
    /// Examples of suspensions are SIGSTOP, or the hardware being put to sleep.
    /// If was_suspended is true, then most of the timings for this build are
    /// suspect.
    /// NOTE: This is no longer set and is deprecated.
    public var wasSuspended: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _exitCode: BuildEventStream_BuildFinished.ExitCode? = nil
  fileprivate var _finishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _anomalyReport: BuildEventStream_BuildFinished.AnomalyReport? = nil
}

public struct BuildEventStream_BuildMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionSummary: BuildEventStream_BuildMetrics.ActionSummary {
    get {return _storage._actionSummary ?? BuildEventStream_BuildMetrics.ActionSummary()}
    set {_uniqueStorage()._actionSummary = newValue}
  }
  /// Returns true if `actionSummary` has been explicitly set.
  public var hasActionSummary: Bool {return _storage._actionSummary != nil}
  /// Clears the value of `actionSummary`. Subsequent reads from it will return its default value.
  public mutating func clearActionSummary() {_uniqueStorage()._actionSummary = nil}

  public var memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics {
    get {return _storage._memoryMetrics ?? BuildEventStream_BuildMetrics.MemoryMetrics()}
    set {_uniqueStorage()._memoryMetrics = newValue}
  }
  /// Returns true if `memoryMetrics` has been explicitly set.
  public var hasMemoryMetrics: Bool {return _storage._memoryMetrics != nil}
  /// Clears the value of `memoryMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearMemoryMetrics() {_uniqueStorage()._memoryMetrics = nil}

  public var targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics {
    get {return _storage._targetMetrics ?? BuildEventStream_BuildMetrics.TargetMetrics()}
    set {_uniqueStorage()._targetMetrics = newValue}
  }
  /// Returns true if `targetMetrics` has been explicitly set.
  public var hasTargetMetrics: Bool {return _storage._targetMetrics != nil}
  /// Clears the value of `targetMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTargetMetrics() {_uniqueStorage()._targetMetrics = nil}

  public var packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics {
    get {return _storage._packageMetrics ?? BuildEventStream_BuildMetrics.PackageMetrics()}
    set {_uniqueStorage()._packageMetrics = newValue}
  }
  /// Returns true if `packageMetrics` has been explicitly set.
  public var hasPackageMetrics: Bool {return _storage._packageMetrics != nil}
  /// Clears the value of `packageMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearPackageMetrics() {_uniqueStorage()._packageMetrics = nil}

  public var timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics {
    get {return _storage._timingMetrics ?? BuildEventStream_BuildMetrics.TimingMetrics()}
    set {_uniqueStorage()._timingMetrics = newValue}
  }
  /// Returns true if `timingMetrics` has been explicitly set.
  public var hasTimingMetrics: Bool {return _storage._timingMetrics != nil}
  /// Clears the value of `timingMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearTimingMetrics() {_uniqueStorage()._timingMetrics = nil}

  public var cumulativeMetrics: BuildEventStream_BuildMetrics.CumulativeMetrics {
    get {return _storage._cumulativeMetrics ?? BuildEventStream_BuildMetrics.CumulativeMetrics()}
    set {_uniqueStorage()._cumulativeMetrics = newValue}
  }
  /// Returns true if `cumulativeMetrics` has been explicitly set.
  public var hasCumulativeMetrics: Bool {return _storage._cumulativeMetrics != nil}
  /// Clears the value of `cumulativeMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearCumulativeMetrics() {_uniqueStorage()._cumulativeMetrics = nil}

  public var artifactMetrics: BuildEventStream_BuildMetrics.ArtifactMetrics {
    get {return _storage._artifactMetrics ?? BuildEventStream_BuildMetrics.ArtifactMetrics()}
    set {_uniqueStorage()._artifactMetrics = newValue}
  }
  /// Returns true if `artifactMetrics` has been explicitly set.
  public var hasArtifactMetrics: Bool {return _storage._artifactMetrics != nil}
  /// Clears the value of `artifactMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearArtifactMetrics() {_uniqueStorage()._artifactMetrics = nil}

  public var buildGraphMetrics: BuildEventStream_BuildMetrics.BuildGraphMetrics {
    get {return _storage._buildGraphMetrics ?? BuildEventStream_BuildMetrics.BuildGraphMetrics()}
    set {_uniqueStorage()._buildGraphMetrics = newValue}
  }
  /// Returns true if `buildGraphMetrics` has been explicitly set.
  public var hasBuildGraphMetrics: Bool {return _storage._buildGraphMetrics != nil}
  /// Clears the value of `buildGraphMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearBuildGraphMetrics() {_uniqueStorage()._buildGraphMetrics = nil}

  public var workerMetrics: [BuildEventStream_BuildMetrics.WorkerMetrics] {
    get {return _storage._workerMetrics}
    set {_uniqueStorage()._workerMetrics = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ActionSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total number of actions created and registered during the build,
    /// including both aspects and configured targets. This metric includes
    /// unused actions that were constructed but not executed during this build.
    /// It does not include actions that were created on prior builds that are
    /// still valid, even if those actions had to be re-executed on this build.
    /// For the total number of actions that would be created if this invocation
    /// were "clean", see BuildGraphMetrics below.
    public var actionsCreated: Int64 = 0

    /// The total number of actions created this build just by configured
    /// targets. Used mainly to allow consumers of actions_created, which used to
    /// not include aspects' actions, to normalize across the Blaze release that
    /// switched actions_created to include all created actions.
    public var actionsCreatedNotIncludingAspects: Int64 = 0

    /// The total number of actions executed during the build. This includes any
    /// remote cache hits, but excludes local action cache hits.
    public var actionsExecuted: Int64 = 0

    /// Contains the top N actions by number of actions executed.
    public var actionData: [BuildEventStream_BuildMetrics.ActionSummary.ActionData] = []

    /// Deprecated. The total number of remote cache hits.
    public var remoteCacheHits: Int64 = 0

    public var runnerCount: [BuildEventStream_BuildMetrics.ActionSummary.RunnerCount] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ActionData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var mnemonic: String = String()

      /// The total number of actions of this type executed during the build. As
      /// above, includes remote cache hits but excludes local action cache hits.
      public var actionsExecuted: Int64 = 0

      /// When the first action of this type started being executed, in
      /// milliseconds from the epoch.
      public var firstStartedMs: Int64 = 0

      /// When the last action of this type ended being executed, in
      /// milliseconds from the epoch.
      public var lastEndedMs: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct RunnerCount {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var count: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct MemoryMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Size of the JVM heap post build in bytes. This is only collected if
    /// --memory_profile is set, since it forces a full GC.
    public var usedHeapSizePostBuild: Int64 = 0

    /// Size of the peak JVM heap size in bytes post GC. Note that this reports 0
    /// if there was no major GC during the build.
    public var peakPostGcHeapSize: Int64 = 0

    /// Size of the peak tenured space JVM heap size event in bytes post GC. Note
    /// that this reports 0 if there was no major GC during the build.
    public var peakPostGcTenuredSpaceHeapSize: Int64 = 0

    public var garbageMetrics: [BuildEventStream_BuildMetrics.MemoryMetrics.GarbageMetrics] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct GarbageMetrics {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Type of garbage collected, e.g. G1 Old Gen.
      public var type: String = String()

      /// Number of bytes of garbage of the given type collected during this
      /// invocation.
      public var garbageCollected: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct TargetMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// DEPRECATED
    /// No longer populated. It never measured what it was supposed to (targets
    /// loaded): it counted targets that were analyzed even if the underlying
    /// package had not changed.
    /// TODO(janakr): rename and remove.
    public var targetsLoaded: Int64 = 0

    /// Number of targets/aspects configured during this build. Does not include
    /// targets/aspects that were configured on prior builds on this server and
    /// were cached. See BuildGraphMetrics below if you need that.
    public var targetsConfigured: Int64 = 0

    /// Number of configured targets analyzed during this build. Does not include
    /// aspects. Used mainly to allow consumers of targets_configured, which used
    /// to not include aspects, to normalize across the Blaze release that
    /// switched targets_configured to include aspects.
    public var targetsConfiguredNotIncludingAspects: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PackageMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of BUILD files (aka packages) successfully loaded during this
    /// build.
    ///
    /// [For Bazel binaries built at source states] Before Dec 2021, this value
    /// was the number of packages attempted to be loaded, for a particular
    /// definition of "attempted".
    ///
    /// After Dec 2021, this value would sometimes overcount because the same
    /// package could sometimes be attempted to be loaded multiple times due to
    /// memory pressure.
    ///
    /// After Feb 2022, this value is the number of packages successfully
    /// loaded.
    public var packagesLoaded: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TimingMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The CPU time in milliseconds consumed during this build.
    public var cpuTimeInMs: Int64 = 0

    /// The elapsed wall time in milliseconds during this build.
    public var wallTimeInMs: Int64 = 0

    /// The elapsed wall time in milliseconds during the analysis phase.
    /// When analysis and execution phases are interleaved, this measures the
    /// elapsed time from the first analysis work to the last.
    public var analysisPhaseTimeInMs: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CumulativeMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// One-indexed number of "analyses" the server has run, including the
    /// current one. Will be incremented for every build/test/cquery/etc. command
    /// that reaches the analysis phase.
    public var numAnalyses: Int32 = 0

    /// One-indexed number of "builds" the server has run, including the current
    /// one. Will be incremented for every build/test/run/etc. command that
    /// reaches the execution phase.
    public var numBuilds: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ArtifactMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Measures all source files newly read this build. Does not include
    /// unchanged sources on incremental builds.
    public var sourceArtifactsRead: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _sourceArtifactsRead ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_sourceArtifactsRead = newValue}
    }
    /// Returns true if `sourceArtifactsRead` has been explicitly set.
    public var hasSourceArtifactsRead: Bool {return self._sourceArtifactsRead != nil}
    /// Clears the value of `sourceArtifactsRead`. Subsequent reads from it will return its default value.
    public mutating func clearSourceArtifactsRead() {self._sourceArtifactsRead = nil}

    /// Measures all output artifacts from executed actions. This includes
    /// actions that were cached locally (via the action cache) or remotely (via
    /// a remote cache or executor), but does *not* include outputs of actions
    /// that were cached internally in Skyframe.
    public var outputArtifactsSeen: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _outputArtifactsSeen ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_outputArtifactsSeen = newValue}
    }
    /// Returns true if `outputArtifactsSeen` has been explicitly set.
    public var hasOutputArtifactsSeen: Bool {return self._outputArtifactsSeen != nil}
    /// Clears the value of `outputArtifactsSeen`. Subsequent reads from it will return its default value.
    public mutating func clearOutputArtifactsSeen() {self._outputArtifactsSeen = nil}

    /// Measures all output artifacts from actions that were cached locally
    /// via the action cache. These artifacts were already present on disk at the
    /// start of the build. Does not include Skyframe-cached actions' outputs.
    public var outputArtifactsFromActionCache: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _outputArtifactsFromActionCache ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_outputArtifactsFromActionCache = newValue}
    }
    /// Returns true if `outputArtifactsFromActionCache` has been explicitly set.
    public var hasOutputArtifactsFromActionCache: Bool {return self._outputArtifactsFromActionCache != nil}
    /// Clears the value of `outputArtifactsFromActionCache`. Subsequent reads from it will return its default value.
    public mutating func clearOutputArtifactsFromActionCache() {self._outputArtifactsFromActionCache = nil}

    /// Measures all artifacts that belong to a top-level output group. Does not
    /// deduplicate, so if there are two top-level targets in this build that
    /// share an artifact, it will be counted twice.
    public var topLevelArtifacts: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric {
      get {return _topLevelArtifacts ?? BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric()}
      set {_topLevelArtifacts = newValue}
    }
    /// Returns true if `topLevelArtifacts` has been explicitly set.
    public var hasTopLevelArtifacts: Bool {return self._topLevelArtifacts != nil}
    /// Clears the value of `topLevelArtifacts`. Subsequent reads from it will return its default value.
    public mutating func clearTopLevelArtifacts() {self._topLevelArtifacts = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct FilesMetric {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var sizeInBytes: Int64 = 0

      public var count: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _sourceArtifactsRead: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
    fileprivate var _outputArtifactsSeen: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
    fileprivate var _outputArtifactsFromActionCache: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
    fileprivate var _topLevelArtifacts: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric? = nil
  }

  /// Information about the size and shape of the build graph. Some fields may
  /// not be populated if Bazel was able to skip steps due to caching.
  public struct BuildGraphMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How many configured targets/aspects were in this build, including any
    /// that were analyzed on a prior build and are still valid. May not be
    /// populated if analysis phase was fully cached. Note: for historical
    /// reasons this includes input/output files and other configured targets
    /// that do not actually have associated actions.
    public var actionLookupValueCount: Int32 = 0

    /// How many configured targets alone were in this build: always at most
    /// action_lookup_value_count. Useful mainly for historical comparisons to
    /// TargetMetrics.targets_configured, which used to not count aspects. This
    /// also includes configured targets that do not have associated actions.
    public var actionLookupValueCountNotIncludingAspects: Int32 = 0

    /// How many actions belonged to the configured targets/aspects above. It may
    /// not be necessary to execute all of these actions to build the requested
    /// targets. May not be populated if analysis phase was fully cached.
    public var actionCount: Int32 = 0

    /// How many actions belonged to configured targets: always at most
    /// action_count. Useful mainly for historical comparisons to
    /// ActionMetrics.actions_created, which used to not count aspects' actions.
    public var actionCountNotIncludingAspects: Int32 = 0

    /// How many "input file" configured targets there were: one per source file.
    /// Should agree with artifact_metrics.source_artifacts_read.count above,
    public var inputFileConfiguredTargetCount: Int32 = 0

    /// How many "output file" configured targets there were: output files that
    /// are targets (not implicit outputs).
    public var outputFileConfiguredTargetCount: Int32 = 0

    /// How many "other" configured targets there were (like alias,
    /// package_group, and other non-rule non-file configured targets).
    public var otherConfiguredTargetCount: Int32 = 0

    /// How many artifacts are outputs of the above actions. May not be populated
    /// if analysis phase was fully cached.
    public var outputArtifactCount: Int32 = 0

    /// How many Skyframe nodes there are in memory at the end of the build. This
    /// may underestimate the number of nodes when running with memory-saving
    /// settings or with Skybuild, and may overestimate if there are nodes from
    /// prior evaluations still in the cache.
    public var postInvocationSkyframeNodeCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Information about all workers that were alive during the invocation.
  public struct WorkerMetrics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique id of worker.
    public var workerID: Int32 = 0

    /// Worker process id. If there is no process for worker, equals to zero.
    public var processID: UInt32 = 0

    /// Mnemonic of running worker.
    public var mnemonic: String = String()

    /// Multiplex or singleplex worker.
    public var isMultiplex: Bool = false

    /// Using worker sandbox file system or not.
    public var isSandbox: Bool = false

    /// Shows is worker stats measured at the end of invocation.
    public var isMeasurable: Bool = false

    /// Combined workers statistics.
    public var workerStats: [BuildEventStream_BuildMetrics.WorkerMetrics.WorkerStats] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Information collected from worker at some point.
    public struct WorkerStats {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Epoch unix time of collection of metrics.
      public var collectTimeInMs: Int64 = 0

      /// RSS size of worker process.
      public var workerMemoryInKb: Int32 = 0

      /// Epoch unix time of last action started on specific worker.
      public var lastActionStartTimeInMs: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Event providing additional statistics/logs after completion of the build.
public struct BuildEventStream_BuildToolLogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var log: [BuildEventStream_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Event describing all convenience symlinks (i.e., workspace symlinks) to be
/// created or deleted once the execution phase has begun. Note that this event
/// does not say anything about whether or not the build tool actually executed
/// these filesystem operations; it only says what logical operations should be
/// performed. This event is emitted exactly once per build; if no symlinks are
/// to be modified, the event is still emitted with empty contents.
public struct BuildEventStream_ConvenienceSymlinksIdentified {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var convenienceSymlinks: [BuildEventStream_ConvenienceSymlink] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The message that contains what type of action to perform on a given path and
/// target of a symlink.
public struct BuildEventStream_ConvenienceSymlink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path of the symlink to be created or deleted, absolute or relative to
  /// the workspace, creating any directories necessary. If a symlink already
  /// exists at that location, then it should be replaced by a symlink pointing
  /// to the new target.
  public var path: String = String()

  /// The operation we are performing on the symlink.
  public var action: BuildEventStream_ConvenienceSymlink.Action = .unknown

  /// If action is CREATE, this is the target path that the symlink should point
  /// to. If the path points underneath the output base, it is relative to the
  /// output base; otherwise it is absolute.
  ///
  /// If action is DELETE, this field is not set.
  public var target: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Indicates a symlink should be created, or overwritten if it already
    /// exists.
    case create // = 1

    /// Indicates a symlink should be deleted if it already exists.
    case delete // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .create
      case 2: self = .delete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .create: return 1
      case .delete: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension BuildEventStream_ConvenienceSymlink.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [BuildEventStream_ConvenienceSymlink.Action] = [
    .unknown,
    .create,
    .delete,
  ]
}

#endif  // swift(>=4.2)

/// Message describing a build event. Events will have an identifier that
/// is unique within a given build invocation; they also announce follow-up
/// events as children. More details, which are specific to the kind of event
/// that is observed, is provided in the payload. More options for the payload
/// might be added in the future.
public struct BuildEventStream_BuildEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: BuildEventStream_BuildEventId {
    get {return _storage._id ?? BuildEventStream_BuildEventId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var children: [BuildEventStream_BuildEventId] {
    get {return _storage._children}
    set {_uniqueStorage()._children = newValue}
  }

  public var lastMessage: Bool {
    get {return _storage._lastMessage}
    set {_uniqueStorage()._lastMessage = newValue}
  }

  public var payload: OneOf_Payload? {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  public var progress: BuildEventStream_Progress {
    get {
      if case .progress(let v)? = _storage._payload {return v}
      return BuildEventStream_Progress()
    }
    set {_uniqueStorage()._payload = .progress(newValue)}
  }

  public var aborted: BuildEventStream_Aborted {
    get {
      if case .aborted(let v)? = _storage._payload {return v}
      return BuildEventStream_Aborted()
    }
    set {_uniqueStorage()._payload = .aborted(newValue)}
  }

  public var started: BuildEventStream_BuildStarted {
    get {
      if case .started(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildStarted()
    }
    set {_uniqueStorage()._payload = .started(newValue)}
  }

  public var unstructuredCommandLine: BuildEventStream_UnstructuredCommandLine {
    get {
      if case .unstructuredCommandLine(let v)? = _storage._payload {return v}
      return BuildEventStream_UnstructuredCommandLine()
    }
    set {_uniqueStorage()._payload = .unstructuredCommandLine(newValue)}
  }

  public var structuredCommandLine: CommandLine_CommandLine {
    get {
      if case .structuredCommandLine(let v)? = _storage._payload {return v}
      return CommandLine_CommandLine()
    }
    set {_uniqueStorage()._payload = .structuredCommandLine(newValue)}
  }

  public var optionsParsed: BuildEventStream_OptionsParsed {
    get {
      if case .optionsParsed(let v)? = _storage._payload {return v}
      return BuildEventStream_OptionsParsed()
    }
    set {_uniqueStorage()._payload = .optionsParsed(newValue)}
  }

  public var workspaceStatus: BuildEventStream_WorkspaceStatus {
    get {
      if case .workspaceStatus(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceStatus()
    }
    set {_uniqueStorage()._payload = .workspaceStatus(newValue)}
  }

  public var fetch: BuildEventStream_Fetch {
    get {
      if case .fetch(let v)? = _storage._payload {return v}
      return BuildEventStream_Fetch()
    }
    set {_uniqueStorage()._payload = .fetch(newValue)}
  }

  public var configuration: BuildEventStream_Configuration {
    get {
      if case .configuration(let v)? = _storage._payload {return v}
      return BuildEventStream_Configuration()
    }
    set {_uniqueStorage()._payload = .configuration(newValue)}
  }

  public var expanded: BuildEventStream_PatternExpanded {
    get {
      if case .expanded(let v)? = _storage._payload {return v}
      return BuildEventStream_PatternExpanded()
    }
    set {_uniqueStorage()._payload = .expanded(newValue)}
  }

  public var configured: BuildEventStream_TargetConfigured {
    get {
      if case .configured(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetConfigured()
    }
    set {_uniqueStorage()._payload = .configured(newValue)}
  }

  public var action: BuildEventStream_ActionExecuted {
    get {
      if case .action(let v)? = _storage._payload {return v}
      return BuildEventStream_ActionExecuted()
    }
    set {_uniqueStorage()._payload = .action(newValue)}
  }

  public var namedSetOfFiles: BuildEventStream_NamedSetOfFiles {
    get {
      if case .namedSetOfFiles(let v)? = _storage._payload {return v}
      return BuildEventStream_NamedSetOfFiles()
    }
    set {_uniqueStorage()._payload = .namedSetOfFiles(newValue)}
  }

  public var completed: BuildEventStream_TargetComplete {
    get {
      if case .completed(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetComplete()
    }
    set {_uniqueStorage()._payload = .completed(newValue)}
  }

  public var testResult: BuildEventStream_TestResult {
    get {
      if case .testResult(let v)? = _storage._payload {return v}
      return BuildEventStream_TestResult()
    }
    set {_uniqueStorage()._payload = .testResult(newValue)}
  }

  public var testSummary: BuildEventStream_TestSummary {
    get {
      if case .testSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TestSummary()
    }
    set {_uniqueStorage()._payload = .testSummary(newValue)}
  }

  public var targetSummary: BuildEventStream_TargetSummary {
    get {
      if case .targetSummary(let v)? = _storage._payload {return v}
      return BuildEventStream_TargetSummary()
    }
    set {_uniqueStorage()._payload = .targetSummary(newValue)}
  }

  public var finished: BuildEventStream_BuildFinished {
    get {
      if case .finished(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildFinished()
    }
    set {_uniqueStorage()._payload = .finished(newValue)}
  }

  public var buildToolLogs: BuildEventStream_BuildToolLogs {
    get {
      if case .buildToolLogs(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildToolLogs()
    }
    set {_uniqueStorage()._payload = .buildToolLogs(newValue)}
  }

  public var buildMetrics: BuildEventStream_BuildMetrics {
    get {
      if case .buildMetrics(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetrics()
    }
    set {_uniqueStorage()._payload = .buildMetrics(newValue)}
  }

  public var workspaceInfo: BuildEventStream_WorkspaceConfig {
    get {
      if case .workspaceInfo(let v)? = _storage._payload {return v}
      return BuildEventStream_WorkspaceConfig()
    }
    set {_uniqueStorage()._payload = .workspaceInfo(newValue)}
  }

  public var buildMetadata: BuildEventStream_BuildMetadata {
    get {
      if case .buildMetadata(let v)? = _storage._payload {return v}
      return BuildEventStream_BuildMetadata()
    }
    set {_uniqueStorage()._payload = .buildMetadata(newValue)}
  }

  public var convenienceSymlinksIdentified: BuildEventStream_ConvenienceSymlinksIdentified {
    get {
      if case .convenienceSymlinksIdentified(let v)? = _storage._payload {return v}
      return BuildEventStream_ConvenienceSymlinksIdentified()
    }
    set {_uniqueStorage()._payload = .convenienceSymlinksIdentified(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case progress(BuildEventStream_Progress)
    case aborted(BuildEventStream_Aborted)
    case started(BuildEventStream_BuildStarted)
    case unstructuredCommandLine(BuildEventStream_UnstructuredCommandLine)
    case structuredCommandLine(CommandLine_CommandLine)
    case optionsParsed(BuildEventStream_OptionsParsed)
    case workspaceStatus(BuildEventStream_WorkspaceStatus)
    case fetch(BuildEventStream_Fetch)
    case configuration(BuildEventStream_Configuration)
    case expanded(BuildEventStream_PatternExpanded)
    case configured(BuildEventStream_TargetConfigured)
    case action(BuildEventStream_ActionExecuted)
    case namedSetOfFiles(BuildEventStream_NamedSetOfFiles)
    case completed(BuildEventStream_TargetComplete)
    case testResult(BuildEventStream_TestResult)
    case testSummary(BuildEventStream_TestSummary)
    case targetSummary(BuildEventStream_TargetSummary)
    case finished(BuildEventStream_BuildFinished)
    case buildToolLogs(BuildEventStream_BuildToolLogs)
    case buildMetrics(BuildEventStream_BuildMetrics)
    case workspaceInfo(BuildEventStream_WorkspaceConfig)
    case buildMetadata(BuildEventStream_BuildMetadata)
    case convenienceSymlinksIdentified(BuildEventStream_ConvenienceSymlinksIdentified)

  #if !swift(>=4.1)
    public static func ==(lhs: BuildEventStream_BuildEvent.OneOf_Payload, rhs: BuildEventStream_BuildEvent.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.progress, .progress): return {
        guard case .progress(let l) = lhs, case .progress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aborted, .aborted): return {
        guard case .aborted(let l) = lhs, case .aborted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.started, .started): return {
        guard case .started(let l) = lhs, case .started(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unstructuredCommandLine, .unstructuredCommandLine): return {
        guard case .unstructuredCommandLine(let l) = lhs, case .unstructuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.structuredCommandLine, .structuredCommandLine): return {
        guard case .structuredCommandLine(let l) = lhs, case .structuredCommandLine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.optionsParsed, .optionsParsed): return {
        guard case .optionsParsed(let l) = lhs, case .optionsParsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceStatus, .workspaceStatus): return {
        guard case .workspaceStatus(let l) = lhs, case .workspaceStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fetch, .fetch): return {
        guard case .fetch(let l) = lhs, case .fetch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuration, .configuration): return {
        guard case .configuration(let l) = lhs, case .configuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expanded, .expanded): return {
        guard case .expanded(let l) = lhs, case .expanded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configured, .configured): return {
        guard case .configured(let l) = lhs, case .configured(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.namedSetOfFiles, .namedSetOfFiles): return {
        guard case .namedSetOfFiles(let l) = lhs, case .namedSetOfFiles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.completed, .completed): return {
        guard case .completed(let l) = lhs, case .completed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testResult, .testResult): return {
        guard case .testResult(let l) = lhs, case .testResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testSummary, .testSummary): return {
        guard case .testSummary(let l) = lhs, case .testSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetSummary, .targetSummary): return {
        guard case .targetSummary(let l) = lhs, case .targetSummary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finished, .finished): return {
        guard case .finished(let l) = lhs, case .finished(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildToolLogs, .buildToolLogs): return {
        guard case .buildToolLogs(let l) = lhs, case .buildToolLogs(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetrics, .buildMetrics): return {
        guard case .buildMetrics(let l) = lhs, case .buildMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceInfo, .workspaceInfo): return {
        guard case .workspaceInfo(let l) = lhs, case .workspaceInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildMetadata, .buildMetadata): return {
        guard case .buildMetadata(let l) = lhs, case .buildMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.convenienceSymlinksIdentified, .convenienceSymlinksIdentified): return {
        guard case .convenienceSymlinksIdentified(let l) = lhs, case .convenienceSymlinksIdentified(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BuildEventStream_TestSize: @unchecked Sendable {}
extension BuildEventStream_TestStatus: @unchecked Sendable {}
extension BuildEventStream_BuildEventId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.OneOf_ID: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.UnknownBuildEventId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.ProgressId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.BuildStartedId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.UnstructuredCommandLineId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.StructuredCommandLineId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.WorkspaceStatusId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.OptionsParsedId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.FetchId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.PatternExpandedId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.WorkspaceConfigId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.BuildMetadataId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.TargetConfiguredId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.NamedSetOfFilesId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.ConfigurationId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.TargetCompletedId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.ActionCompletedId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.UnconfiguredLabelId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.ConfiguredLabelId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.TestResultId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.TestSummaryId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.TargetSummaryId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.BuildFinishedId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.BuildToolLogsId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.BuildMetricsId: @unchecked Sendable {}
extension BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId: @unchecked Sendable {}
extension BuildEventStream_Progress: @unchecked Sendable {}
extension BuildEventStream_Aborted: @unchecked Sendable {}
extension BuildEventStream_Aborted.AbortReason: @unchecked Sendable {}
extension BuildEventStream_BuildStarted: @unchecked Sendable {}
extension BuildEventStream_WorkspaceConfig: @unchecked Sendable {}
extension BuildEventStream_UnstructuredCommandLine: @unchecked Sendable {}
extension BuildEventStream_OptionsParsed: @unchecked Sendable {}
extension BuildEventStream_Fetch: @unchecked Sendable {}
extension BuildEventStream_WorkspaceStatus: @unchecked Sendable {}
extension BuildEventStream_WorkspaceStatus.Item: @unchecked Sendable {}
extension BuildEventStream_BuildMetadata: @unchecked Sendable {}
extension BuildEventStream_Configuration: @unchecked Sendable {}
extension BuildEventStream_PatternExpanded: @unchecked Sendable {}
extension BuildEventStream_PatternExpanded.TestSuiteExpansion: @unchecked Sendable {}
extension BuildEventStream_TargetConfigured: @unchecked Sendable {}
extension BuildEventStream_File: @unchecked Sendable {}
extension BuildEventStream_File.OneOf_File: @unchecked Sendable {}
extension BuildEventStream_NamedSetOfFiles: @unchecked Sendable {}
extension BuildEventStream_ActionExecuted: @unchecked Sendable {}
extension BuildEventStream_OutputGroup: @unchecked Sendable {}
extension BuildEventStream_TargetComplete: @unchecked Sendable {}
extension BuildEventStream_TestResult: @unchecked Sendable {}
extension BuildEventStream_TestResult.ExecutionInfo: @unchecked Sendable {}
extension BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown: @unchecked Sendable {}
extension BuildEventStream_TestResult.ExecutionInfo.ResourceUsage: @unchecked Sendable {}
extension BuildEventStream_TestSummary: @unchecked Sendable {}
extension BuildEventStream_TargetSummary: @unchecked Sendable {}
extension BuildEventStream_BuildFinished: @unchecked Sendable {}
extension BuildEventStream_BuildFinished.ExitCode: @unchecked Sendable {}
extension BuildEventStream_BuildFinished.AnomalyReport: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.ActionSummary: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.ActionSummary.ActionData: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.ActionSummary.RunnerCount: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.MemoryMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.MemoryMetrics.GarbageMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.TargetMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.PackageMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.TimingMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.CumulativeMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.ArtifactMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.BuildGraphMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.WorkerMetrics: @unchecked Sendable {}
extension BuildEventStream_BuildMetrics.WorkerMetrics.WorkerStats: @unchecked Sendable {}
extension BuildEventStream_BuildToolLogs: @unchecked Sendable {}
extension BuildEventStream_ConvenienceSymlinksIdentified: @unchecked Sendable {}
extension BuildEventStream_ConvenienceSymlink: @unchecked Sendable {}
extension BuildEventStream_ConvenienceSymlink.Action: @unchecked Sendable {}
extension BuildEventStream_BuildEvent: @unchecked Sendable {}
extension BuildEventStream_BuildEvent.OneOf_Payload: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "build_event_stream"

extension BuildEventStream_TestSize: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SMALL"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "LARGE"),
    4: .same(proto: "ENORMOUS"),
  ]
}

extension BuildEventStream_TestStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_STATUS"),
    1: .same(proto: "PASSED"),
    2: .same(proto: "FLAKY"),
    3: .same(proto: "TIMEOUT"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "INCOMPLETE"),
    6: .same(proto: "REMOTE_FAILURE"),
    7: .same(proto: "FAILED_TO_BUILD"),
    8: .same(proto: "TOOL_HALTED_BEFORE_TESTING"),
  ]
}

extension BuildEventStream_BuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unknown"),
    2: .same(proto: "progress"),
    3: .same(proto: "started"),
    11: .standard(proto: "unstructured_command_line"),
    18: .standard(proto: "structured_command_line"),
    14: .standard(proto: "workspace_status"),
    12: .standard(proto: "options_parsed"),
    17: .same(proto: "fetch"),
    15: .same(proto: "configuration"),
    16: .standard(proto: "target_configured"),
    4: .same(proto: "pattern"),
    10: .standard(proto: "pattern_skipped"),
    13: .standard(proto: "named_set"),
    5: .standard(proto: "target_completed"),
    6: .standard(proto: "action_completed"),
    19: .standard(proto: "unconfigured_label"),
    21: .standard(proto: "configured_label"),
    8: .standard(proto: "test_result"),
    7: .standard(proto: "test_summary"),
    26: .standard(proto: "target_summary"),
    9: .standard(proto: "build_finished"),
    20: .standard(proto: "build_tool_logs"),
    22: .standard(proto: "build_metrics"),
    23: .same(proto: "workspace"),
    24: .standard(proto: "build_metadata"),
    25: .standard(proto: "convenience_symlinks_identified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: BuildEventStream_BuildEventId.UnknownBuildEventId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .unknown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .unknown(v)
        }
      }()
      case 2: try {
        var v: BuildEventStream_BuildEventId.ProgressId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .progress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .progress(v)
        }
      }()
      case 3: try {
        var v: BuildEventStream_BuildEventId.BuildStartedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .started(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .started(v)
        }
      }()
      case 4: try {
        var v: BuildEventStream_BuildEventId.PatternExpandedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .pattern(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .pattern(v)
        }
      }()
      case 5: try {
        var v: BuildEventStream_BuildEventId.TargetCompletedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .targetCompleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .targetCompleted(v)
        }
      }()
      case 6: try {
        var v: BuildEventStream_BuildEventId.ActionCompletedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .actionCompleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .actionCompleted(v)
        }
      }()
      case 7: try {
        var v: BuildEventStream_BuildEventId.TestSummaryId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .testSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .testSummary(v)
        }
      }()
      case 8: try {
        var v: BuildEventStream_BuildEventId.TestResultId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .testResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .testResult(v)
        }
      }()
      case 9: try {
        var v: BuildEventStream_BuildEventId.BuildFinishedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildFinished(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildFinished(v)
        }
      }()
      case 10: try {
        var v: BuildEventStream_BuildEventId.PatternExpandedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .patternSkipped(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .patternSkipped(v)
        }
      }()
      case 11: try {
        var v: BuildEventStream_BuildEventId.UnstructuredCommandLineId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .unstructuredCommandLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .unstructuredCommandLine(v)
        }
      }()
      case 12: try {
        var v: BuildEventStream_BuildEventId.OptionsParsedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .optionsParsed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .optionsParsed(v)
        }
      }()
      case 13: try {
        var v: BuildEventStream_BuildEventId.NamedSetOfFilesId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .namedSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .namedSet(v)
        }
      }()
      case 14: try {
        var v: BuildEventStream_BuildEventId.WorkspaceStatusId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .workspaceStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .workspaceStatus(v)
        }
      }()
      case 15: try {
        var v: BuildEventStream_BuildEventId.ConfigurationId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .configuration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .configuration(v)
        }
      }()
      case 16: try {
        var v: BuildEventStream_BuildEventId.TargetConfiguredId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .targetConfigured(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .targetConfigured(v)
        }
      }()
      case 17: try {
        var v: BuildEventStream_BuildEventId.FetchId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .fetch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .fetch(v)
        }
      }()
      case 18: try {
        var v: BuildEventStream_BuildEventId.StructuredCommandLineId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .structuredCommandLine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .structuredCommandLine(v)
        }
      }()
      case 19: try {
        var v: BuildEventStream_BuildEventId.UnconfiguredLabelId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .unconfiguredLabel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .unconfiguredLabel(v)
        }
      }()
      case 20: try {
        var v: BuildEventStream_BuildEventId.BuildToolLogsId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildToolLogs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildToolLogs(v)
        }
      }()
      case 21: try {
        var v: BuildEventStream_BuildEventId.ConfiguredLabelId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .configuredLabel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .configuredLabel(v)
        }
      }()
      case 22: try {
        var v: BuildEventStream_BuildEventId.BuildMetricsId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildMetrics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildMetrics(v)
        }
      }()
      case 23: try {
        var v: BuildEventStream_BuildEventId.WorkspaceConfigId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .workspace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .workspace(v)
        }
      }()
      case 24: try {
        var v: BuildEventStream_BuildEventId.BuildMetadataId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .buildMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .buildMetadata(v)
        }
      }()
      case 25: try {
        var v: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .convenienceSymlinksIdentified(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .convenienceSymlinksIdentified(v)
        }
      }()
      case 26: try {
        var v: BuildEventStream_BuildEventId.TargetSummaryId?
        var hadOneofValue = false
        if let current = self.id {
          hadOneofValue = true
          if case .targetSummary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.id = .targetSummary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.id {
    case .unknown?: try {
      guard case .unknown(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .progress?: try {
      guard case .progress(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .started?: try {
      guard case .started(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .pattern?: try {
      guard case .pattern(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .targetCompleted?: try {
      guard case .targetCompleted(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .actionCompleted?: try {
      guard case .actionCompleted(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .testSummary?: try {
      guard case .testSummary(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .testResult?: try {
      guard case .testResult(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .buildFinished?: try {
      guard case .buildFinished(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .patternSkipped?: try {
      guard case .patternSkipped(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .unstructuredCommandLine?: try {
      guard case .unstructuredCommandLine(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .optionsParsed?: try {
      guard case .optionsParsed(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .namedSet?: try {
      guard case .namedSet(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .workspaceStatus?: try {
      guard case .workspaceStatus(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .configuration?: try {
      guard case .configuration(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .targetConfigured?: try {
      guard case .targetConfigured(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .fetch?: try {
      guard case .fetch(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .structuredCommandLine?: try {
      guard case .structuredCommandLine(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .unconfiguredLabel?: try {
      guard case .unconfiguredLabel(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .buildToolLogs?: try {
      guard case .buildToolLogs(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .configuredLabel?: try {
      guard case .configuredLabel(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .buildMetrics?: try {
      guard case .buildMetrics(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .workspace?: try {
      guard case .workspace(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .buildMetadata?: try {
      guard case .buildMetadata(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .convenienceSymlinksIdentified?: try {
      guard case .convenienceSymlinksIdentified(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .targetSummary?: try {
      guard case .targetSummary(let v)? = self.id else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId, rhs: BuildEventStream_BuildEventId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnknownBuildEventId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnknownBuildEventId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnknownBuildEventId, rhs: BuildEventStream_BuildEventId.UnknownBuildEventId) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ProgressId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ProgressId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "opaque_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.opaqueCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.opaqueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.opaqueCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ProgressId, rhs: BuildEventStream_BuildEventId.ProgressId) -> Bool {
    if lhs.opaqueCount != rhs.opaqueCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildStartedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildStartedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildStartedId, rhs: BuildEventStream_BuildEventId.BuildStartedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnstructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnstructuredCommandLineId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId, rhs: BuildEventStream_BuildEventId.UnstructuredCommandLineId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.StructuredCommandLineId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".StructuredCommandLineId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_line_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commandLineLabel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commandLineLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.commandLineLabel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.StructuredCommandLineId, rhs: BuildEventStream_BuildEventId.StructuredCommandLineId) -> Bool {
    if lhs.commandLineLabel != rhs.commandLineLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceStatusId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceStatusId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceStatusId, rhs: BuildEventStream_BuildEventId.WorkspaceStatusId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.OptionsParsedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".OptionsParsedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.OptionsParsedId, rhs: BuildEventStream_BuildEventId.OptionsParsedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.FetchId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".FetchId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.FetchId, rhs: BuildEventStream_BuildEventId.FetchId) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.PatternExpandedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".PatternExpandedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pattern) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pattern.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.PatternExpandedId, rhs: BuildEventStream_BuildEventId.PatternExpandedId) -> Bool {
    if lhs.pattern != rhs.pattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.WorkspaceConfigId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".WorkspaceConfigId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.WorkspaceConfigId, rhs: BuildEventStream_BuildEventId.WorkspaceConfigId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetadataId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetadataId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetadataId, rhs: BuildEventStream_BuildEventId.BuildMetadataId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetConfiguredId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetConfiguredId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.aspect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetConfiguredId, rhs: BuildEventStream_BuildEventId.TargetConfiguredId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.NamedSetOfFilesId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".NamedSetOfFilesId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.NamedSetOfFilesId, rhs: BuildEventStream_BuildEventId.NamedSetOfFilesId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfigurationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfigurationId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfigurationId, rhs: BuildEventStream_BuildEventId.ConfigurationId) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    3: .same(proto: "configuration"),
    2: .same(proto: "aspect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.aspect) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.aspect.isEmpty {
      try visitor.visitSingularStringField(value: self.aspect, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetCompletedId, rhs: BuildEventStream_BuildEventId.TargetCompletedId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ActionCompletedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ActionCompletedId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primary_output"),
    2: .same(proto: "label"),
    3: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.primaryOutput) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.primaryOutput.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryOutput, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ActionCompletedId, rhs: BuildEventStream_BuildEventId.ActionCompletedId) -> Bool {
    if lhs.primaryOutput != rhs.primaryOutput {return false}
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.UnconfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".UnconfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.UnconfiguredLabelId, rhs: BuildEventStream_BuildEventId.UnconfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConfiguredLabelId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConfiguredLabelId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConfiguredLabelId, rhs: BuildEventStream_BuildEventId.ConfiguredLabelId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestResultId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestResultId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    5: .same(proto: "configuration"),
    2: .same(proto: "run"),
    3: .same(proto: "shard"),
    4: .same(proto: "attempt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.run) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.shard) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.run != 0 {
      try visitor.visitSingularInt32Field(value: self.run, fieldNumber: 2)
    }
    if self.shard != 0 {
      try visitor.visitSingularInt32Field(value: self.shard, fieldNumber: 3)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 4)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestResultId, rhs: BuildEventStream_BuildEventId.TestResultId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.run != rhs.run {return false}
    if lhs.shard != rhs.shard {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TestSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TestSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TestSummaryId, rhs: BuildEventStream_BuildEventId.TestSummaryId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.TargetSummaryId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".TargetSummaryId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "configuration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.TargetSummaryId, rhs: BuildEventStream_BuildEventId.TargetSummaryId) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildFinishedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildFinishedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildFinishedId, rhs: BuildEventStream_BuildEventId.BuildFinishedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildToolLogsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildToolLogsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildToolLogsId, rhs: BuildEventStream_BuildEventId.BuildToolLogsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.BuildMetricsId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".BuildMetricsId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.BuildMetricsId, rhs: BuildEventStream_BuildEventId.BuildMetricsId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildEventId.protoMessageName + ".ConvenienceSymlinksIdentifiedId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId, rhs: BuildEventStream_BuildEventId.ConvenienceSymlinksIdentifiedId) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stdout"),
    2: .same(proto: "stderr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stdout) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stderr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stdout.isEmpty {
      try visitor.visitSingularStringField(value: self.stdout, fieldNumber: 1)
    }
    if !self.stderr.isEmpty {
      try visitor.visitSingularStringField(value: self.stderr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Progress, rhs: BuildEventStream_Progress) -> Bool {
    if lhs.stdout != rhs.stdout {return false}
    if lhs.stderr != rhs.stderr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aborted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unknown {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Aborted, rhs: BuildEventStream_Aborted) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Aborted.AbortReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "USER_INTERRUPTED"),
    2: .same(proto: "TIME_OUT"),
    3: .same(proto: "REMOTE_ENVIRONMENT_FAILURE"),
    4: .same(proto: "INTERNAL"),
    5: .same(proto: "LOADING_FAILURE"),
    6: .same(proto: "ANALYSIS_FAILURE"),
    7: .same(proto: "SKIPPED"),
    8: .same(proto: "NO_ANALYZE"),
    9: .same(proto: "NO_BUILD"),
    10: .same(proto: "INCOMPLETE"),
    11: .same(proto: "OUT_OF_MEMORY"),
  ]
}

extension BuildEventStream_BuildStarted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildStarted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .standard(proto: "start_time_millis"),
    9: .standard(proto: "start_time"),
    3: .standard(proto: "build_tool_version"),
    4: .standard(proto: "options_description"),
    5: .same(proto: "command"),
    6: .standard(proto: "working_directory"),
    7: .standard(proto: "workspace_directory"),
    8: .standard(proto: "server_pid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startTimeMillis) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.buildToolVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.optionsDescription) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.command) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.workingDirectory) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.workspaceDirectory) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.serverPid) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.startTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimeMillis, fieldNumber: 2)
    }
    if !self.buildToolVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.buildToolVersion, fieldNumber: 3)
    }
    if !self.optionsDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.optionsDescription, fieldNumber: 4)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 5)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 6)
    }
    if !self.workspaceDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workspaceDirectory, fieldNumber: 7)
    }
    if self.serverPid != 0 {
      try visitor.visitSingularInt64Field(value: self.serverPid, fieldNumber: 8)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildStarted, rhs: BuildEventStream_BuildStarted) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.startTimeMillis != rhs.startTimeMillis {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.buildToolVersion != rhs.buildToolVersion {return false}
    if lhs.optionsDescription != rhs.optionsDescription {return false}
    if lhs.command != rhs.command {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.workspaceDirectory != rhs.workspaceDirectory {return false}
    if lhs.serverPid != rhs.serverPid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_exec_root"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localExecRoot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localExecRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.localExecRoot, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceConfig, rhs: BuildEventStream_WorkspaceConfig) -> Bool {
    if lhs.localExecRoot != rhs.localExecRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_UnstructuredCommandLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnstructuredCommandLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "args"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_UnstructuredCommandLine, rhs: BuildEventStream_UnstructuredCommandLine) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OptionsParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptionsParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "startup_options"),
    2: .standard(proto: "explicit_startup_options"),
    3: .standard(proto: "cmd_line"),
    4: .standard(proto: "explicit_cmd_line"),
    5: .standard(proto: "invocation_policy"),
    6: .standard(proto: "tool_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.startupOptions) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.explicitStartupOptions) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.cmdLine) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.explicitCmdLine) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._invocationPolicy) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.toolTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.startupOptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.startupOptions, fieldNumber: 1)
    }
    if !self.explicitStartupOptions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.explicitStartupOptions, fieldNumber: 2)
    }
    if !self.cmdLine.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cmdLine, fieldNumber: 3)
    }
    if !self.explicitCmdLine.isEmpty {
      try visitor.visitRepeatedStringField(value: self.explicitCmdLine, fieldNumber: 4)
    }
    try { if let v = self._invocationPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.toolTag.isEmpty {
      try visitor.visitSingularStringField(value: self.toolTag, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OptionsParsed, rhs: BuildEventStream_OptionsParsed) -> Bool {
    if lhs.startupOptions != rhs.startupOptions {return false}
    if lhs.explicitStartupOptions != rhs.explicitStartupOptions {return false}
    if lhs.cmdLine != rhs.cmdLine {return false}
    if lhs.explicitCmdLine != rhs.explicitCmdLine {return false}
    if lhs._invocationPolicy != rhs._invocationPolicy {return false}
    if lhs.toolTag != rhs.toolTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Fetch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fetch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Fetch, rhs: BuildEventStream_Fetch) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus, rhs: BuildEventStream_WorkspaceStatus) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_WorkspaceStatus.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_WorkspaceStatus.protoMessageName + ".Item"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_WorkspaceStatus.Item, rhs: BuildEventStream_WorkspaceStatus.Item) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetadata, rhs: BuildEventStream_BuildMetadata) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "platform_name"),
    3: .same(proto: "cpu"),
    4: .standard(proto: "make_variable"),
    5: .standard(proto: "is_tool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.platformName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cpu) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.makeVariable) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isTool) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 2)
    }
    if !self.cpu.isEmpty {
      try visitor.visitSingularStringField(value: self.cpu, fieldNumber: 3)
    }
    if !self.makeVariable.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.makeVariable, fieldNumber: 4)
    }
    if self.isTool != false {
      try visitor.visitSingularBoolField(value: self.isTool, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_Configuration, rhs: BuildEventStream_Configuration) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.cpu != rhs.cpu {return false}
    if lhs.makeVariable != rhs.makeVariable {return false}
    if lhs.isTool != rhs.isTool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatternExpanded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_suite_expansions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.testSuiteExpansions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.testSuiteExpansions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.testSuiteExpansions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded, rhs: BuildEventStream_PatternExpanded) -> Bool {
    if lhs.testSuiteExpansions != rhs.testSuiteExpansions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_PatternExpanded.TestSuiteExpansion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_PatternExpanded.protoMessageName + ".TestSuiteExpansion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suite_label"),
    2: .standard(proto: "test_labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suiteLabel) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.testLabels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suiteLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.suiteLabel, fieldNumber: 1)
    }
    if !self.testLabels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.testLabels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_PatternExpanded.TestSuiteExpansion, rhs: BuildEventStream_PatternExpanded.TestSuiteExpansion) -> Bool {
    if lhs.suiteLabel != rhs.suiteLabel {return false}
    if lhs.testLabels != rhs.testLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetConfigured: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetConfigured"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_kind"),
    2: .standard(proto: "test_size"),
    3: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetKind) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.testSize) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 1)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetConfigured, rhs: BuildEventStream_TargetConfigured) -> Bool {
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "path_prefix"),
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
    3: .same(proto: "contents"),
    5: .same(proto: "digest"),
    6: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.file != nil {try decoder.handleConflictingOneOf()}
          self.file = .uri(v)
        }
      }()
      case 3: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.file != nil {try decoder.handleConflictingOneOf()}
          self.file = .contents(v)
        }
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.pathPrefix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.digest) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.file {
    case .uri?: try {
      guard case .uri(let v)? = self.file else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .contents?: try {
      guard case .contents(let v)? = self.file else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.pathPrefix.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pathPrefix, fieldNumber: 4)
    }
    if !self.digest.isEmpty {
      try visitor.visitSingularStringField(value: self.digest, fieldNumber: 5)
    }
    if self.length != 0 {
      try visitor.visitSingularInt64Field(value: self.length, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_File, rhs: BuildEventStream_File) -> Bool {
    if lhs.pathPrefix != rhs.pathPrefix {return false}
    if lhs.name != rhs.name {return false}
    if lhs.file != rhs.file {return false}
    if lhs.digest != rhs.digest {return false}
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_NamedSetOfFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamedSetOfFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .standard(proto: "file_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fileSets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_NamedSetOfFiles, rhs: BuildEventStream_NamedSetOfFiles) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ActionExecuted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionExecuted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    8: .same(proto: "type"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "stdout"),
    4: .same(proto: "stderr"),
    5: .same(proto: "label"),
    7: .same(proto: "configuration"),
    6: .standard(proto: "primary_output"),
    9: .standard(proto: "command_line"),
    10: .standard(proto: "action_metadata_logs"),
    11: .standard(proto: "failure_detail"),
  ]

  fileprivate class _StorageClass {
    var _success: Bool = false
    var _type: String = String()
    var _exitCode: Int32 = 0
    var _stdout: BuildEventStream_File? = nil
    var _stderr: BuildEventStream_File? = nil
    var _label: String = String()
    var _configuration: BuildEventStream_BuildEventId.ConfigurationId? = nil
    var _primaryOutput: BuildEventStream_File? = nil
    var _commandLine: [String] = []
    var _actionMetadataLogs: [BuildEventStream_File] = []
    var _failureDetail: FailureDetails_FailureDetail? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _success = source._success
      _type = source._type
      _exitCode = source._exitCode
      _stdout = source._stdout
      _stderr = source._stderr
      _label = source._label
      _configuration = source._configuration
      _primaryOutput = source._primaryOutput
      _commandLine = source._commandLine
      _actionMetadataLogs = source._actionMetadataLogs
      _failureDetail = source._failureDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._success) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._exitCode) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stdout) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stderr) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._label) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._primaryOutput) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._configuration) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._type) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._commandLine) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._actionMetadataLogs) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._failureDetail) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._success != false {
        try visitor.visitSingularBoolField(value: _storage._success, fieldNumber: 1)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 2)
      }
      try { if let v = _storage._stdout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._stderr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._label.isEmpty {
        try visitor.visitSingularStringField(value: _storage._label, fieldNumber: 5)
      }
      try { if let v = _storage._primaryOutput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._type.isEmpty {
        try visitor.visitSingularStringField(value: _storage._type, fieldNumber: 8)
      }
      if !_storage._commandLine.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandLine, fieldNumber: 9)
      }
      if !_storage._actionMetadataLogs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionMetadataLogs, fieldNumber: 10)
      }
      try { if let v = _storage._failureDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ActionExecuted, rhs: BuildEventStream_ActionExecuted) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._success != rhs_storage._success {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._stdout != rhs_storage._stdout {return false}
        if _storage._stderr != rhs_storage._stderr {return false}
        if _storage._label != rhs_storage._label {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._primaryOutput != rhs_storage._primaryOutput {return false}
        if _storage._commandLine != rhs_storage._commandLine {return false}
        if _storage._actionMetadataLogs != rhs_storage._actionMetadataLogs {return false}
        if _storage._failureDetail != rhs_storage._failureDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_OutputGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "file_sets"),
    4: .same(proto: "incomplete"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fileSets) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.incomplete) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 3)
    }
    if self.incomplete != false {
      try visitor.visitSingularBoolField(value: self.incomplete, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_OutputGroup, rhs: BuildEventStream_OutputGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.incomplete != rhs.incomplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetComplete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetComplete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    5: .standard(proto: "target_kind"),
    6: .standard(proto: "test_size"),
    2: .standard(proto: "output_group"),
    4: .standard(proto: "important_output"),
    8: .standard(proto: "directory_output"),
    3: .same(proto: "tag"),
    7: .standard(proto: "test_timeout_seconds"),
    10: .standard(proto: "test_timeout"),
    9: .standard(proto: "failure_detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputGroup) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tag) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.importantOutput) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.targetKind) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.testSize) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.testTimeoutSeconds) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.directoryOutput) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._failureDetail) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._testTimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.outputGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputGroup, fieldNumber: 2)
    }
    if !self.tag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tag, fieldNumber: 3)
    }
    if !self.importantOutput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.importantOutput, fieldNumber: 4)
    }
    if !self.targetKind.isEmpty {
      try visitor.visitSingularStringField(value: self.targetKind, fieldNumber: 5)
    }
    if self.testSize != .unknown {
      try visitor.visitSingularEnumField(value: self.testSize, fieldNumber: 6)
    }
    if self.testTimeoutSeconds != 0 {
      try visitor.visitSingularInt64Field(value: self.testTimeoutSeconds, fieldNumber: 7)
    }
    if !self.directoryOutput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directoryOutput, fieldNumber: 8)
    }
    try { if let v = self._failureDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._testTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetComplete, rhs: BuildEventStream_TargetComplete) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.targetKind != rhs.targetKind {return false}
    if lhs.testSize != rhs.testSize {return false}
    if lhs.outputGroup != rhs.outputGroup {return false}
    if lhs.importantOutput != rhs.importantOutput {return false}
    if lhs.directoryOutput != rhs.directoryOutput {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.testTimeoutSeconds != rhs.testTimeoutSeconds {return false}
    if lhs._testTimeout != rhs._testTimeout {return false}
    if lhs._failureDetail != rhs._failureDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "status"),
    9: .standard(proto: "status_details"),
    4: .standard(proto: "cached_locally"),
    6: .standard(proto: "test_attempt_start_millis_epoch"),
    10: .standard(proto: "test_attempt_start"),
    3: .standard(proto: "test_attempt_duration_millis"),
    11: .standard(proto: "test_attempt_duration"),
    2: .standard(proto: "test_action_output"),
    7: .same(proto: "warning"),
    8: .standard(proto: "execution_info"),
  ]

  fileprivate class _StorageClass {
    var _status: BuildEventStream_TestStatus = .noStatus
    var _statusDetails: String = String()
    var _cachedLocally: Bool = false
    var _testAttemptStartMillisEpoch: Int64 = 0
    var _testAttemptStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _testAttemptDurationMillis: Int64 = 0
    var _testAttemptDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _testActionOutput: [BuildEventStream_File] = []
    var _warning: [String] = []
    var _executionInfo: BuildEventStream_TestResult.ExecutionInfo? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _statusDetails = source._statusDetails
      _cachedLocally = source._cachedLocally
      _testAttemptStartMillisEpoch = source._testAttemptStartMillisEpoch
      _testAttemptStart = source._testAttemptStart
      _testAttemptDurationMillis = source._testAttemptDurationMillis
      _testAttemptDuration = source._testAttemptDuration
      _testActionOutput = source._testActionOutput
      _warning = source._warning
      _executionInfo = source._executionInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._testActionOutput) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._testAttemptDurationMillis) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._cachedLocally) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._testAttemptStartMillisEpoch) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._warning) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._executionInfo) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._statusDetails) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._testAttemptStart) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._testAttemptDuration) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._testActionOutput.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._testActionOutput, fieldNumber: 2)
      }
      if _storage._testAttemptDurationMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptDurationMillis, fieldNumber: 3)
      }
      if _storage._cachedLocally != false {
        try visitor.visitSingularBoolField(value: _storage._cachedLocally, fieldNumber: 4)
      }
      if _storage._status != .noStatus {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._testAttemptStartMillisEpoch != 0 {
        try visitor.visitSingularInt64Field(value: _storage._testAttemptStartMillisEpoch, fieldNumber: 6)
      }
      if !_storage._warning.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._warning, fieldNumber: 7)
      }
      try { if let v = _storage._executionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._statusDetails.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusDetails, fieldNumber: 9)
      }
      try { if let v = _storage._testAttemptStart {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._testAttemptDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult, rhs: BuildEventStream_TestResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusDetails != rhs_storage._statusDetails {return false}
        if _storage._cachedLocally != rhs_storage._cachedLocally {return false}
        if _storage._testAttemptStartMillisEpoch != rhs_storage._testAttemptStartMillisEpoch {return false}
        if _storage._testAttemptStart != rhs_storage._testAttemptStart {return false}
        if _storage._testAttemptDurationMillis != rhs_storage._testAttemptDurationMillis {return false}
        if _storage._testAttemptDuration != rhs_storage._testAttemptDuration {return false}
        if _storage._testActionOutput != rhs_storage._testActionOutput {return false}
        if _storage._warning != rhs_storage._warning {return false}
        if _storage._executionInfo != rhs_storage._executionInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.protoMessageName + ".ExecutionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timeout_seconds"),
    2: .same(proto: "strategy"),
    6: .standard(proto: "cached_remotely"),
    7: .standard(proto: "exit_code"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "timing_breakdown"),
    5: .standard(proto: "resource_usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSeconds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.strategy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timingBreakdown) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.resourceUsage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.cachedRemotely) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeoutSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSeconds, fieldNumber: 1)
    }
    if !self.strategy.isEmpty {
      try visitor.visitSingularStringField(value: self.strategy, fieldNumber: 2)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    try { if let v = self._timingBreakdown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.resourceUsage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceUsage, fieldNumber: 5)
    }
    if self.cachedRemotely != false {
      try visitor.visitSingularBoolField(value: self.cachedRemotely, fieldNumber: 6)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo, rhs: BuildEventStream_TestResult.ExecutionInfo) -> Bool {
    if lhs.timeoutSeconds != rhs.timeoutSeconds {return false}
    if lhs.strategy != rhs.strategy {return false}
    if lhs.cachedRemotely != rhs.cachedRemotely {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs._timingBreakdown != rhs._timingBreakdown {return false}
    if lhs.resourceUsage != rhs.resourceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".TimingBreakdown"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "child"),
    2: .same(proto: "name"),
    3: .standard(proto: "time_millis"),
    4: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.child) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timeMillis) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.child.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.child, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.timeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.timeMillis, fieldNumber: 3)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown, rhs: BuildEventStream_TestResult.ExecutionInfo.TimingBreakdown) -> Bool {
    if lhs.child != rhs.child {return false}
    if lhs.name != rhs.name {return false}
    if lhs.timeMillis != rhs.timeMillis {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestResult.ExecutionInfo.ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_TestResult.ExecutionInfo.protoMessageName + ".ResourceUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage, rhs: BuildEventStream_TestResult.ExecutionInfo.ResourceUsage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TestSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "overall_status"),
    1: .standard(proto: "total_run_count"),
    10: .standard(proto: "run_count"),
    15: .standard(proto: "attempt_count"),
    11: .standard(proto: "shard_count"),
    3: .same(proto: "passed"),
    4: .same(proto: "failed"),
    6: .standard(proto: "total_num_cached"),
    7: .standard(proto: "first_start_time_millis"),
    13: .standard(proto: "first_start_time"),
    8: .standard(proto: "last_stop_time_millis"),
    14: .standard(proto: "last_stop_time"),
    9: .standard(proto: "total_run_duration_millis"),
    12: .standard(proto: "total_run_duration"),
  ]

  fileprivate class _StorageClass {
    var _overallStatus: BuildEventStream_TestStatus = .noStatus
    var _totalRunCount: Int32 = 0
    var _runCount: Int32 = 0
    var _attemptCount: Int32 = 0
    var _shardCount: Int32 = 0
    var _passed: [BuildEventStream_File] = []
    var _failed: [BuildEventStream_File] = []
    var _totalNumCached: Int32 = 0
    var _firstStartTimeMillis: Int64 = 0
    var _firstStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastStopTimeMillis: Int64 = 0
    var _lastStopTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _totalRunDurationMillis: Int64 = 0
    var _totalRunDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _overallStatus = source._overallStatus
      _totalRunCount = source._totalRunCount
      _runCount = source._runCount
      _attemptCount = source._attemptCount
      _shardCount = source._shardCount
      _passed = source._passed
      _failed = source._failed
      _totalNumCached = source._totalNumCached
      _firstStartTimeMillis = source._firstStartTimeMillis
      _firstStartTime = source._firstStartTime
      _lastStopTimeMillis = source._lastStopTimeMillis
      _lastStopTime = source._lastStopTime
      _totalRunDurationMillis = source._totalRunDurationMillis
      _totalRunDuration = source._totalRunDuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._totalRunCount) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._passed) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._failed) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._overallStatus) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._totalNumCached) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._firstStartTimeMillis) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._lastStopTimeMillis) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._totalRunDurationMillis) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._runCount) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._shardCount) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._totalRunDuration) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._firstStartTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lastStopTime) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._attemptCount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._totalRunCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalRunCount, fieldNumber: 1)
      }
      if !_storage._passed.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._passed, fieldNumber: 3)
      }
      if !_storage._failed.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._failed, fieldNumber: 4)
      }
      if _storage._overallStatus != .noStatus {
        try visitor.visitSingularEnumField(value: _storage._overallStatus, fieldNumber: 5)
      }
      if _storage._totalNumCached != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalNumCached, fieldNumber: 6)
      }
      if _storage._firstStartTimeMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._firstStartTimeMillis, fieldNumber: 7)
      }
      if _storage._lastStopTimeMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastStopTimeMillis, fieldNumber: 8)
      }
      if _storage._totalRunDurationMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._totalRunDurationMillis, fieldNumber: 9)
      }
      if _storage._runCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._runCount, fieldNumber: 10)
      }
      if _storage._shardCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shardCount, fieldNumber: 11)
      }
      try { if let v = _storage._totalRunDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._firstStartTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._lastStopTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._attemptCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attemptCount, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TestSummary, rhs: BuildEventStream_TestSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._overallStatus != rhs_storage._overallStatus {return false}
        if _storage._totalRunCount != rhs_storage._totalRunCount {return false}
        if _storage._runCount != rhs_storage._runCount {return false}
        if _storage._attemptCount != rhs_storage._attemptCount {return false}
        if _storage._shardCount != rhs_storage._shardCount {return false}
        if _storage._passed != rhs_storage._passed {return false}
        if _storage._failed != rhs_storage._failed {return false}
        if _storage._totalNumCached != rhs_storage._totalNumCached {return false}
        if _storage._firstStartTimeMillis != rhs_storage._firstStartTimeMillis {return false}
        if _storage._firstStartTime != rhs_storage._firstStartTime {return false}
        if _storage._lastStopTimeMillis != rhs_storage._lastStopTimeMillis {return false}
        if _storage._lastStopTime != rhs_storage._lastStopTime {return false}
        if _storage._totalRunDurationMillis != rhs_storage._totalRunDurationMillis {return false}
        if _storage._totalRunDuration != rhs_storage._totalRunDuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_TargetSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_build_success"),
    2: .standard(proto: "overall_test_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.overallBuildSuccess) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.overallTestStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overallBuildSuccess != false {
      try visitor.visitSingularBoolField(value: self.overallBuildSuccess, fieldNumber: 1)
    }
    if self.overallTestStatus != .noStatus {
      try visitor.visitSingularEnumField(value: self.overallTestStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_TargetSummary, rhs: BuildEventStream_TargetSummary) -> Bool {
    if lhs.overallBuildSuccess != rhs.overallBuildSuccess {return false}
    if lhs.overallTestStatus != rhs.overallTestStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildFinished"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_success"),
    3: .standard(proto: "exit_code"),
    2: .standard(proto: "finish_time_millis"),
    5: .standard(proto: "finish_time"),
    4: .standard(proto: "anomaly_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.overallSuccess) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.finishTimeMillis) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._exitCode) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._anomalyReport) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._finishTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.overallSuccess != false {
      try visitor.visitSingularBoolField(value: self.overallSuccess, fieldNumber: 1)
    }
    if self.finishTimeMillis != 0 {
      try visitor.visitSingularInt64Field(value: self.finishTimeMillis, fieldNumber: 2)
    }
    try { if let v = self._exitCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._anomalyReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._finishTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished, rhs: BuildEventStream_BuildFinished) -> Bool {
    if lhs.overallSuccess != rhs.overallSuccess {return false}
    if lhs._exitCode != rhs._exitCode {return false}
    if lhs.finishTimeMillis != rhs.finishTimeMillis {return false}
    if lhs._finishTime != rhs._finishTime {return false}
    if lhs._anomalyReport != rhs._anomalyReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.ExitCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".ExitCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.ExitCode, rhs: BuildEventStream_BuildFinished.ExitCode) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildFinished.AnomalyReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildFinished.protoMessageName + ".AnomalyReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "was_suspended"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.wasSuspended) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.wasSuspended != false {
      try visitor.visitSingularBoolField(value: self.wasSuspended, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildFinished.AnomalyReport, rhs: BuildEventStream_BuildFinished.AnomalyReport) -> Bool {
    if lhs.wasSuspended != rhs.wasSuspended {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_summary"),
    2: .standard(proto: "memory_metrics"),
    3: .standard(proto: "target_metrics"),
    4: .standard(proto: "package_metrics"),
    5: .standard(proto: "timing_metrics"),
    6: .standard(proto: "cumulative_metrics"),
    7: .standard(proto: "artifact_metrics"),
    8: .standard(proto: "build_graph_metrics"),
    9: .standard(proto: "worker_metrics"),
  ]

  fileprivate class _StorageClass {
    var _actionSummary: BuildEventStream_BuildMetrics.ActionSummary? = nil
    var _memoryMetrics: BuildEventStream_BuildMetrics.MemoryMetrics? = nil
    var _targetMetrics: BuildEventStream_BuildMetrics.TargetMetrics? = nil
    var _packageMetrics: BuildEventStream_BuildMetrics.PackageMetrics? = nil
    var _timingMetrics: BuildEventStream_BuildMetrics.TimingMetrics? = nil
    var _cumulativeMetrics: BuildEventStream_BuildMetrics.CumulativeMetrics? = nil
    var _artifactMetrics: BuildEventStream_BuildMetrics.ArtifactMetrics? = nil
    var _buildGraphMetrics: BuildEventStream_BuildMetrics.BuildGraphMetrics? = nil
    var _workerMetrics: [BuildEventStream_BuildMetrics.WorkerMetrics] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _actionSummary = source._actionSummary
      _memoryMetrics = source._memoryMetrics
      _targetMetrics = source._targetMetrics
      _packageMetrics = source._packageMetrics
      _timingMetrics = source._timingMetrics
      _cumulativeMetrics = source._cumulativeMetrics
      _artifactMetrics = source._artifactMetrics
      _buildGraphMetrics = source._buildGraphMetrics
      _workerMetrics = source._workerMetrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._actionSummary) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._memoryMetrics) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._targetMetrics) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._packageMetrics) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._timingMetrics) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._cumulativeMetrics) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._artifactMetrics) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._buildGraphMetrics) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._workerMetrics) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._actionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._memoryMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._targetMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._packageMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timingMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._cumulativeMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._artifactMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._buildGraphMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._workerMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._workerMetrics, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics, rhs: BuildEventStream_BuildMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actionSummary != rhs_storage._actionSummary {return false}
        if _storage._memoryMetrics != rhs_storage._memoryMetrics {return false}
        if _storage._targetMetrics != rhs_storage._targetMetrics {return false}
        if _storage._packageMetrics != rhs_storage._packageMetrics {return false}
        if _storage._timingMetrics != rhs_storage._timingMetrics {return false}
        if _storage._cumulativeMetrics != rhs_storage._cumulativeMetrics {return false}
        if _storage._artifactMetrics != rhs_storage._artifactMetrics {return false}
        if _storage._buildGraphMetrics != rhs_storage._buildGraphMetrics {return false}
        if _storage._workerMetrics != rhs_storage._workerMetrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ActionSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "actions_created"),
    3: .standard(proto: "actions_created_not_including_aspects"),
    2: .standard(proto: "actions_executed"),
    4: .standard(proto: "action_data"),
    5: .standard(proto: "remote_cache_hits"),
    6: .standard(proto: "runner_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.actionsCreated) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.actionsExecuted) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.actionsCreatedNotIncludingAspects) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.actionData) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.remoteCacheHits) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.runnerCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsCreated != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreated, fieldNumber: 1)
    }
    if self.actionsExecuted != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsExecuted, fieldNumber: 2)
    }
    if self.actionsCreatedNotIncludingAspects != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsCreatedNotIncludingAspects, fieldNumber: 3)
    }
    if !self.actionData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actionData, fieldNumber: 4)
    }
    if self.remoteCacheHits != 0 {
      try visitor.visitSingularInt64Field(value: self.remoteCacheHits, fieldNumber: 5)
    }
    if !self.runnerCount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runnerCount, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary, rhs: BuildEventStream_BuildMetrics.ActionSummary) -> Bool {
    if lhs.actionsCreated != rhs.actionsCreated {return false}
    if lhs.actionsCreatedNotIncludingAspects != rhs.actionsCreatedNotIncludingAspects {return false}
    if lhs.actionsExecuted != rhs.actionsExecuted {return false}
    if lhs.actionData != rhs.actionData {return false}
    if lhs.remoteCacheHits != rhs.remoteCacheHits {return false}
    if lhs.runnerCount != rhs.runnerCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary.ActionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.ActionSummary.protoMessageName + ".ActionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mnemonic"),
    2: .standard(proto: "actions_executed"),
    3: .standard(proto: "first_started_ms"),
    4: .standard(proto: "last_ended_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.actionsExecuted) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.firstStartedMs) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastEndedMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 1)
    }
    if self.actionsExecuted != 0 {
      try visitor.visitSingularInt64Field(value: self.actionsExecuted, fieldNumber: 2)
    }
    if self.firstStartedMs != 0 {
      try visitor.visitSingularInt64Field(value: self.firstStartedMs, fieldNumber: 3)
    }
    if self.lastEndedMs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastEndedMs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary.ActionData, rhs: BuildEventStream_BuildMetrics.ActionSummary.ActionData) -> Bool {
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.actionsExecuted != rhs.actionsExecuted {return false}
    if lhs.firstStartedMs != rhs.firstStartedMs {return false}
    if lhs.lastEndedMs != rhs.lastEndedMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ActionSummary.RunnerCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.ActionSummary.protoMessageName + ".RunnerCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ActionSummary.RunnerCount, rhs: BuildEventStream_BuildMetrics.ActionSummary.RunnerCount) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.MemoryMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".MemoryMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "used_heap_size_post_build"),
    2: .standard(proto: "peak_post_gc_heap_size"),
    4: .standard(proto: "peak_post_gc_tenured_space_heap_size"),
    3: .standard(proto: "garbage_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.usedHeapSizePostBuild) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.peakPostGcHeapSize) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.garbageMetrics) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.peakPostGcTenuredSpaceHeapSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.usedHeapSizePostBuild != 0 {
      try visitor.visitSingularInt64Field(value: self.usedHeapSizePostBuild, fieldNumber: 1)
    }
    if self.peakPostGcHeapSize != 0 {
      try visitor.visitSingularInt64Field(value: self.peakPostGcHeapSize, fieldNumber: 2)
    }
    if !self.garbageMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.garbageMetrics, fieldNumber: 3)
    }
    if self.peakPostGcTenuredSpaceHeapSize != 0 {
      try visitor.visitSingularInt64Field(value: self.peakPostGcTenuredSpaceHeapSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.MemoryMetrics, rhs: BuildEventStream_BuildMetrics.MemoryMetrics) -> Bool {
    if lhs.usedHeapSizePostBuild != rhs.usedHeapSizePostBuild {return false}
    if lhs.peakPostGcHeapSize != rhs.peakPostGcHeapSize {return false}
    if lhs.peakPostGcTenuredSpaceHeapSize != rhs.peakPostGcTenuredSpaceHeapSize {return false}
    if lhs.garbageMetrics != rhs.garbageMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.MemoryMetrics.GarbageMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.MemoryMetrics.protoMessageName + ".GarbageMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "garbage_collected"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.garbageCollected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.garbageCollected != 0 {
      try visitor.visitSingularInt64Field(value: self.garbageCollected, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.MemoryMetrics.GarbageMetrics, rhs: BuildEventStream_BuildMetrics.MemoryMetrics.GarbageMetrics) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.garbageCollected != rhs.garbageCollected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TargetMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TargetMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "targets_loaded"),
    2: .standard(proto: "targets_configured"),
    3: .standard(proto: "targets_configured_not_including_aspects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.targetsLoaded) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.targetsConfigured) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.targetsConfiguredNotIncludingAspects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetsLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsLoaded, fieldNumber: 1)
    }
    if self.targetsConfigured != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsConfigured, fieldNumber: 2)
    }
    if self.targetsConfiguredNotIncludingAspects != 0 {
      try visitor.visitSingularInt64Field(value: self.targetsConfiguredNotIncludingAspects, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TargetMetrics, rhs: BuildEventStream_BuildMetrics.TargetMetrics) -> Bool {
    if lhs.targetsLoaded != rhs.targetsLoaded {return false}
    if lhs.targetsConfigured != rhs.targetsConfigured {return false}
    if lhs.targetsConfiguredNotIncludingAspects != rhs.targetsConfiguredNotIncludingAspects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.PackageMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".PackageMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packages_loaded"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.packagesLoaded) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packagesLoaded != 0 {
      try visitor.visitSingularInt64Field(value: self.packagesLoaded, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.PackageMetrics, rhs: BuildEventStream_BuildMetrics.PackageMetrics) -> Bool {
    if lhs.packagesLoaded != rhs.packagesLoaded {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.TimingMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".TimingMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_time_in_ms"),
    2: .standard(proto: "wall_time_in_ms"),
    3: .standard(proto: "analysis_phase_time_in_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.cpuTimeInMs) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.wallTimeInMs) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.analysisPhaseTimeInMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.cpuTimeInMs, fieldNumber: 1)
    }
    if self.wallTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.wallTimeInMs, fieldNumber: 2)
    }
    if self.analysisPhaseTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.analysisPhaseTimeInMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.TimingMetrics, rhs: BuildEventStream_BuildMetrics.TimingMetrics) -> Bool {
    if lhs.cpuTimeInMs != rhs.cpuTimeInMs {return false}
    if lhs.wallTimeInMs != rhs.wallTimeInMs {return false}
    if lhs.analysisPhaseTimeInMs != rhs.analysisPhaseTimeInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.CumulativeMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".CumulativeMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "num_analyses"),
    12: .standard(proto: "num_builds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.numAnalyses) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.numBuilds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numAnalyses != 0 {
      try visitor.visitSingularInt32Field(value: self.numAnalyses, fieldNumber: 11)
    }
    if self.numBuilds != 0 {
      try visitor.visitSingularInt32Field(value: self.numBuilds, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.CumulativeMetrics, rhs: BuildEventStream_BuildMetrics.CumulativeMetrics) -> Bool {
    if lhs.numAnalyses != rhs.numAnalyses {return false}
    if lhs.numBuilds != rhs.numBuilds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ArtifactMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".ArtifactMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "source_artifacts_read"),
    3: .standard(proto: "output_artifacts_seen"),
    4: .standard(proto: "output_artifacts_from_action_cache"),
    5: .standard(proto: "top_level_artifacts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sourceArtifactsRead) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._outputArtifactsSeen) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outputArtifactsFromActionCache) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._topLevelArtifacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sourceArtifactsRead {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._outputArtifactsSeen {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outputArtifactsFromActionCache {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._topLevelArtifacts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ArtifactMetrics, rhs: BuildEventStream_BuildMetrics.ArtifactMetrics) -> Bool {
    if lhs._sourceArtifactsRead != rhs._sourceArtifactsRead {return false}
    if lhs._outputArtifactsSeen != rhs._outputArtifactsSeen {return false}
    if lhs._outputArtifactsFromActionCache != rhs._outputArtifactsFromActionCache {return false}
    if lhs._topLevelArtifacts != rhs._topLevelArtifacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.ArtifactMetrics.protoMessageName + ".FilesMetric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "size_in_bytes"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.sizeInBytes) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sizeInBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeInBytes, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric, rhs: BuildEventStream_BuildMetrics.ArtifactMetrics.FilesMetric) -> Bool {
    if lhs.sizeInBytes != rhs.sizeInBytes {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.BuildGraphMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".BuildGraphMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_lookup_value_count"),
    5: .standard(proto: "action_lookup_value_count_not_including_aspects"),
    2: .standard(proto: "action_count"),
    6: .standard(proto: "action_count_not_including_aspects"),
    7: .standard(proto: "input_file_configured_target_count"),
    8: .standard(proto: "output_file_configured_target_count"),
    9: .standard(proto: "other_configured_target_count"),
    3: .standard(proto: "output_artifact_count"),
    4: .standard(proto: "post_invocation_skyframe_node_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.actionLookupValueCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.actionCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.outputArtifactCount) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.postInvocationSkyframeNodeCount) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.actionLookupValueCountNotIncludingAspects) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.actionCountNotIncludingAspects) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.inputFileConfiguredTargetCount) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.outputFileConfiguredTargetCount) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.otherConfiguredTargetCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionLookupValueCount != 0 {
      try visitor.visitSingularInt32Field(value: self.actionLookupValueCount, fieldNumber: 1)
    }
    if self.actionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.actionCount, fieldNumber: 2)
    }
    if self.outputArtifactCount != 0 {
      try visitor.visitSingularInt32Field(value: self.outputArtifactCount, fieldNumber: 3)
    }
    if self.postInvocationSkyframeNodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.postInvocationSkyframeNodeCount, fieldNumber: 4)
    }
    if self.actionLookupValueCountNotIncludingAspects != 0 {
      try visitor.visitSingularInt32Field(value: self.actionLookupValueCountNotIncludingAspects, fieldNumber: 5)
    }
    if self.actionCountNotIncludingAspects != 0 {
      try visitor.visitSingularInt32Field(value: self.actionCountNotIncludingAspects, fieldNumber: 6)
    }
    if self.inputFileConfiguredTargetCount != 0 {
      try visitor.visitSingularInt32Field(value: self.inputFileConfiguredTargetCount, fieldNumber: 7)
    }
    if self.outputFileConfiguredTargetCount != 0 {
      try visitor.visitSingularInt32Field(value: self.outputFileConfiguredTargetCount, fieldNumber: 8)
    }
    if self.otherConfiguredTargetCount != 0 {
      try visitor.visitSingularInt32Field(value: self.otherConfiguredTargetCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.BuildGraphMetrics, rhs: BuildEventStream_BuildMetrics.BuildGraphMetrics) -> Bool {
    if lhs.actionLookupValueCount != rhs.actionLookupValueCount {return false}
    if lhs.actionLookupValueCountNotIncludingAspects != rhs.actionLookupValueCountNotIncludingAspects {return false}
    if lhs.actionCount != rhs.actionCount {return false}
    if lhs.actionCountNotIncludingAspects != rhs.actionCountNotIncludingAspects {return false}
    if lhs.inputFileConfiguredTargetCount != rhs.inputFileConfiguredTargetCount {return false}
    if lhs.outputFileConfiguredTargetCount != rhs.outputFileConfiguredTargetCount {return false}
    if lhs.otherConfiguredTargetCount != rhs.otherConfiguredTargetCount {return false}
    if lhs.outputArtifactCount != rhs.outputArtifactCount {return false}
    if lhs.postInvocationSkyframeNodeCount != rhs.postInvocationSkyframeNodeCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.WorkerMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.protoMessageName + ".WorkerMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_id"),
    2: .standard(proto: "process_id"),
    3: .same(proto: "mnemonic"),
    4: .standard(proto: "is_multiplex"),
    5: .standard(proto: "is_sandbox"),
    6: .standard(proto: "is_measurable"),
    7: .standard(proto: "worker_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.workerID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.processID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isMultiplex) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isSandbox) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isMeasurable) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.workerStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.workerID != 0 {
      try visitor.visitSingularInt32Field(value: self.workerID, fieldNumber: 1)
    }
    if self.processID != 0 {
      try visitor.visitSingularUInt32Field(value: self.processID, fieldNumber: 2)
    }
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 3)
    }
    if self.isMultiplex != false {
      try visitor.visitSingularBoolField(value: self.isMultiplex, fieldNumber: 4)
    }
    if self.isSandbox != false {
      try visitor.visitSingularBoolField(value: self.isSandbox, fieldNumber: 5)
    }
    if self.isMeasurable != false {
      try visitor.visitSingularBoolField(value: self.isMeasurable, fieldNumber: 6)
    }
    if !self.workerStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerStats, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.WorkerMetrics, rhs: BuildEventStream_BuildMetrics.WorkerMetrics) -> Bool {
    if lhs.workerID != rhs.workerID {return false}
    if lhs.processID != rhs.processID {return false}
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.isMultiplex != rhs.isMultiplex {return false}
    if lhs.isSandbox != rhs.isSandbox {return false}
    if lhs.isMeasurable != rhs.isMeasurable {return false}
    if lhs.workerStats != rhs.workerStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildMetrics.WorkerMetrics.WorkerStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BuildEventStream_BuildMetrics.WorkerMetrics.protoMessageName + ".WorkerStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "collect_time_in_ms"),
    2: .standard(proto: "worker_memory_in_kb"),
    3: .standard(proto: "last_action_start_time_in_ms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.collectTimeInMs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.workerMemoryInKb) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.lastActionStartTimeInMs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.collectTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.collectTimeInMs, fieldNumber: 1)
    }
    if self.workerMemoryInKb != 0 {
      try visitor.visitSingularInt32Field(value: self.workerMemoryInKb, fieldNumber: 2)
    }
    if self.lastActionStartTimeInMs != 0 {
      try visitor.visitSingularInt64Field(value: self.lastActionStartTimeInMs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildMetrics.WorkerMetrics.WorkerStats, rhs: BuildEventStream_BuildMetrics.WorkerMetrics.WorkerStats) -> Bool {
    if lhs.collectTimeInMs != rhs.collectTimeInMs {return false}
    if lhs.workerMemoryInKb != rhs.workerMemoryInKb {return false}
    if lhs.lastActionStartTimeInMs != rhs.lastActionStartTimeInMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_BuildToolLogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildToolLogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "log"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.log) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.log.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.log, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildToolLogs, rhs: BuildEventStream_BuildToolLogs) -> Bool {
    if lhs.log != rhs.log {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlinksIdentified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlinksIdentified"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "convenience_symlinks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.convenienceSymlinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.convenienceSymlinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.convenienceSymlinks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlinksIdentified, rhs: BuildEventStream_ConvenienceSymlinksIdentified) -> Bool {
    if lhs.convenienceSymlinks != rhs.convenienceSymlinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConvenienceSymlink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "action"),
    3: .same(proto: "target"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_ConvenienceSymlink, rhs: BuildEventStream_ConvenienceSymlink) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.action != rhs.action {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BuildEventStream_ConvenienceSymlink.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "DELETE"),
  ]
}

extension BuildEventStream_BuildEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "children"),
    20: .standard(proto: "last_message"),
    3: .same(proto: "progress"),
    4: .same(proto: "aborted"),
    5: .same(proto: "started"),
    12: .standard(proto: "unstructured_command_line"),
    22: .standard(proto: "structured_command_line"),
    13: .standard(proto: "options_parsed"),
    16: .standard(proto: "workspace_status"),
    21: .same(proto: "fetch"),
    17: .same(proto: "configuration"),
    6: .same(proto: "expanded"),
    18: .same(proto: "configured"),
    7: .same(proto: "action"),
    15: .standard(proto: "named_set_of_files"),
    8: .same(proto: "completed"),
    10: .standard(proto: "test_result"),
    9: .standard(proto: "test_summary"),
    28: .standard(proto: "target_summary"),
    14: .same(proto: "finished"),
    23: .standard(proto: "build_tool_logs"),
    24: .standard(proto: "build_metrics"),
    25: .standard(proto: "workspace_info"),
    26: .standard(proto: "build_metadata"),
    27: .standard(proto: "convenience_symlinks_identified"),
  ]

  fileprivate class _StorageClass {
    var _id: BuildEventStream_BuildEventId? = nil
    var _children: [BuildEventStream_BuildEventId] = []
    var _lastMessage: Bool = false
    var _payload: BuildEventStream_BuildEvent.OneOf_Payload?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _children = source._children
      _lastMessage = source._lastMessage
      _payload = source._payload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._children) }()
        case 3: try {
          var v: BuildEventStream_Progress?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .progress(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .progress(v)
          }
        }()
        case 4: try {
          var v: BuildEventStream_Aborted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .aborted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .aborted(v)
          }
        }()
        case 5: try {
          var v: BuildEventStream_BuildStarted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .started(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .started(v)
          }
        }()
        case 6: try {
          var v: BuildEventStream_PatternExpanded?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .expanded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .expanded(v)
          }
        }()
        case 7: try {
          var v: BuildEventStream_ActionExecuted?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .action(v)
          }
        }()
        case 8: try {
          var v: BuildEventStream_TargetComplete?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .completed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .completed(v)
          }
        }()
        case 9: try {
          var v: BuildEventStream_TestSummary?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .testSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .testSummary(v)
          }
        }()
        case 10: try {
          var v: BuildEventStream_TestResult?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .testResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .testResult(v)
          }
        }()
        case 12: try {
          var v: BuildEventStream_UnstructuredCommandLine?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .unstructuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .unstructuredCommandLine(v)
          }
        }()
        case 13: try {
          var v: BuildEventStream_OptionsParsed?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .optionsParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .optionsParsed(v)
          }
        }()
        case 14: try {
          var v: BuildEventStream_BuildFinished?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .finished(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .finished(v)
          }
        }()
        case 15: try {
          var v: BuildEventStream_NamedSetOfFiles?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .namedSetOfFiles(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .namedSetOfFiles(v)
          }
        }()
        case 16: try {
          var v: BuildEventStream_WorkspaceStatus?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .workspaceStatus(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .workspaceStatus(v)
          }
        }()
        case 17: try {
          var v: BuildEventStream_Configuration?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .configuration(v)
          }
        }()
        case 18: try {
          var v: BuildEventStream_TargetConfigured?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .configured(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .configured(v)
          }
        }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._lastMessage) }()
        case 21: try {
          var v: BuildEventStream_Fetch?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .fetch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .fetch(v)
          }
        }()
        case 22: try {
          var v: CommandLine_CommandLine?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .structuredCommandLine(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .structuredCommandLine(v)
          }
        }()
        case 23: try {
          var v: BuildEventStream_BuildToolLogs?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .buildToolLogs(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .buildToolLogs(v)
          }
        }()
        case 24: try {
          var v: BuildEventStream_BuildMetrics?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .buildMetrics(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .buildMetrics(v)
          }
        }()
        case 25: try {
          var v: BuildEventStream_WorkspaceConfig?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .workspaceInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .workspaceInfo(v)
          }
        }()
        case 26: try {
          var v: BuildEventStream_BuildMetadata?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .buildMetadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .buildMetadata(v)
          }
        }()
        case 27: try {
          var v: BuildEventStream_ConvenienceSymlinksIdentified?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .convenienceSymlinksIdentified(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .convenienceSymlinksIdentified(v)
          }
        }()
        case 28: try {
          var v: BuildEventStream_TargetSummary?
          var hadOneofValue = false
          if let current = _storage._payload {
            hadOneofValue = true
            if case .targetSummary(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._payload = .targetSummary(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._children.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._children, fieldNumber: 2)
      }
      switch _storage._payload {
      case .progress?: try {
        guard case .progress(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .aborted?: try {
        guard case .aborted(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .started?: try {
        guard case .started(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .expanded?: try {
        guard case .expanded(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .action?: try {
        guard case .action(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .completed?: try {
        guard case .completed(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .testSummary?: try {
        guard case .testSummary(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .testResult?: try {
        guard case .testResult(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .unstructuredCommandLine?: try {
        guard case .unstructuredCommandLine(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .optionsParsed?: try {
        guard case .optionsParsed(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .finished?: try {
        guard case .finished(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .namedSetOfFiles?: try {
        guard case .namedSetOfFiles(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .workspaceStatus?: try {
        guard case .workspaceStatus(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .configuration?: try {
        guard case .configuration(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .configured?: try {
        guard case .configured(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      default: break
      }
      if _storage._lastMessage != false {
        try visitor.visitSingularBoolField(value: _storage._lastMessage, fieldNumber: 20)
      }
      switch _storage._payload {
      case .fetch?: try {
        guard case .fetch(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .structuredCommandLine?: try {
        guard case .structuredCommandLine(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .buildToolLogs?: try {
        guard case .buildToolLogs(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .buildMetrics?: try {
        guard case .buildMetrics(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .workspaceInfo?: try {
        guard case .workspaceInfo(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .buildMetadata?: try {
        guard case .buildMetadata(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .convenienceSymlinksIdentified?: try {
        guard case .convenienceSymlinksIdentified(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .targetSummary?: try {
        guard case .targetSummary(let v)? = _storage._payload else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BuildEventStream_BuildEvent, rhs: BuildEventStream_BuildEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._children != rhs_storage._children {return false}
        if _storage._lastMessage != rhs_storage._lastMessage {return false}
        if _storage._payload != rhs_storage._payload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
