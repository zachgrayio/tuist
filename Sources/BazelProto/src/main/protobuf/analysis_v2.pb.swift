// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/analysis_v2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Container for the action graph properties.
public struct Analysis_ActionGraphContainer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var artifacts: [Analysis_Artifact] = []

  public var actions: [Analysis_Action] = []

  public var targets: [Analysis_Target] = []

  public var depSetOfFiles: [Analysis_DepSetOfFiles] = []

  public var configuration: [Analysis_Configuration] = []

  public var aspectDescriptors: [Analysis_AspectDescriptor] = []

  public var ruleClasses: [Analysis_RuleClass] = []

  public var pathFragments: [Analysis_PathFragment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a single artifact, whether it's a source file or a derived output
/// file.
public struct Analysis_Artifact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this artifact; this is a uint32, only valid for this
  /// particular dump of the analysis.
  public var id: UInt32 = 0

  /// The id of the PathFragment that represents the relative path of the file
  /// within the execution root.
  public var pathFragmentID: UInt32 = 0

  /// True iff the artifact is a tree artifact, i.e. the above exec_path refers
  /// a directory.
  public var isTreeArtifact: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a single action, which is a function from Artifact(s) to
/// Artifact(s).
public struct Analysis_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The target that was responsible for the creation of the action.
  public var targetID: UInt32 {
    get {return _storage._targetID}
    set {_uniqueStorage()._targetID = newValue}
  }

  /// The aspects that were responsible for the creation of the action (if any).
  /// In the case of aspect-on-aspect, AspectDescriptors are listed in
  /// topological order of the dependency graph.
  /// e.g. [A, B] would imply that aspect A is applied on top of aspect B.
  public var aspectDescriptorIds: [UInt32] {
    get {return _storage._aspectDescriptorIds}
    set {_uniqueStorage()._aspectDescriptorIds = newValue}
  }

  /// Encodes all significant behavior that might affect the output. The key
  /// must change if the work performed by the execution of this action changes.
  /// Note that the key doesn't include checksums of the input files.
  public var actionKey: String {
    get {return _storage._actionKey}
    set {_uniqueStorage()._actionKey = newValue}
  }

  /// The mnemonic for this kind of action.
  public var mnemonic: String {
    get {return _storage._mnemonic}
    set {_uniqueStorage()._mnemonic = newValue}
  }

  /// The configuration under which this action is executed.
  public var configurationID: UInt32 {
    get {return _storage._configurationID}
    set {_uniqueStorage()._configurationID = newValue}
  }

  /// The command line arguments of the action. This will be only set if
  /// explicitly requested.
  public var arguments: [String] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// The list of environment variables to be set before executing the command.
  public var environmentVariables: [Analysis_KeyValuePair] {
    get {return _storage._environmentVariables}
    set {_uniqueStorage()._environmentVariables = newValue}
  }

  /// The set of input dep sets that the action depends upon. If the action does
  /// input discovery, the contents of this set might change during execution.
  public var inputDepSetIds: [UInt32] {
    get {return _storage._inputDepSetIds}
    set {_uniqueStorage()._inputDepSetIds = newValue}
  }

  /// The list of Artifact IDs that represent the output files that this action
  /// will generate.
  public var outputIds: [UInt32] {
    get {return _storage._outputIds}
    set {_uniqueStorage()._outputIds = newValue}
  }

  /// True iff the action does input discovery during execution.
  public var discoversInputs: Bool {
    get {return _storage._discoversInputs}
    set {_uniqueStorage()._discoversInputs = newValue}
  }

  /// Execution info for the action.  Remote execution services may use this
  /// information to modify the execution environment, but actions will
  /// generally not be aware of it.
  public var executionInfo: [Analysis_KeyValuePair] {
    get {return _storage._executionInfo}
    set {_uniqueStorage()._executionInfo = newValue}
  }

  /// The list of param files. This will be only set if explicitly requested.
  public var paramFiles: [Analysis_ParamFile] {
    get {return _storage._paramFiles}
    set {_uniqueStorage()._paramFiles = newValue}
  }

  /// The id to an Artifact that is the primary output of this action.
  public var primaryOutputID: UInt32 {
    get {return _storage._primaryOutputID}
    set {_uniqueStorage()._primaryOutputID = newValue}
  }

  /// The execution platform for this action. Empty if the action has no
  /// execution platform.
  public var executionPlatform: String {
    get {return _storage._executionPlatform}
    set {_uniqueStorage()._executionPlatform = newValue}
  }

  /// The template content of the action, if it is TemplateExpand action.
  public var templateContent: String {
    get {return _storage._templateContent}
    set {_uniqueStorage()._templateContent = newValue}
  }

  /// The list of substitution should be performed on the template. The key is
  /// the string to be substituted and the value is the string to be substituted
  /// to.
  public var substitutions: [Analysis_KeyValuePair] {
    get {return _storage._substitutions}
    set {_uniqueStorage()._substitutions = newValue}
  }

  /// The contents of the file for the actions.write() action
  /// (guarded by the --include_file_write_contents flag).
  public var fileContents: String {
    get {return _storage._fileContents}
    set {_uniqueStorage()._fileContents = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents a single target (without configuration information) that is
/// associated with an action.
public struct Analysis_Target {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this target; this is a uint32, only valid for this
  /// particular dump of the analysis.
  public var id: UInt32 = 0

  /// Label of the target, e.g. //foo:bar.
  public var label: String = String()

  /// Class of the rule.
  public var ruleClassID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Analysis_RuleClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this rule class; this is a uint32, only valid for
  /// this particular dump of the analysis.
  public var id: UInt32 = 0

  /// Name of the rule class, e.g. cc_library.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents an invocation specific descriptor of an aspect.
public struct Analysis_AspectDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this aspect descriptor; this is a uint32, only valid
  /// for the particular dump of the analysis.
  public var id: UInt32 = 0

  /// The name of the corresponding aspect. For native aspects, it's the Java
  /// class name, for Starlark aspects it's the bzl file followed by a % sign
  /// followed by the name of the aspect.
  public var name: String = String()

  /// The list of parameters bound to a particular invocation of that aspect on
  /// a target. Note that aspects can be executed multiple times on the same
  /// target in different order.
  public var parameters: [Analysis_KeyValuePair] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Analysis_DepSetOfFiles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this named set of files; this is a uint32, only
  /// valid for the particular dump of the analysis.
  public var id: UInt32 = 0

  /// Other transitively included named set of files.
  public var transitiveDepSetIds: [UInt32] = []

  /// The list of input artifact IDs that are immediately contained in this set.
  public var directArtifactIds: [UInt32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Analysis_Configuration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this configuration; this is a uint32, only valid for
  /// the particular dump of the analysis.
  public var id: UInt32 = 0

  /// The mnemonic representing the build configuration.
  public var mnemonic: String = String()

  /// The platform string.
  public var platformName: String = String()

  /// The checksum representation of the configuration options;
  public var checksum: String = String()

  /// Whether this configuration is used for building tools.
  public var isTool: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Analysis_KeyValuePair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The variable name.
  public var key: String = String()

  /// The variable value.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Analysis_ConfiguredTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The target. We use blaze_query.Target defined in build.proto instead of
  /// the Target defined in this file because blaze_query.Target is much heavier
  /// and will output proto results similar to what users are familiar with from
  /// regular blaze query.
  public var target: BlazeQuery_Target {
    get {return _target ?? BlazeQuery_Target()}
    set {_target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return self._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {self._target = nil}

  /// DEPRECATED. Use configuration_id instead.
  public var configuration: Analysis_Configuration {
    get {return _configuration ?? Analysis_Configuration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {self._configuration = nil}

  /// The id of the configuration this target is configured for. The actual
  /// Configuration message can be found in CqueryResults. If the target doesn't
  /// have a configuration, the value will be 0.
  public var configurationID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _target: BlazeQuery_Target? = nil
  fileprivate var _configuration: Analysis_Configuration? = nil
}

/// Container for cquery results
public struct Analysis_CqueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All the configuredtargets returns by cquery
  public var results: [Analysis_ConfiguredTarget] = []

  /// All the Configurations referenced by results.
  public var configurations: [Analysis_Configuration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Content of a param file.
public struct Analysis_ParamFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The exec path of the param file artifact.
  public var execPath: String = String()

  /// The arguments in the param file.
  /// Each argument corresponds to a line in the param file.
  public var arguments: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The path fragment that makes up a full path.
public struct Analysis_PathFragment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for this path fragment.
  public var id: UInt32 = 0

  /// The label of the section in the path.
  public var label: String = String()

  /// The id of the parent path fragment.
  public var parentID: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Analysis_ActionGraphContainer: @unchecked Sendable {}
extension Analysis_Artifact: @unchecked Sendable {}
extension Analysis_Action: @unchecked Sendable {}
extension Analysis_Target: @unchecked Sendable {}
extension Analysis_RuleClass: @unchecked Sendable {}
extension Analysis_AspectDescriptor: @unchecked Sendable {}
extension Analysis_DepSetOfFiles: @unchecked Sendable {}
extension Analysis_Configuration: @unchecked Sendable {}
extension Analysis_KeyValuePair: @unchecked Sendable {}
extension Analysis_ConfiguredTarget: @unchecked Sendable {}
extension Analysis_CqueryResult: @unchecked Sendable {}
extension Analysis_ParamFile: @unchecked Sendable {}
extension Analysis_PathFragment: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "analysis"

extension Analysis_ActionGraphContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionGraphContainer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "artifacts"),
    2: .same(proto: "actions"),
    3: .same(proto: "targets"),
    4: .standard(proto: "dep_set_of_files"),
    5: .same(proto: "configuration"),
    6: .standard(proto: "aspect_descriptors"),
    7: .standard(proto: "rule_classes"),
    8: .standard(proto: "path_fragments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.artifacts) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.depSetOfFiles) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.configuration) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.aspectDescriptors) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.ruleClasses) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.pathFragments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifacts, fieldNumber: 1)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 2)
    }
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 3)
    }
    if !self.depSetOfFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.depSetOfFiles, fieldNumber: 4)
    }
    if !self.configuration.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configuration, fieldNumber: 5)
    }
    if !self.aspectDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aspectDescriptors, fieldNumber: 6)
    }
    if !self.ruleClasses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ruleClasses, fieldNumber: 7)
    }
    if !self.pathFragments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pathFragments, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_ActionGraphContainer, rhs: Analysis_ActionGraphContainer) -> Bool {
    if lhs.artifacts != rhs.artifacts {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.targets != rhs.targets {return false}
    if lhs.depSetOfFiles != rhs.depSetOfFiles {return false}
    if lhs.configuration != rhs.configuration {return false}
    if lhs.aspectDescriptors != rhs.aspectDescriptors {return false}
    if lhs.ruleClasses != rhs.ruleClasses {return false}
    if lhs.pathFragments != rhs.pathFragments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_Artifact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Artifact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "path_fragment_id"),
    3: .standard(proto: "is_tree_artifact"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.pathFragmentID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isTreeArtifact) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.pathFragmentID != 0 {
      try visitor.visitSingularUInt32Field(value: self.pathFragmentID, fieldNumber: 2)
    }
    if self.isTreeArtifact != false {
      try visitor.visitSingularBoolField(value: self.isTreeArtifact, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_Artifact, rhs: Analysis_Artifact) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pathFragmentID != rhs.pathFragmentID {return false}
    if lhs.isTreeArtifact != rhs.isTreeArtifact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .standard(proto: "aspect_descriptor_ids"),
    3: .standard(proto: "action_key"),
    4: .same(proto: "mnemonic"),
    5: .standard(proto: "configuration_id"),
    6: .same(proto: "arguments"),
    7: .standard(proto: "environment_variables"),
    8: .standard(proto: "input_dep_set_ids"),
    9: .standard(proto: "output_ids"),
    10: .standard(proto: "discovers_inputs"),
    11: .standard(proto: "execution_info"),
    12: .standard(proto: "param_files"),
    13: .standard(proto: "primary_output_id"),
    14: .standard(proto: "execution_platform"),
    15: .standard(proto: "template_content"),
    16: .same(proto: "substitutions"),
    17: .standard(proto: "file_contents"),
  ]

  fileprivate class _StorageClass {
    var _targetID: UInt32 = 0
    var _aspectDescriptorIds: [UInt32] = []
    var _actionKey: String = String()
    var _mnemonic: String = String()
    var _configurationID: UInt32 = 0
    var _arguments: [String] = []
    var _environmentVariables: [Analysis_KeyValuePair] = []
    var _inputDepSetIds: [UInt32] = []
    var _outputIds: [UInt32] = []
    var _discoversInputs: Bool = false
    var _executionInfo: [Analysis_KeyValuePair] = []
    var _paramFiles: [Analysis_ParamFile] = []
    var _primaryOutputID: UInt32 = 0
    var _executionPlatform: String = String()
    var _templateContent: String = String()
    var _substitutions: [Analysis_KeyValuePair] = []
    var _fileContents: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _targetID = source._targetID
      _aspectDescriptorIds = source._aspectDescriptorIds
      _actionKey = source._actionKey
      _mnemonic = source._mnemonic
      _configurationID = source._configurationID
      _arguments = source._arguments
      _environmentVariables = source._environmentVariables
      _inputDepSetIds = source._inputDepSetIds
      _outputIds = source._outputIds
      _discoversInputs = source._discoversInputs
      _executionInfo = source._executionInfo
      _paramFiles = source._paramFiles
      _primaryOutputID = source._primaryOutputID
      _executionPlatform = source._executionPlatform
      _templateContent = source._templateContent
      _substitutions = source._substitutions
      _fileContents = source._fileContents
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._targetID) }()
        case 2: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._aspectDescriptorIds) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._actionKey) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._mnemonic) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._configurationID) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._arguments) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._environmentVariables) }()
        case 8: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._inputDepSetIds) }()
        case 9: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._outputIds) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._discoversInputs) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._executionInfo) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._paramFiles) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._primaryOutputID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._executionPlatform) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._templateContent) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._substitutions) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._fileContents) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._targetID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._targetID, fieldNumber: 1)
      }
      if !_storage._aspectDescriptorIds.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._aspectDescriptorIds, fieldNumber: 2)
      }
      if !_storage._actionKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionKey, fieldNumber: 3)
      }
      if !_storage._mnemonic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mnemonic, fieldNumber: 4)
      }
      if _storage._configurationID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._configurationID, fieldNumber: 5)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._arguments, fieldNumber: 6)
      }
      if !_storage._environmentVariables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._environmentVariables, fieldNumber: 7)
      }
      if !_storage._inputDepSetIds.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._inputDepSetIds, fieldNumber: 8)
      }
      if !_storage._outputIds.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._outputIds, fieldNumber: 9)
      }
      if _storage._discoversInputs != false {
        try visitor.visitSingularBoolField(value: _storage._discoversInputs, fieldNumber: 10)
      }
      if !_storage._executionInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._executionInfo, fieldNumber: 11)
      }
      if !_storage._paramFiles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._paramFiles, fieldNumber: 12)
      }
      if _storage._primaryOutputID != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._primaryOutputID, fieldNumber: 13)
      }
      if !_storage._executionPlatform.isEmpty {
        try visitor.visitSingularStringField(value: _storage._executionPlatform, fieldNumber: 14)
      }
      if !_storage._templateContent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._templateContent, fieldNumber: 15)
      }
      if !_storage._substitutions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._substitutions, fieldNumber: 16)
      }
      if !_storage._fileContents.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fileContents, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_Action, rhs: Analysis_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._aspectDescriptorIds != rhs_storage._aspectDescriptorIds {return false}
        if _storage._actionKey != rhs_storage._actionKey {return false}
        if _storage._mnemonic != rhs_storage._mnemonic {return false}
        if _storage._configurationID != rhs_storage._configurationID {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._environmentVariables != rhs_storage._environmentVariables {return false}
        if _storage._inputDepSetIds != rhs_storage._inputDepSetIds {return false}
        if _storage._outputIds != rhs_storage._outputIds {return false}
        if _storage._discoversInputs != rhs_storage._discoversInputs {return false}
        if _storage._executionInfo != rhs_storage._executionInfo {return false}
        if _storage._paramFiles != rhs_storage._paramFiles {return false}
        if _storage._primaryOutputID != rhs_storage._primaryOutputID {return false}
        if _storage._executionPlatform != rhs_storage._executionPlatform {return false}
        if _storage._templateContent != rhs_storage._templateContent {return false}
        if _storage._substitutions != rhs_storage._substitutions {return false}
        if _storage._fileContents != rhs_storage._fileContents {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Target"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .standard(proto: "rule_class_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.ruleClassID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.ruleClassID != 0 {
      try visitor.visitSingularUInt32Field(value: self.ruleClassID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_Target, rhs: Analysis_Target) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.ruleClassID != rhs.ruleClassID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_RuleClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuleClass"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_RuleClass, rhs: Analysis_RuleClass) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_AspectDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AspectDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.parameters, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_AspectDescriptor, rhs: Analysis_AspectDescriptor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_DepSetOfFiles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DepSetOfFiles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "transitive_dep_set_ids"),
    3: .standard(proto: "direct_artifact_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.transitiveDepSetIds) }()
      case 3: try { try decoder.decodeRepeatedUInt32Field(value: &self.directArtifactIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.transitiveDepSetIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.transitiveDepSetIds, fieldNumber: 2)
    }
    if !self.directArtifactIds.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.directArtifactIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_DepSetOfFiles, rhs: Analysis_DepSetOfFiles) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.transitiveDepSetIds != rhs.transitiveDepSetIds {return false}
    if lhs.directArtifactIds != rhs.directArtifactIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Configuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "mnemonic"),
    3: .standard(proto: "platform_name"),
    4: .same(proto: "checksum"),
    5: .standard(proto: "is_tool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mnemonic) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platformName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isTool) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.mnemonic.isEmpty {
      try visitor.visitSingularStringField(value: self.mnemonic, fieldNumber: 2)
    }
    if !self.platformName.isEmpty {
      try visitor.visitSingularStringField(value: self.platformName, fieldNumber: 3)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 4)
    }
    if self.isTool != false {
      try visitor.visitSingularBoolField(value: self.isTool, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_Configuration, rhs: Analysis_Configuration) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.mnemonic != rhs.mnemonic {return false}
    if lhs.platformName != rhs.platformName {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.isTool != rhs.isTool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_KeyValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyValuePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_KeyValuePair, rhs: Analysis_KeyValuePair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_ConfiguredTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfiguredTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .same(proto: "configuration"),
    3: .standard(proto: "configuration_id"),
  ]

  public var isInitialized: Bool {
    if let v = self._target, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._target) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.configurationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.configurationID != 0 {
      try visitor.visitSingularUInt32Field(value: self.configurationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_ConfiguredTarget, rhs: Analysis_ConfiguredTarget) -> Bool {
    if lhs._target != rhs._target {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_CqueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CqueryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .same(proto: "configurations"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.results) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.configurations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.configurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configurations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_CqueryResult, rhs: Analysis_CqueryResult) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.configurations != rhs.configurations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_ParamFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParamFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exec_path"),
    2: .same(proto: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.execPath) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.execPath.isEmpty {
      try visitor.visitSingularStringField(value: self.execPath, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_ParamFile, rhs: Analysis_ParamFile) -> Bool {
    if lhs.execPath != rhs.execPath {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Analysis_PathFragment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PathFragment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .standard(proto: "parent_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.parentID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.parentID != 0 {
      try visitor.visitSingularUInt32Field(value: self.parentID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Analysis_PathFragment, rhs: Analysis_PathFragment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.label != rhs.label {return false}
    if lhs.parentID != rhs.parentID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
