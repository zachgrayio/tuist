// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/execution_statistics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Verbatim representation of the rusage structure returned by getrusage(2).
/// For further details on all these cryptic names, see that manual page.
public struct Tools_Protos_ResourceUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user CPU time used, seconds part
  public var utimeSec: Int64 {
    get {return _storage._utimeSec}
    set {_uniqueStorage()._utimeSec = newValue}
  }

  /// user CPU time used, microseconds part
  public var utimeUsec: Int64 {
    get {return _storage._utimeUsec}
    set {_uniqueStorage()._utimeUsec = newValue}
  }

  /// system CPU time used, seconds part
  public var stimeSec: Int64 {
    get {return _storage._stimeSec}
    set {_uniqueStorage()._stimeSec = newValue}
  }

  /// system CPU time used, microseconds part
  public var stimeUsec: Int64 {
    get {return _storage._stimeUsec}
    set {_uniqueStorage()._stimeUsec = newValue}
  }

  /// maximum resident set size
  public var maxrss: Int64 {
    get {return _storage._maxrss}
    set {_uniqueStorage()._maxrss = newValue}
  }

  /// integral shared memory size
  public var ixrss: Int64 {
    get {return _storage._ixrss}
    set {_uniqueStorage()._ixrss = newValue}
  }

  /// integral unshared data size
  public var idrss: Int64 {
    get {return _storage._idrss}
    set {_uniqueStorage()._idrss = newValue}
  }

  /// integral unshared stack size
  public var isrss: Int64 {
    get {return _storage._isrss}
    set {_uniqueStorage()._isrss = newValue}
  }

  /// page reclaims (soft page faults)
  public var minflt: Int64 {
    get {return _storage._minflt}
    set {_uniqueStorage()._minflt = newValue}
  }

  /// page faults (hard page faults)
  public var majflt: Int64 {
    get {return _storage._majflt}
    set {_uniqueStorage()._majflt = newValue}
  }

  /// swaps
  public var nswap: Int64 {
    get {return _storage._nswap}
    set {_uniqueStorage()._nswap = newValue}
  }

  /// block input operations
  public var inblock: Int64 {
    get {return _storage._inblock}
    set {_uniqueStorage()._inblock = newValue}
  }

  /// block output operations
  public var oublock: Int64 {
    get {return _storage._oublock}
    set {_uniqueStorage()._oublock = newValue}
  }

  /// IPC messages sent
  public var msgsnd: Int64 {
    get {return _storage._msgsnd}
    set {_uniqueStorage()._msgsnd = newValue}
  }

  /// IPC messages received
  public var msgrcv: Int64 {
    get {return _storage._msgrcv}
    set {_uniqueStorage()._msgrcv = newValue}
  }

  /// signals received
  public var nsignals: Int64 {
    get {return _storage._nsignals}
    set {_uniqueStorage()._nsignals = newValue}
  }

  /// voluntary context switches
  public var nvcsw: Int64 {
    get {return _storage._nvcsw}
    set {_uniqueStorage()._nvcsw = newValue}
  }

  /// involuntary context switches
  public var nivcsw: Int64 {
    get {return _storage._nivcsw}
    set {_uniqueStorage()._nivcsw = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Tools_Protos_ExecutionStatistics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var resourceUsage: Tools_Protos_ResourceUsage {
    get {return _resourceUsage ?? Tools_Protos_ResourceUsage()}
    set {_resourceUsage = newValue}
  }
  /// Returns true if `resourceUsage` has been explicitly set.
  public var hasResourceUsage: Bool {return self._resourceUsage != nil}
  /// Clears the value of `resourceUsage`. Subsequent reads from it will return its default value.
  public mutating func clearResourceUsage() {self._resourceUsage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resourceUsage: Tools_Protos_ResourceUsage? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tools_Protos_ResourceUsage: @unchecked Sendable {}
extension Tools_Protos_ExecutionStatistics: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tools.protos"

extension Tools_Protos_ResourceUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "utime_sec"),
    2: .standard(proto: "utime_usec"),
    3: .standard(proto: "stime_sec"),
    4: .standard(proto: "stime_usec"),
    5: .same(proto: "maxrss"),
    6: .same(proto: "ixrss"),
    7: .same(proto: "idrss"),
    8: .same(proto: "isrss"),
    9: .same(proto: "minflt"),
    10: .same(proto: "majflt"),
    11: .same(proto: "nswap"),
    12: .same(proto: "inblock"),
    13: .same(proto: "oublock"),
    14: .same(proto: "msgsnd"),
    15: .same(proto: "msgrcv"),
    16: .same(proto: "nsignals"),
    17: .same(proto: "nvcsw"),
    18: .same(proto: "nivcsw"),
  ]

  fileprivate class _StorageClass {
    var _utimeSec: Int64 = 0
    var _utimeUsec: Int64 = 0
    var _stimeSec: Int64 = 0
    var _stimeUsec: Int64 = 0
    var _maxrss: Int64 = 0
    var _ixrss: Int64 = 0
    var _idrss: Int64 = 0
    var _isrss: Int64 = 0
    var _minflt: Int64 = 0
    var _majflt: Int64 = 0
    var _nswap: Int64 = 0
    var _inblock: Int64 = 0
    var _oublock: Int64 = 0
    var _msgsnd: Int64 = 0
    var _msgrcv: Int64 = 0
    var _nsignals: Int64 = 0
    var _nvcsw: Int64 = 0
    var _nivcsw: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _utimeSec = source._utimeSec
      _utimeUsec = source._utimeUsec
      _stimeSec = source._stimeSec
      _stimeUsec = source._stimeUsec
      _maxrss = source._maxrss
      _ixrss = source._ixrss
      _idrss = source._idrss
      _isrss = source._isrss
      _minflt = source._minflt
      _majflt = source._majflt
      _nswap = source._nswap
      _inblock = source._inblock
      _oublock = source._oublock
      _msgsnd = source._msgsnd
      _msgrcv = source._msgrcv
      _nsignals = source._nsignals
      _nvcsw = source._nvcsw
      _nivcsw = source._nivcsw
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._utimeSec) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._utimeUsec) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._stimeSec) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._stimeUsec) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._maxrss) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._ixrss) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._idrss) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._isrss) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._minflt) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._majflt) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._nswap) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._inblock) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._oublock) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._msgsnd) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._msgrcv) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._nsignals) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._nvcsw) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._nivcsw) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._utimeSec != 0 {
        try visitor.visitSingularInt64Field(value: _storage._utimeSec, fieldNumber: 1)
      }
      if _storage._utimeUsec != 0 {
        try visitor.visitSingularInt64Field(value: _storage._utimeUsec, fieldNumber: 2)
      }
      if _storage._stimeSec != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stimeSec, fieldNumber: 3)
      }
      if _storage._stimeUsec != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stimeUsec, fieldNumber: 4)
      }
      if _storage._maxrss != 0 {
        try visitor.visitSingularInt64Field(value: _storage._maxrss, fieldNumber: 5)
      }
      if _storage._ixrss != 0 {
        try visitor.visitSingularInt64Field(value: _storage._ixrss, fieldNumber: 6)
      }
      if _storage._idrss != 0 {
        try visitor.visitSingularInt64Field(value: _storage._idrss, fieldNumber: 7)
      }
      if _storage._isrss != 0 {
        try visitor.visitSingularInt64Field(value: _storage._isrss, fieldNumber: 8)
      }
      if _storage._minflt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._minflt, fieldNumber: 9)
      }
      if _storage._majflt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._majflt, fieldNumber: 10)
      }
      if _storage._nswap != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nswap, fieldNumber: 11)
      }
      if _storage._inblock != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inblock, fieldNumber: 12)
      }
      if _storage._oublock != 0 {
        try visitor.visitSingularInt64Field(value: _storage._oublock, fieldNumber: 13)
      }
      if _storage._msgsnd != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgsnd, fieldNumber: 14)
      }
      if _storage._msgrcv != 0 {
        try visitor.visitSingularInt64Field(value: _storage._msgrcv, fieldNumber: 15)
      }
      if _storage._nsignals != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nsignals, fieldNumber: 16)
      }
      if _storage._nvcsw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nvcsw, fieldNumber: 17)
      }
      if _storage._nivcsw != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nivcsw, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_ResourceUsage, rhs: Tools_Protos_ResourceUsage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._utimeSec != rhs_storage._utimeSec {return false}
        if _storage._utimeUsec != rhs_storage._utimeUsec {return false}
        if _storage._stimeSec != rhs_storage._stimeSec {return false}
        if _storage._stimeUsec != rhs_storage._stimeUsec {return false}
        if _storage._maxrss != rhs_storage._maxrss {return false}
        if _storage._ixrss != rhs_storage._ixrss {return false}
        if _storage._idrss != rhs_storage._idrss {return false}
        if _storage._isrss != rhs_storage._isrss {return false}
        if _storage._minflt != rhs_storage._minflt {return false}
        if _storage._majflt != rhs_storage._majflt {return false}
        if _storage._nswap != rhs_storage._nswap {return false}
        if _storage._inblock != rhs_storage._inblock {return false}
        if _storage._oublock != rhs_storage._oublock {return false}
        if _storage._msgsnd != rhs_storage._msgsnd {return false}
        if _storage._msgrcv != rhs_storage._msgrcv {return false}
        if _storage._nsignals != rhs_storage._nsignals {return false}
        if _storage._nvcsw != rhs_storage._nvcsw {return false}
        if _storage._nivcsw != rhs_storage._nivcsw {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_ExecutionStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionStatistics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resourceUsage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resourceUsage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_ExecutionStatistics, rhs: Tools_Protos_ExecutionStatistics) -> Bool {
    if lhs._resourceUsage != rhs._resourceUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
