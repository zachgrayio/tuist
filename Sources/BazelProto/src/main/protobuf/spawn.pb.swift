// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/spawn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Tools_Protos_Digest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Digest of a file's contents using the current FileSystem digest function.
  public var hash: String = String()

  /// The size in bytes of the original content.
  public var sizeBytes: Int64 = 0

  /// The digest function that was used to generate the hash.
  /// This is not an enum for compatibility reasons, and also because the
  /// purpose of these logs is to enable analysis by comparison of multiple
  /// builds. So, from the programmatic perspective, this is an opaque field.
  public var hashFunctionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Tools_Protos_File {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the file relative to the execution root.
  public var path: String = String()

  /// Digest of the file's contents.
  public var digest: Tools_Protos_Digest {
    get {return _digest ?? Tools_Protos_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Tools_Protos_Digest? = nil
}

/// Contents of command environment.
public struct Tools_Protos_EnvironmentVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Command execution platform. This message needs to be kept in sync
/// with [Platform][google.devtools.remoteexecution.v1test.Platform].
public struct Tools_Protos_Platform {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var properties: [Tools_Protos_Platform.Property] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Property {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Timing, size, and memory statistics for a SpawnExec.
public struct Tools_Protos_SpawnMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total wall time spent running a spawn, measured locally.
  public var totalTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._totalTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._totalTime = newValue}
  }
  /// Returns true if `totalTime` has been explicitly set.
  public var hasTotalTime: Bool {return _storage._totalTime != nil}
  /// Clears the value of `totalTime`. Subsequent reads from it will return its default value.
  public mutating func clearTotalTime() {_uniqueStorage()._totalTime = nil}

  /// Time taken to convert the spawn into a network request.
  public var parseTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._parseTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._parseTime = newValue}
  }
  /// Returns true if `parseTime` has been explicitly set.
  public var hasParseTime: Bool {return _storage._parseTime != nil}
  /// Clears the value of `parseTime`. Subsequent reads from it will return its default value.
  public mutating func clearParseTime() {_uniqueStorage()._parseTime = nil}

  /// Time spent communicating over the network.
  public var networkTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._networkTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._networkTime = newValue}
  }
  /// Returns true if `networkTime` has been explicitly set.
  public var hasNetworkTime: Bool {return _storage._networkTime != nil}
  /// Clears the value of `networkTime`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkTime() {_uniqueStorage()._networkTime = nil}

  /// Time spent fetching remote outputs.
  public var fetchTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._fetchTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._fetchTime = newValue}
  }
  /// Returns true if `fetchTime` has been explicitly set.
  public var hasFetchTime: Bool {return _storage._fetchTime != nil}
  /// Clears the value of `fetchTime`. Subsequent reads from it will return its default value.
  public mutating func clearFetchTime() {_uniqueStorage()._fetchTime = nil}

  /// Time spent waiting in queues.
  public var queueTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._queueTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._queueTime = newValue}
  }
  /// Returns true if `queueTime` has been explicitly set.
  public var hasQueueTime: Bool {return _storage._queueTime != nil}
  /// Clears the value of `queueTime`. Subsequent reads from it will return its default value.
  public mutating func clearQueueTime() {_uniqueStorage()._queueTime = nil}

  /// Time spent setting up the environment in which the spawn is run.
  public var setupTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._setupTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._setupTime = newValue}
  }
  /// Returns true if `setupTime` has been explicitly set.
  public var hasSetupTime: Bool {return _storage._setupTime != nil}
  /// Clears the value of `setupTime`. Subsequent reads from it will return its default value.
  public mutating func clearSetupTime() {_uniqueStorage()._setupTime = nil}

  /// Time spent uploading outputs to a remote store.
  public var uploadTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._uploadTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._uploadTime = newValue}
  }
  /// Returns true if `uploadTime` has been explicitly set.
  public var hasUploadTime: Bool {return _storage._uploadTime != nil}
  /// Clears the value of `uploadTime`. Subsequent reads from it will return its default value.
  public mutating func clearUploadTime() {_uniqueStorage()._uploadTime = nil}

  /// Time spent running the subprocess.
  public var executionWallTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._executionWallTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._executionWallTime = newValue}
  }
  /// Returns true if `executionWallTime` has been explicitly set.
  public var hasExecutionWallTime: Bool {return _storage._executionWallTime != nil}
  /// Clears the value of `executionWallTime`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionWallTime() {_uniqueStorage()._executionWallTime = nil}

  /// Time spent by the execution framework processing outputs.
  public var processOutputsTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._processOutputsTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._processOutputsTime = newValue}
  }
  /// Returns true if `processOutputsTime` has been explicitly set.
  public var hasProcessOutputsTime: Bool {return _storage._processOutputsTime != nil}
  /// Clears the value of `processOutputsTime`. Subsequent reads from it will return its default value.
  public mutating func clearProcessOutputsTime() {_uniqueStorage()._processOutputsTime = nil}

  /// Time spent in previous failed attempts, not including queue time.
  public var retryTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._retryTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._retryTime = newValue}
  }
  /// Returns true if `retryTime` has been explicitly set.
  public var hasRetryTime: Bool {return _storage._retryTime != nil}
  /// Clears the value of `retryTime`. Subsequent reads from it will return its default value.
  public mutating func clearRetryTime() {_uniqueStorage()._retryTime = nil}

  /// Total size in bytes of inputs or 0 if unavailable.
  public var inputBytes: Int64 {
    get {return _storage._inputBytes}
    set {_uniqueStorage()._inputBytes = newValue}
  }

  /// Total number of input files or 0 if unavailable.
  public var inputFiles: Int64 {
    get {return _storage._inputFiles}
    set {_uniqueStorage()._inputFiles = newValue}
  }

  /// Estimated memory usage or 0 if unavailable.
  public var memoryEstimateBytes: Int64 {
    get {return _storage._memoryEstimateBytes}
    set {_uniqueStorage()._memoryEstimateBytes = newValue}
  }

  /// Limit of total size of inputs or 0 if unavailable.
  public var inputBytesLimit: Int64 {
    get {return _storage._inputBytesLimit}
    set {_uniqueStorage()._inputBytesLimit = newValue}
  }

  /// Limit of total number of input files or 0 if unavailable.
  public var inputFilesLimit: Int64 {
    get {return _storage._inputFilesLimit}
    set {_uniqueStorage()._inputFilesLimit = newValue}
  }

  /// Limit of total size of outputs or 0 if unavailable.
  public var outputBytesLimit: Int64 {
    get {return _storage._outputBytesLimit}
    set {_uniqueStorage()._outputBytesLimit = newValue}
  }

  /// Limit of total number of output files or 0 if unavailable.
  public var outputFilesLimit: Int64 {
    get {return _storage._outputFilesLimit}
    set {_uniqueStorage()._outputFilesLimit = newValue}
  }

  /// Memory limit or 0 if unavailable.
  public var memoryBytesLimit: Int64 {
    get {return _storage._memoryBytesLimit}
    set {_uniqueStorage()._memoryBytesLimit = newValue}
  }

  /// Time limit or 0 if unavailable.
  public var timeLimit: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeLimit ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeLimit = newValue}
  }
  /// Returns true if `timeLimit` has been explicitly set.
  public var hasTimeLimit: Bool {return _storage._timeLimit != nil}
  /// Clears the value of `timeLimit`. Subsequent reads from it will return its default value.
  public mutating func clearTimeLimit() {_uniqueStorage()._timeLimit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Details of an executed spawn.
/// These will only be generated on demand, using the
/// --execution_log_file=<path> flag.
/// Each message contains an executed command, its full inputs and outputs.
/// The purpose of these is to enable comparisons of multiple builds to diagnose
/// output differences or more subtle problems such as remote caching misses.
/// Only the executed Spawns will be output -- local cache hits are ignored.
public struct Tools_Protos_SpawnExec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The command that was run.
  public var commandArgs: [String] {
    get {return _storage._commandArgs}
    set {_uniqueStorage()._commandArgs = newValue}
  }

  /// The command environment.
  public var environmentVariables: [Tools_Protos_EnvironmentVariable] {
    get {return _storage._environmentVariables}
    set {_uniqueStorage()._environmentVariables = newValue}
  }

  /// The command execution platform.
  public var platform: Tools_Protos_Platform {
    get {return _storage._platform ?? Tools_Protos_Platform()}
    set {_uniqueStorage()._platform = newValue}
  }
  /// Returns true if `platform` has been explicitly set.
  public var hasPlatform: Bool {return _storage._platform != nil}
  /// Clears the value of `platform`. Subsequent reads from it will return its default value.
  public mutating func clearPlatform() {_uniqueStorage()._platform = nil}

  /// The inputs at the time of the execution.
  public var inputs: [Tools_Protos_File] {
    get {return _storage._inputs}
    set {_uniqueStorage()._inputs = newValue}
  }

  /// All the listed outputs paths. The paths are relative to the execution root.
  /// Actual outputs are a subset of the listed outputs. These paths are sorted.
  public var listedOutputs: [String] {
    get {return _storage._listedOutputs}
    set {_uniqueStorage()._listedOutputs = newValue}
  }

  /// Was the Spawn allowed to be executed remotely.
  public var remotable: Bool {
    get {return _storage._remotable}
    set {_uniqueStorage()._remotable = newValue}
  }

  /// Was the Spawn result allowed to be cached.
  public var cacheable: Bool {
    get {return _storage._cacheable}
    set {_uniqueStorage()._cacheable = newValue}
  }

  /// The Spawn timeout.
  public var timeoutMillis: Int64 {
    get {return _storage._timeoutMillis}
    set {_uniqueStorage()._timeoutMillis = newValue}
  }

  /// A user-friendly text message representing the spawn progress.
  public var progressMessage: String {
    get {return _storage._progressMessage}
    set {_uniqueStorage()._progressMessage = newValue}
  }

  /// An opaque string that identifies the type of the Spawn's action.
  public var mnemonic: String {
    get {return _storage._mnemonic}
    set {_uniqueStorage()._mnemonic = newValue}
  }

  /// The outputs generated by the execution.
  public var actualOutputs: [Tools_Protos_File] {
    get {return _storage._actualOutputs}
    set {_uniqueStorage()._actualOutputs = newValue}
  }

  /// If the Spawn was actually executed, rather than a cache hit,
  /// this will be the name of the runner executing the spawn, e.g. remote or
  /// linux-sandbox. If it was a remote cache hit, the runner will be
  /// "remote cache hit". If it was a local cache hit, the action will not be
  /// included in the log in the first place.
  ///
  /// Note, this is not the same as the "strategy" string -- even
  /// though the action strategy may be remote. A particular action may still
  /// fall back to local execution due to a variety of reasons. This field
  /// indicates what really happened for the particular Spawn+execution.
  public var runner: String {
    get {return _storage._runner}
    set {_uniqueStorage()._runner = newValue}
  }

  /// Whether the Spawn was a remote cache hit, in which case it was not executed
  /// and the runner field will be empty.
  public var remoteCacheHit: Bool {
    get {return _storage._remoteCacheHit}
    set {_uniqueStorage()._remoteCacheHit = newValue}
  }

  /// A text status returned by the execution, in case there were any errors.
  /// Empty in case of successful execution.
  public var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// This field contains the contents of SpawnResult.exitCode.
  /// Its semantics varies greatly depending on the status field.
  /// Dependable: if status is empty, exit_code is guaranteed to be zero.
  public var exitCode: Int32 {
    get {return _storage._exitCode}
    set {_uniqueStorage()._exitCode = newValue}
  }

  /// Was the Spawn result allowed to be cached remotely.
  public var remoteCacheable: Bool {
    get {return _storage._remoteCacheable}
    set {_uniqueStorage()._remoteCacheable = newValue}
  }

  /// The wall time it took to execute the Spawn. This is only the time spent in
  /// the subprocess, not including the time doing setup and teardown.
  public var walltime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._walltime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._walltime = newValue}
  }
  /// Returns true if `walltime` has been explicitly set.
  public var hasWalltime: Bool {return _storage._walltime != nil}
  /// Clears the value of `walltime`. Subsequent reads from it will return its default value.
  public mutating func clearWalltime() {_uniqueStorage()._walltime = nil}

  /// Canonical label of the target that emitted this spawn, may not always be
  /// set.
  public var targetLabel: String {
    get {return _storage._targetLabel}
    set {_uniqueStorage()._targetLabel = newValue}
  }

  /// A unique identifier for this Spawn.
  public var digest: Tools_Protos_Digest {
    get {return _storage._digest ?? Tools_Protos_Digest()}
    set {_uniqueStorage()._digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return _storage._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {_uniqueStorage()._digest = nil}

  /// Timing, size and memory statistics.
  public var metrics: Tools_Protos_SpawnMetrics {
    get {return _storage._metrics ?? Tools_Protos_SpawnMetrics()}
    set {_uniqueStorage()._metrics = newValue}
  }
  /// Returns true if `metrics` has been explicitly set.
  public var hasMetrics: Bool {return _storage._metrics != nil}
  /// Clears the value of `metrics`. Subsequent reads from it will return its default value.
  public mutating func clearMetrics() {_uniqueStorage()._metrics = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tools_Protos_Digest: @unchecked Sendable {}
extension Tools_Protos_File: @unchecked Sendable {}
extension Tools_Protos_EnvironmentVariable: @unchecked Sendable {}
extension Tools_Protos_Platform: @unchecked Sendable {}
extension Tools_Protos_Platform.Property: @unchecked Sendable {}
extension Tools_Protos_SpawnMetrics: @unchecked Sendable {}
extension Tools_Protos_SpawnExec: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tools.protos"

extension Tools_Protos_Digest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Digest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "size_bytes"),
    3: .standard(proto: "hash_function_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hashFunctionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 2)
    }
    if !self.hashFunctionName.isEmpty {
      try visitor.visitSingularStringField(value: self.hashFunctionName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_Digest, rhs: Tools_Protos_Digest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.hashFunctionName != rhs.hashFunctionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try { if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_File, rhs: Tools_Protos_File) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvironmentVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_EnvironmentVariable, rhs: Tools_Protos_EnvironmentVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_Platform: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Platform"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_Platform, rhs: Tools_Protos_Platform) -> Bool {
    if lhs.properties != rhs.properties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_Platform.Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Tools_Protos_Platform.protoMessageName + ".Property"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_Platform.Property, rhs: Tools_Protos_Platform.Property) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_SpawnMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpawnMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_time"),
    2: .standard(proto: "parse_time"),
    3: .standard(proto: "network_time"),
    4: .standard(proto: "fetch_time"),
    5: .standard(proto: "queue_time"),
    6: .standard(proto: "setup_time"),
    7: .standard(proto: "upload_time"),
    8: .standard(proto: "execution_wall_time"),
    9: .standard(proto: "process_outputs_time"),
    10: .standard(proto: "retry_time"),
    11: .standard(proto: "input_bytes"),
    12: .standard(proto: "input_files"),
    13: .standard(proto: "memory_estimate_bytes"),
    14: .standard(proto: "input_bytes_limit"),
    15: .standard(proto: "input_files_limit"),
    16: .standard(proto: "output_bytes_limit"),
    17: .standard(proto: "output_files_limit"),
    18: .standard(proto: "memory_bytes_limit"),
    19: .standard(proto: "time_limit"),
  ]

  fileprivate class _StorageClass {
    var _totalTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _parseTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _networkTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _fetchTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _queueTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _setupTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _uploadTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _executionWallTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _processOutputsTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _inputBytes: Int64 = 0
    var _inputFiles: Int64 = 0
    var _memoryEstimateBytes: Int64 = 0
    var _inputBytesLimit: Int64 = 0
    var _inputFilesLimit: Int64 = 0
    var _outputBytesLimit: Int64 = 0
    var _outputFilesLimit: Int64 = 0
    var _memoryBytesLimit: Int64 = 0
    var _timeLimit: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _totalTime = source._totalTime
      _parseTime = source._parseTime
      _networkTime = source._networkTime
      _fetchTime = source._fetchTime
      _queueTime = source._queueTime
      _setupTime = source._setupTime
      _uploadTime = source._uploadTime
      _executionWallTime = source._executionWallTime
      _processOutputsTime = source._processOutputsTime
      _retryTime = source._retryTime
      _inputBytes = source._inputBytes
      _inputFiles = source._inputFiles
      _memoryEstimateBytes = source._memoryEstimateBytes
      _inputBytesLimit = source._inputBytesLimit
      _inputFilesLimit = source._inputFilesLimit
      _outputBytesLimit = source._outputBytesLimit
      _outputFilesLimit = source._outputFilesLimit
      _memoryBytesLimit = source._memoryBytesLimit
      _timeLimit = source._timeLimit
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._totalTime) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._parseTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._networkTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._fetchTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._queueTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._setupTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._uploadTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._executionWallTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._processOutputsTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._retryTime) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._inputBytes) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._inputFiles) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._memoryEstimateBytes) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._inputBytesLimit) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._inputFilesLimit) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._outputBytesLimit) }()
        case 17: try { try decoder.decodeSingularInt64Field(value: &_storage._outputFilesLimit) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._memoryBytesLimit) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._timeLimit) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._totalTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._parseTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._networkTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._fetchTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._queueTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._setupTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._uploadTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._executionWallTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._processOutputsTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._retryTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._inputBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inputBytes, fieldNumber: 11)
      }
      if _storage._inputFiles != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inputFiles, fieldNumber: 12)
      }
      if _storage._memoryEstimateBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._memoryEstimateBytes, fieldNumber: 13)
      }
      if _storage._inputBytesLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inputBytesLimit, fieldNumber: 14)
      }
      if _storage._inputFilesLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inputFilesLimit, fieldNumber: 15)
      }
      if _storage._outputBytesLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._outputBytesLimit, fieldNumber: 16)
      }
      if _storage._outputFilesLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._outputFilesLimit, fieldNumber: 17)
      }
      if _storage._memoryBytesLimit != 0 {
        try visitor.visitSingularInt64Field(value: _storage._memoryBytesLimit, fieldNumber: 18)
      }
      try { if let v = _storage._timeLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_SpawnMetrics, rhs: Tools_Protos_SpawnMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._totalTime != rhs_storage._totalTime {return false}
        if _storage._parseTime != rhs_storage._parseTime {return false}
        if _storage._networkTime != rhs_storage._networkTime {return false}
        if _storage._fetchTime != rhs_storage._fetchTime {return false}
        if _storage._queueTime != rhs_storage._queueTime {return false}
        if _storage._setupTime != rhs_storage._setupTime {return false}
        if _storage._uploadTime != rhs_storage._uploadTime {return false}
        if _storage._executionWallTime != rhs_storage._executionWallTime {return false}
        if _storage._processOutputsTime != rhs_storage._processOutputsTime {return false}
        if _storage._retryTime != rhs_storage._retryTime {return false}
        if _storage._inputBytes != rhs_storage._inputBytes {return false}
        if _storage._inputFiles != rhs_storage._inputFiles {return false}
        if _storage._memoryEstimateBytes != rhs_storage._memoryEstimateBytes {return false}
        if _storage._inputBytesLimit != rhs_storage._inputBytesLimit {return false}
        if _storage._inputFilesLimit != rhs_storage._inputFilesLimit {return false}
        if _storage._outputBytesLimit != rhs_storage._outputBytesLimit {return false}
        if _storage._outputFilesLimit != rhs_storage._outputFilesLimit {return false}
        if _storage._memoryBytesLimit != rhs_storage._memoryBytesLimit {return false}
        if _storage._timeLimit != rhs_storage._timeLimit {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tools_Protos_SpawnExec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpawnExec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "command_args"),
    2: .standard(proto: "environment_variables"),
    3: .same(proto: "platform"),
    4: .same(proto: "inputs"),
    5: .standard(proto: "listed_outputs"),
    6: .same(proto: "remotable"),
    7: .same(proto: "cacheable"),
    8: .standard(proto: "timeout_millis"),
    9: .standard(proto: "progress_message"),
    10: .same(proto: "mnemonic"),
    11: .standard(proto: "actual_outputs"),
    12: .same(proto: "runner"),
    13: .standard(proto: "remote_cache_hit"),
    14: .same(proto: "status"),
    15: .standard(proto: "exit_code"),
    16: .standard(proto: "remote_cacheable"),
    17: .same(proto: "walltime"),
    18: .standard(proto: "target_label"),
    19: .same(proto: "digest"),
    20: .same(proto: "metrics"),
  ]

  fileprivate class _StorageClass {
    var _commandArgs: [String] = []
    var _environmentVariables: [Tools_Protos_EnvironmentVariable] = []
    var _platform: Tools_Protos_Platform? = nil
    var _inputs: [Tools_Protos_File] = []
    var _listedOutputs: [String] = []
    var _remotable: Bool = false
    var _cacheable: Bool = false
    var _timeoutMillis: Int64 = 0
    var _progressMessage: String = String()
    var _mnemonic: String = String()
    var _actualOutputs: [Tools_Protos_File] = []
    var _runner: String = String()
    var _remoteCacheHit: Bool = false
    var _status: String = String()
    var _exitCode: Int32 = 0
    var _remoteCacheable: Bool = false
    var _walltime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _targetLabel: String = String()
    var _digest: Tools_Protos_Digest? = nil
    var _metrics: Tools_Protos_SpawnMetrics? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commandArgs = source._commandArgs
      _environmentVariables = source._environmentVariables
      _platform = source._platform
      _inputs = source._inputs
      _listedOutputs = source._listedOutputs
      _remotable = source._remotable
      _cacheable = source._cacheable
      _timeoutMillis = source._timeoutMillis
      _progressMessage = source._progressMessage
      _mnemonic = source._mnemonic
      _actualOutputs = source._actualOutputs
      _runner = source._runner
      _remoteCacheHit = source._remoteCacheHit
      _status = source._status
      _exitCode = source._exitCode
      _remoteCacheable = source._remoteCacheable
      _walltime = source._walltime
      _targetLabel = source._targetLabel
      _digest = source._digest
      _metrics = source._metrics
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedStringField(value: &_storage._commandArgs) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._environmentVariables) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._platform) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._inputs) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._listedOutputs) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._remotable) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._cacheable) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._timeoutMillis) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._progressMessage) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._mnemonic) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._actualOutputs) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._runner) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._remoteCacheHit) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._exitCode) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._remoteCacheable) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._walltime) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._targetLabel) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._digest) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._metrics) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._commandArgs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._commandArgs, fieldNumber: 1)
      }
      if !_storage._environmentVariables.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._environmentVariables, fieldNumber: 2)
      }
      try { if let v = _storage._platform {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._inputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._inputs, fieldNumber: 4)
      }
      if !_storage._listedOutputs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._listedOutputs, fieldNumber: 5)
      }
      if _storage._remotable != false {
        try visitor.visitSingularBoolField(value: _storage._remotable, fieldNumber: 6)
      }
      if _storage._cacheable != false {
        try visitor.visitSingularBoolField(value: _storage._cacheable, fieldNumber: 7)
      }
      if _storage._timeoutMillis != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timeoutMillis, fieldNumber: 8)
      }
      if !_storage._progressMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._progressMessage, fieldNumber: 9)
      }
      if !_storage._mnemonic.isEmpty {
        try visitor.visitSingularStringField(value: _storage._mnemonic, fieldNumber: 10)
      }
      if !_storage._actualOutputs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actualOutputs, fieldNumber: 11)
      }
      if !_storage._runner.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runner, fieldNumber: 12)
      }
      if _storage._remoteCacheHit != false {
        try visitor.visitSingularBoolField(value: _storage._remoteCacheHit, fieldNumber: 13)
      }
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 14)
      }
      if _storage._exitCode != 0 {
        try visitor.visitSingularInt32Field(value: _storage._exitCode, fieldNumber: 15)
      }
      if _storage._remoteCacheable != false {
        try visitor.visitSingularBoolField(value: _storage._remoteCacheable, fieldNumber: 16)
      }
      try { if let v = _storage._walltime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._targetLabel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetLabel, fieldNumber: 18)
      }
      try { if let v = _storage._digest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._metrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Tools_Protos_SpawnExec, rhs: Tools_Protos_SpawnExec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commandArgs != rhs_storage._commandArgs {return false}
        if _storage._environmentVariables != rhs_storage._environmentVariables {return false}
        if _storage._platform != rhs_storage._platform {return false}
        if _storage._inputs != rhs_storage._inputs {return false}
        if _storage._listedOutputs != rhs_storage._listedOutputs {return false}
        if _storage._remotable != rhs_storage._remotable {return false}
        if _storage._cacheable != rhs_storage._cacheable {return false}
        if _storage._timeoutMillis != rhs_storage._timeoutMillis {return false}
        if _storage._progressMessage != rhs_storage._progressMessage {return false}
        if _storage._mnemonic != rhs_storage._mnemonic {return false}
        if _storage._actualOutputs != rhs_storage._actualOutputs {return false}
        if _storage._runner != rhs_storage._runner {return false}
        if _storage._remoteCacheHit != rhs_storage._remoteCacheHit {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._exitCode != rhs_storage._exitCode {return false}
        if _storage._remoteCacheable != rhs_storage._remoteCacheable {return false}
        if _storage._walltime != rhs_storage._walltime {return false}
        if _storage._targetLabel != rhs_storage._targetLabel {return false}
        if _storage._digest != rhs_storage._digest {return false}
        if _storage._metrics != rhs_storage._metrics {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
