// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/crosstool_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// File format for Blaze to configure Crosstool releases.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case fastbuild // = 1
  case dbg // = 2
  case opt // = 3

  /// This value is ignored and should not be used in new files.
  case coverage // = 4

  public init() {
    self = .fastbuild
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .fastbuild
    case 2: self = .dbg
    case 3: self = .opt
    case 4: self = .coverage
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .fastbuild: return 1
    case .dbg: return 2
    case .opt: return 3
    case .coverage: return 4
    }
  }

}

#if swift(>=4.2)

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public enum Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingMode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case fullyStatic // = 1
  case mostlyStatic // = 2
  case dynamic // = 3
  case mostlyStaticLibraries // = 4

  public init() {
    self = .fullyStatic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .fullyStatic
    case 2: self = .mostlyStatic
    case 3: self = .dynamic
    case 4: self = .mostlyStaticLibraries
    default: return nil
    }
  }

  public var rawValue: Int {
    switch self {
    case .fullyStatic: return 1
    case .mostlyStatic: return 2
    case .dynamic: return 3
    case .mostlyStaticLibraries: return 4
    }
  }

}

#if swift(>=4.2)

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A description of a toolchain, which includes all the tools generally expected
/// to be available for building C/C++ targets, based on the GNU C compiler.
///
/// System and cpu names are two overlapping concepts, which need to be both
/// supported at this time. The cpu name is the blaze command-line name for the
/// target system. The most common values are 'k8' and 'piii'. The system name is
/// a more generic identification of the executable system, based on the names
/// used by the GNU C compiler.
///
/// Typically, the system name contains an identifier for the cpu (e.g. x86_64 or
/// alpha), an identifier for the machine (e.g. pc, or unknown), and an
/// identifier for the operating system (e.g. cygwin or linux-gnu). Typical
/// examples are 'x86_64-unknown-linux-gnu' and 'i686-unknown-cygwin'.
///
/// The system name is used to determine if a given machine can execute a given
/// executable. In particular, it is used to check if the compilation products of
/// a toolchain can run on the host machine.
public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var feature: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Feature] {
    get {return _storage._feature}
    set {_uniqueStorage()._feature = newValue}
  }

  public var actionConfig: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ActionConfig] {
    get {return _storage._actionConfig}
    set {_uniqueStorage()._actionConfig = newValue}
  }

  public var artifactNamePattern: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ArtifactNamePattern] {
    get {return _storage._artifactNamePattern}
    set {_uniqueStorage()._artifactNamePattern = newValue}
  }

  /// The unique identifier of the toolchain within the crosstool release. It
  /// must be possible to use this as a directory name in a path.
  /// It has to match the following regex: [a-zA-Z_][\.\- \w]*
  public var toolchainIdentifier: String {
    get {return _storage._toolchainIdentifier ?? String()}
    set {_uniqueStorage()._toolchainIdentifier = newValue}
  }
  /// Returns true if `toolchainIdentifier` has been explicitly set.
  public var hasToolchainIdentifier: Bool {return _storage._toolchainIdentifier != nil}
  /// Clears the value of `toolchainIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearToolchainIdentifier() {_uniqueStorage()._toolchainIdentifier = nil}

  /// A basic toolchain description.
  public var hostSystemName: String {
    get {return _storage._hostSystemName ?? String()}
    set {_uniqueStorage()._hostSystemName = newValue}
  }
  /// Returns true if `hostSystemName` has been explicitly set.
  public var hasHostSystemName: Bool {return _storage._hostSystemName != nil}
  /// Clears the value of `hostSystemName`. Subsequent reads from it will return its default value.
  public mutating func clearHostSystemName() {_uniqueStorage()._hostSystemName = nil}

  public var targetSystemName: String {
    get {return _storage._targetSystemName ?? String()}
    set {_uniqueStorage()._targetSystemName = newValue}
  }
  /// Returns true if `targetSystemName` has been explicitly set.
  public var hasTargetSystemName: Bool {return _storage._targetSystemName != nil}
  /// Clears the value of `targetSystemName`. Subsequent reads from it will return its default value.
  public mutating func clearTargetSystemName() {_uniqueStorage()._targetSystemName = nil}

  public var targetCpu: String {
    get {return _storage._targetCpu ?? String()}
    set {_uniqueStorage()._targetCpu = newValue}
  }
  /// Returns true if `targetCpu` has been explicitly set.
  public var hasTargetCpu: Bool {return _storage._targetCpu != nil}
  /// Clears the value of `targetCpu`. Subsequent reads from it will return its default value.
  public mutating func clearTargetCpu() {_uniqueStorage()._targetCpu = nil}

  public var targetLibc: String {
    get {return _storage._targetLibc ?? String()}
    set {_uniqueStorage()._targetLibc = newValue}
  }
  /// Returns true if `targetLibc` has been explicitly set.
  public var hasTargetLibc: Bool {return _storage._targetLibc != nil}
  /// Clears the value of `targetLibc`. Subsequent reads from it will return its default value.
  public mutating func clearTargetLibc() {_uniqueStorage()._targetLibc = nil}

  public var compiler: String {
    get {return _storage._compiler ?? String()}
    set {_uniqueStorage()._compiler = newValue}
  }
  /// Returns true if `compiler` has been explicitly set.
  public var hasCompiler: Bool {return _storage._compiler != nil}
  /// Clears the value of `compiler`. Subsequent reads from it will return its default value.
  public mutating func clearCompiler() {_uniqueStorage()._compiler = nil}

  public var abiVersion: String {
    get {return _storage._abiVersion ?? String()}
    set {_uniqueStorage()._abiVersion = newValue}
  }
  /// Returns true if `abiVersion` has been explicitly set.
  public var hasAbiVersion: Bool {return _storage._abiVersion != nil}
  /// Clears the value of `abiVersion`. Subsequent reads from it will return its default value.
  public mutating func clearAbiVersion() {_uniqueStorage()._abiVersion = nil}

  public var abiLibcVersion: String {
    get {return _storage._abiLibcVersion ?? String()}
    set {_uniqueStorage()._abiLibcVersion = newValue}
  }
  /// Returns true if `abiLibcVersion` has been explicitly set.
  public var hasAbiLibcVersion: Bool {return _storage._abiLibcVersion != nil}
  /// Clears the value of `abiLibcVersion`. Subsequent reads from it will return its default value.
  public mutating func clearAbiLibcVersion() {_uniqueStorage()._abiLibcVersion = nil}

  /// Tool locations. Relative paths are resolved relative to the configuration
  /// file directory.
  /// NOTE: DEPRECATED. Prefer specifying an ActionConfig for the action that
  /// needs the tool.
  /// TODO(b/27903698) migrate to ActionConfig.
  public var toolPath: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath] {
    get {return _storage._toolPath}
    set {_uniqueStorage()._toolPath = newValue}
  }

  /// Feature flags.
  /// TODO(bazel-team): Sink those into 'Feature' instances.
  /// Legacy field, ignored by Bazel.
  public var supportsGoldLinker: Bool {
    get {return _storage._supportsGoldLinker ?? false}
    set {_uniqueStorage()._supportsGoldLinker = newValue}
  }
  /// Returns true if `supportsGoldLinker` has been explicitly set.
  public var hasSupportsGoldLinker: Bool {return _storage._supportsGoldLinker != nil}
  /// Clears the value of `supportsGoldLinker`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsGoldLinker() {_uniqueStorage()._supportsGoldLinker = nil}

  /// Legacy field, ignored by Bazel.
  public var supportsThinArchives: Bool {
    get {return _storage._supportsThinArchives ?? false}
    set {_uniqueStorage()._supportsThinArchives = newValue}
  }
  /// Returns true if `supportsThinArchives` has been explicitly set.
  public var hasSupportsThinArchives: Bool {return _storage._supportsThinArchives != nil}
  /// Clears the value of `supportsThinArchives`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsThinArchives() {_uniqueStorage()._supportsThinArchives = nil}

  /// Legacy field, use 'supports_start_end_lib' feature instead.
  public var supportsStartEndLib: Bool {
    get {return _storage._supportsStartEndLib ?? false}
    set {_uniqueStorage()._supportsStartEndLib = newValue}
  }
  /// Returns true if `supportsStartEndLib` has been explicitly set.
  public var hasSupportsStartEndLib: Bool {return _storage._supportsStartEndLib != nil}
  /// Clears the value of `supportsStartEndLib`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsStartEndLib() {_uniqueStorage()._supportsStartEndLib = nil}

  /// Legacy field, use 'supports_interface_shared_libraries' instead.
  public var supportsInterfaceSharedObjects: Bool {
    get {return _storage._supportsInterfaceSharedObjects ?? false}
    set {_uniqueStorage()._supportsInterfaceSharedObjects = newValue}
  }
  /// Returns true if `supportsInterfaceSharedObjects` has been explicitly set.
  public var hasSupportsInterfaceSharedObjects: Bool {return _storage._supportsInterfaceSharedObjects != nil}
  /// Clears the value of `supportsInterfaceSharedObjects`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsInterfaceSharedObjects() {_uniqueStorage()._supportsInterfaceSharedObjects = nil}

  /// Legacy field, use 'static_link_cpp_runtimes' feature instead.
  public var supportsEmbeddedRuntimes: Bool {
    get {return _storage._supportsEmbeddedRuntimes ?? false}
    set {_uniqueStorage()._supportsEmbeddedRuntimes = newValue}
  }
  /// Returns true if `supportsEmbeddedRuntimes` has been explicitly set.
  public var hasSupportsEmbeddedRuntimes: Bool {return _storage._supportsEmbeddedRuntimes != nil}
  /// Clears the value of `supportsEmbeddedRuntimes`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsEmbeddedRuntimes() {_uniqueStorage()._supportsEmbeddedRuntimes = nil}

  /// If specified, Blaze finds statically linked / dynamically linked runtime
  /// libraries in the declared crosstool filegroup. Otherwise, Blaze
  /// looks in "[static|dynamic]-runtime-libs-$TARGET_CPU".
  /// Deprecated, see https://github.com/bazelbuild/bazel/issues/6942
  public var staticRuntimesFilegroup: String {
    get {return _storage._staticRuntimesFilegroup ?? String()}
    set {_uniqueStorage()._staticRuntimesFilegroup = newValue}
  }
  /// Returns true if `staticRuntimesFilegroup` has been explicitly set.
  public var hasStaticRuntimesFilegroup: Bool {return _storage._staticRuntimesFilegroup != nil}
  /// Clears the value of `staticRuntimesFilegroup`. Subsequent reads from it will return its default value.
  public mutating func clearStaticRuntimesFilegroup() {_uniqueStorage()._staticRuntimesFilegroup = nil}

  /// Deprecated, see https://github.com/bazelbuild/bazel/issues/6942
  public var dynamicRuntimesFilegroup: String {
    get {return _storage._dynamicRuntimesFilegroup ?? String()}
    set {_uniqueStorage()._dynamicRuntimesFilegroup = newValue}
  }
  /// Returns true if `dynamicRuntimesFilegroup` has been explicitly set.
  public var hasDynamicRuntimesFilegroup: Bool {return _storage._dynamicRuntimesFilegroup != nil}
  /// Clears the value of `dynamicRuntimesFilegroup`. Subsequent reads from it will return its default value.
  public mutating func clearDynamicRuntimesFilegroup() {_uniqueStorage()._dynamicRuntimesFilegroup = nil}

  /// Legacy field, ignored by Bazel.
  public var supportsIncrementalLinker: Bool {
    get {return _storage._supportsIncrementalLinker ?? false}
    set {_uniqueStorage()._supportsIncrementalLinker = newValue}
  }
  /// Returns true if `supportsIncrementalLinker` has been explicitly set.
  public var hasSupportsIncrementalLinker: Bool {return _storage._supportsIncrementalLinker != nil}
  /// Clears the value of `supportsIncrementalLinker`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsIncrementalLinker() {_uniqueStorage()._supportsIncrementalLinker = nil}

  /// Legacy field, ignored by Bazel.
  public var supportsNormalizingAr: Bool {
    get {return _storage._supportsNormalizingAr ?? false}
    set {_uniqueStorage()._supportsNormalizingAr = newValue}
  }
  /// Returns true if `supportsNormalizingAr` has been explicitly set.
  public var hasSupportsNormalizingAr: Bool {return _storage._supportsNormalizingAr != nil}
  /// Clears the value of `supportsNormalizingAr`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsNormalizingAr() {_uniqueStorage()._supportsNormalizingAr = nil}

  /// Legacy field, use 'per_object_debug_info' feature instead.
  public var supportsFission: Bool {
    get {return _storage._supportsFission ?? false}
    set {_uniqueStorage()._supportsFission = newValue}
  }
  /// Returns true if `supportsFission` has been explicitly set.
  public var hasSupportsFission: Bool {return _storage._supportsFission != nil}
  /// Clears the value of `supportsFission`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsFission() {_uniqueStorage()._supportsFission = nil}

  /// Legacy field, ignored by Bazel.
  public var supportsDsym: Bool {
    get {return _storage._supportsDsym ?? false}
    set {_uniqueStorage()._supportsDsym = newValue}
  }
  /// Returns true if `supportsDsym` has been explicitly set.
  public var hasSupportsDsym: Bool {return _storage._supportsDsym != nil}
  /// Clears the value of `supportsDsym`. Subsequent reads from it will return its default value.
  public mutating func clearSupportsDsym() {_uniqueStorage()._supportsDsym = nil}

  /// Legacy field, use 'supports_pic' feature instead
  public var needsPic: Bool {
    get {return _storage._needsPic ?? false}
    set {_uniqueStorage()._needsPic = newValue}
  }
  /// Returns true if `needsPic` has been explicitly set.
  public var hasNeedsPic: Bool {return _storage._needsPic != nil}
  /// Clears the value of `needsPic`. Subsequent reads from it will return its default value.
  public mutating func clearNeedsPic() {_uniqueStorage()._needsPic = nil}

  /// Compiler flags for C/C++/Asm compilation.
  public var compilerFlag: [String] {
    get {return _storage._compilerFlag}
    set {_uniqueStorage()._compilerFlag = newValue}
  }

  /// Additional compiler flags for C++ compilation.
  public var cxxFlag: [String] {
    get {return _storage._cxxFlag}
    set {_uniqueStorage()._cxxFlag = newValue}
  }

  /// Additional unfiltered compiler flags for C/C++/Asm compilation.
  /// These are not subject to nocopt filtering in cc_* rules.
  /// Note: These flags are *not* applied to objc/objc++ compiles.
  public var unfilteredCxxFlag: [String] {
    get {return _storage._unfilteredCxxFlag}
    set {_uniqueStorage()._unfilteredCxxFlag = newValue}
  }

  /// Linker flags.
  public var linkerFlag: [String] {
    get {return _storage._linkerFlag}
    set {_uniqueStorage()._linkerFlag = newValue}
  }

  /// Additional linker flags when linking dynamic libraries.
  public var dynamicLibraryLinkerFlag: [String] {
    get {return _storage._dynamicLibraryLinkerFlag}
    set {_uniqueStorage()._dynamicLibraryLinkerFlag = newValue}
  }

  /// Additional test-only linker flags.
  public var testOnlyLinkerFlag: [String] {
    get {return _storage._testOnlyLinkerFlag}
    set {_uniqueStorage()._testOnlyLinkerFlag = newValue}
  }

  /// Objcopy flags for embedding files into binaries.
  public var objcopyEmbedFlag: [String] {
    get {return _storage._objcopyEmbedFlag}
    set {_uniqueStorage()._objcopyEmbedFlag = newValue}
  }

  /// Ld flags for embedding files into binaries. This is used by filewrapper
  /// since it calls ld directly and needs to know what -m flag to pass.
  public var ldEmbedFlag: [String] {
    get {return _storage._ldEmbedFlag}
    set {_uniqueStorage()._ldEmbedFlag = newValue}
  }

  /// Ar flags for combining object files into archives. If this is not set, it
  /// defaults to "rcsD".
  /// TODO(b/37271982): Remove after blaze with ar action_config release
  public var arFlag: [String] {
    get {return _storage._arFlag}
    set {_uniqueStorage()._arFlag = newValue}
  }

  /// Legacy field, ignored by Bazel.
  public var arThinArchivesFlag: [String] {
    get {return _storage._arThinArchivesFlag}
    set {_uniqueStorage()._arThinArchivesFlag = newValue}
  }

  /// Legacy field, ignored by Bazel.
  public var gccPluginCompilerFlag: [String] {
    get {return _storage._gccPluginCompilerFlag}
    set {_uniqueStorage()._gccPluginCompilerFlag = newValue}
  }

  /// Additional compiler and linker flags depending on the compilation mode.
  public var compilationModeFlags: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags] {
    get {return _storage._compilationModeFlags}
    set {_uniqueStorage()._compilationModeFlags = newValue}
  }

  /// Additional linker flags depending on the linking mode.
  public var linkingModeFlags: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags] {
    get {return _storage._linkingModeFlags}
    set {_uniqueStorage()._linkingModeFlags = newValue}
  }

  /// Legacy field, ignored by Bazel.
  public var gccPluginHeaderDirectory: [String] {
    get {return _storage._gccPluginHeaderDirectory}
    set {_uniqueStorage()._gccPluginHeaderDirectory = newValue}
  }

  /// Legacy field, ignored by Bazel.
  public var maoPluginHeaderDirectory: [String] {
    get {return _storage._maoPluginHeaderDirectory}
    set {_uniqueStorage()._maoPluginHeaderDirectory = newValue}
  }

  /// Make variables that are made accessible to rules.
  public var makeVariable: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable] {
    get {return _storage._makeVariable}
    set {_uniqueStorage()._makeVariable = newValue}
  }

  /// Built-in include directories for C++ compilation. These should be the exact
  /// paths used by the compiler, and are generally relative to the exec root.
  /// The paths used by the compiler can be determined by 'gcc -Wp,-v some.c'.
  /// We currently use the C++ paths also for C compilation, which is safe as
  /// long as there are no name clashes between C++ and C header files.
  ///
  /// Relative paths are resolved relative to the configuration file directory.
  ///
  /// If the compiler has --sysroot support, then these paths should use
  /// %sysroot% rather than the include path, and specify the sysroot attribute
  /// in order to give blaze the information necessary to make the correct
  /// replacements.
  public var cxxBuiltinIncludeDirectory: [String] {
    get {return _storage._cxxBuiltinIncludeDirectory}
    set {_uniqueStorage()._cxxBuiltinIncludeDirectory = newValue}
  }

  /// The built-in sysroot. If this attribute is not present, blaze does not
  /// allow using a different sysroot, i.e. through the --grte_top option. Also
  /// see the documentation above.
  public var builtinSysroot: String {
    get {return _storage._builtinSysroot ?? String()}
    set {_uniqueStorage()._builtinSysroot = newValue}
  }
  /// Returns true if `builtinSysroot` has been explicitly set.
  public var hasBuiltinSysroot: Bool {return _storage._builtinSysroot != nil}
  /// Clears the value of `builtinSysroot`. Subsequent reads from it will return its default value.
  public mutating func clearBuiltinSysroot() {_uniqueStorage()._builtinSysroot = nil}

  /// Legacy field, ignored by Bazel.
  public var defaultPythonTop: String {
    get {return _storage._defaultPythonTop ?? String()}
    set {_uniqueStorage()._defaultPythonTop = newValue}
  }
  /// Returns true if `defaultPythonTop` has been explicitly set.
  public var hasDefaultPythonTop: Bool {return _storage._defaultPythonTop != nil}
  /// Clears the value of `defaultPythonTop`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultPythonTop() {_uniqueStorage()._defaultPythonTop = nil}

  /// Legacy field, ignored by Bazel.
  public var defaultPythonVersion: String {
    get {return _storage._defaultPythonVersion ?? String()}
    set {_uniqueStorage()._defaultPythonVersion = newValue}
  }
  /// Returns true if `defaultPythonVersion` has been explicitly set.
  public var hasDefaultPythonVersion: Bool {return _storage._defaultPythonVersion != nil}
  /// Clears the value of `defaultPythonVersion`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultPythonVersion() {_uniqueStorage()._defaultPythonVersion = nil}

  /// Legacy field, ignored by Bazel.
  public var pythonPreloadSwigdeps: Bool {
    get {return _storage._pythonPreloadSwigdeps ?? false}
    set {_uniqueStorage()._pythonPreloadSwigdeps = newValue}
  }
  /// Returns true if `pythonPreloadSwigdeps` has been explicitly set.
  public var hasPythonPreloadSwigdeps: Bool {return _storage._pythonPreloadSwigdeps != nil}
  /// Clears the value of `pythonPreloadSwigdeps`. Subsequent reads from it will return its default value.
  public mutating func clearPythonPreloadSwigdeps() {_uniqueStorage()._pythonPreloadSwigdeps = nil}

  /// The default GRTE to use. This should be a label, and gets the same
  /// treatment from Blaze as the --grte_top option. This setting is only used in
  /// the absence of an explicit --grte_top option. If unset, Blaze will not pass
  /// -sysroot by default. The local part must be 'everything', i.e.,
  /// '//some/label:everything'. There can only be one GRTE library per package,
  /// because the compiler expects the directory as a parameter of the -sysroot
  /// option.
  /// This may only be set to a non-empty value if builtin_sysroot is also set!
  public var defaultGrteTop: String {
    get {return _storage._defaultGrteTop ?? String()}
    set {_uniqueStorage()._defaultGrteTop = newValue}
  }
  /// Returns true if `defaultGrteTop` has been explicitly set.
  public var hasDefaultGrteTop: Bool {return _storage._defaultGrteTop != nil}
  /// Clears the value of `defaultGrteTop`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultGrteTop() {_uniqueStorage()._defaultGrteTop = nil}

  /// Legacy field, ignored by Bazel.
  public var debianExtraRequires: [String] {
    get {return _storage._debianExtraRequires}
    set {_uniqueStorage()._debianExtraRequires = newValue}
  }

  /// Legacy field, ignored by Bazel. Only there for compatibility with
  /// things internal to Google.
  public var ccTargetOs: String {
    get {return _storage._ccTargetOs ?? String()}
    set {_uniqueStorage()._ccTargetOs = newValue}
  }
  /// Returns true if `ccTargetOs` has been explicitly set.
  public var hasCcTargetOs: Bool {return _storage._ccTargetOs != nil}
  /// Clears the value of `ccTargetOs`. Subsequent reads from it will return its default value.
  public mutating func clearCcTargetOs() {_uniqueStorage()._ccTargetOs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A group of correlated flags. Supports parametrization via variable
  /// expansion.
  ///
  /// To expand a variable of list type, flag_group has to be annotated with
  /// `iterate_over` message. Then all nested flags or flag_groups will be
  /// expanded repeatedly for each element of the list.
  ///
  /// For example:
  /// flag_group {
  ///   iterate_over: 'include_path'
  ///   flag: '-I'
  ///   flag: '%{include_path}'
  /// }
  /// ... will get expanded to -I /to/path1 -I /to/path2 ... for each
  /// include_path /to/pathN.
  ///
  /// To expand a variable of structure type, use dot-notation, e.g.:
  ///    flag_group {
  ///      iterate_over: "libraries_to_link"
  ///      flag_group {
  ///        iterate_over: "libraries_to_link.libraries"
  ///        flag: "-L%{libraries_to_link.libraries.directory}"
  ///      }
  ///    }
  ///
  /// Flag groups can be nested; if they are, the flag group must only contain
  /// other flag groups (no flags) so the order is unambiguously specified.
  /// In order to expand a variable of nested lists, 'iterate_over' can be used.
  ///
  /// For example:
  /// flag_group {
  ///   iterate_over: 'object_files'
  ///   flag_group { flag: '--start-lib' }
  ///   flag_group {
  ///     iterate_over: 'object_files'
  ///     flag: '%{object_files}'
  ///   }
  ///   flag_group { flag: '--end-lib' }
  /// }
  /// ... will get expanded to
  ///   --start-lib a1.o a2.o ... --end-lib --start-lib b1.o b2.o .. --end-lib
  ///   with %{object_files} being a variable of nested list type
  ///   [['a1.o', 'a2.o', ...], ['b1.o', 'b2.o', ...], ...].
  ///
  /// TODO(bazel-team): Write more elaborate documentation and add a link to it.
  public struct FlagGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var flag: [String] = []

    public var flagGroup: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagGroup] = []

    public var iterateOver: String {
      get {return _iterateOver ?? String()}
      set {_iterateOver = newValue}
    }
    /// Returns true if `iterateOver` has been explicitly set.
    public var hasIterateOver: Bool {return self._iterateOver != nil}
    /// Clears the value of `iterateOver`. Subsequent reads from it will return its default value.
    public mutating func clearIterateOver() {self._iterateOver = nil}

    public var expandIfAllAvailable: [String] = []

    public var expandIfNoneAvailable: [String] = []

    public var expandIfTrue: String {
      get {return _expandIfTrue ?? String()}
      set {_expandIfTrue = newValue}
    }
    /// Returns true if `expandIfTrue` has been explicitly set.
    public var hasExpandIfTrue: Bool {return self._expandIfTrue != nil}
    /// Clears the value of `expandIfTrue`. Subsequent reads from it will return its default value.
    public mutating func clearExpandIfTrue() {self._expandIfTrue = nil}

    public var expandIfFalse: String {
      get {return _expandIfFalse ?? String()}
      set {_expandIfFalse = newValue}
    }
    /// Returns true if `expandIfFalse` has been explicitly set.
    public var hasExpandIfFalse: Bool {return self._expandIfFalse != nil}
    /// Clears the value of `expandIfFalse`. Subsequent reads from it will return its default value.
    public mutating func clearExpandIfFalse() {self._expandIfFalse = nil}

    public var expandIfEqual: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue {
      get {return _expandIfEqual ?? Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue()}
      set {_expandIfEqual = newValue}
    }
    /// Returns true if `expandIfEqual` has been explicitly set.
    public var hasExpandIfEqual: Bool {return self._expandIfEqual != nil}
    /// Clears the value of `expandIfEqual`. Subsequent reads from it will return its default value.
    public mutating func clearExpandIfEqual() {self._expandIfEqual = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _iterateOver: String? = nil
    fileprivate var _expandIfTrue: String? = nil
    fileprivate var _expandIfFalse: String? = nil
    fileprivate var _expandIfEqual: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue? = nil
  }

  public struct VariableWithValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var variable: String {
      get {return _variable ?? String()}
      set {_variable = newValue}
    }
    /// Returns true if `variable` has been explicitly set.
    public var hasVariable: Bool {return self._variable != nil}
    /// Clears the value of `variable`. Subsequent reads from it will return its default value.
    public mutating func clearVariable() {self._variable = nil}

    public var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _variable: String? = nil
    fileprivate var _value: String? = nil
  }

  /// A key/value pair to be added as an environment variable. The value of
  /// this pair is expanded in the same way as is described in FlagGroup.
  /// The key remains an unexpanded string literal.
  public struct EnvEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {self._key = nil}

    public var value: String {
      get {return _value ?? String()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _key: String? = nil
    fileprivate var _value: String? = nil
  }

  /// A set of features; used to support logical 'and' when specifying feature
  /// requirements in Feature.
  public struct FeatureSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var feature: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A set of positive and negative features. This stanza will
  /// evaluate to true when every 'feature' is enabled, and every
  /// 'not_feature' is not enabled.
  public struct WithFeatureSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var feature: [String] = []

    public var notFeature: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A set of flags that are expanded in the command line for specific actions.
  public struct FlagSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The actions this flag set applies to; each flag set must specify at
    /// least one action.
    public var action: [String] = []

    /// The flags applied via this flag set.
    public var flagGroup: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagGroup] = []

    /// A list of feature sets defining when this flag set gets applied.  The
    /// flag set will be applied when any one of the feature sets evaluate to
    /// true. (That is, when when every 'feature' is enabled, and every
    /// 'not_feature' is not enabled.)
    ///
    /// If 'with_feature' is omitted, the flag set will be applied
    /// unconditionally for every action specified.
    public var withFeature: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet] = []

    /// Deprecated (https://github.com/bazelbuild/bazel/issues/7008) - use
    /// expand_if_all_available in flag_group
    ///
    /// A list of build variables that this feature set needs, but which are
    /// allowed to not be set. If any of the build variables listed is not
    /// set, the feature set will not be expanded.
    ///
    /// NOTE: Consider alternatives before using this; usually tools should
    /// consistently create the same set of files, even if empty; use this
    /// only for backwards compatibility with already existing behavior in tools
    /// that are currently not worth changing.
    public var expandIfAllAvailable: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A set of environment variables that are expanded in the command line for
  /// specific actions.
  public struct EnvSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The actions this env set applies to; each env set must specify at
    /// least one action.
    public var action: [String] = []

    /// The environment variables applied via this env set.
    public var envEntry: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvEntry] = []

    /// A list of feature sets defining when this env set gets applied.  The
    /// env set will be applied when any one of the feature sets evaluate to
    /// true. (That is, when when every 'feature' is enabled, and every
    /// 'not_feature' is not enabled.)
    ///
    /// If 'with_feature' is omitted, the env set will be applied
    /// unconditionally for every action specified.
    public var withFeature: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Contains all flag specifications for one feature.
  /// Next ID: 8
  public struct Feature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The feature's name. Feature names are generally defined by Bazel; it is
    /// possible to introduce a feature without a change to Bazel by adding a
    /// 'feature' section to the toolchain and adding the corresponding string as
    /// feature in the BUILD file.
    public var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    public var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    public mutating func clearName() {self._name = nil}

    /// If 'true', this feature is enabled unless a rule type explicitly marks it
    /// as unsupported. Such features cannot be turned off from within a BUILD
    /// file or the command line.
    public var enabled: Bool {
      get {return _enabled ?? false}
      set {_enabled = newValue}
    }
    /// Returns true if `enabled` has been explicitly set.
    public var hasEnabled: Bool {return self._enabled != nil}
    /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
    public mutating func clearEnabled() {self._enabled = nil}

    /// If the given feature is enabled, the flag sets will be applied for the
    /// actions in the modes that they are specified for.
    public var flagSet: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagSet] = []

    /// If the given feature is enabled, the env sets will be applied for the
    /// actions in the modes that they are specified for.
    public var envSet: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvSet] = []

    /// A list of feature sets defining when this feature is supported by the
    /// toolchain. The feature is supported if any of the feature sets fully
    /// apply, that is, when all features of a feature set are enabled.
    ///
    /// If 'requires' is omitted, the feature is supported independently of which
    /// other features are enabled.
    ///
    /// Use this for example to filter flags depending on the build mode
    /// enabled (opt / fastbuild / dbg).
    public var requires: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FeatureSet] = []

    /// A list of features or action configs that are automatically enabled when
    /// this feature is enabled. If any of the implied features or action configs
    /// cannot be enabled, this feature will (silently) not be enabled either.
    public var implies: [String] = []

    /// A list of names this feature conflicts with.
    /// A feature cannot be enabled if:
    /// - 'provides' contains the name of a different feature or action config
    ///  that we want to enable.
    /// - 'provides' contains the same value as a 'provides' in a different
    ///   feature or action config that we want to enable.
    ///
    /// Use this in order to ensure that incompatible features cannot be
    /// accidentally activated at the same time, leading to hard to diagnose
    /// compiler errors.
    public var provides: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _name: String? = nil
    fileprivate var _enabled: Bool? = nil
  }

  /// Describes a tool associated with a crosstool action config.
  public struct Tool {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Path to the tool, relative to the location of the crosstool.
    public var toolPath: String {
      get {return _toolPath ?? String()}
      set {_toolPath = newValue}
    }
    /// Returns true if `toolPath` has been explicitly set.
    public var hasToolPath: Bool {return self._toolPath != nil}
    /// Clears the value of `toolPath`. Subsequent reads from it will return its default value.
    public mutating func clearToolPath() {self._toolPath = nil}

    /// Origin of `tool_path`.
    /// Optional only for legacy reasons. New crosstools should set this value!
    public var toolPathOrigin: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool.PathOrigin {
      get {return _toolPathOrigin ?? .crosstoolPackage}
      set {_toolPathOrigin = newValue}
    }
    /// Returns true if `toolPathOrigin` has been explicitly set.
    public var hasToolPathOrigin: Bool {return self._toolPathOrigin != nil}
    /// Clears the value of `toolPathOrigin`. Subsequent reads from it will return its default value.
    public mutating func clearToolPathOrigin() {self._toolPathOrigin = nil}

    /// A list of feature sets defining when this tool is applicable.  The tool
    /// will used when any one of the feature sets evaluate to true. (That is,
    /// when when every 'feature' is enabled, and every 'not_feature' is not
    /// enabled.)
    ///
    /// If 'with_feature' is omitted, the tool will apply for any feature
    /// configuration.
    public var withFeature: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet] = []

    /// Requirements on the execution environment for the execution of this tool,
    /// to be passed as out-of-band "hints" to the execution backend.
    /// Ex. "requires-darwin"
    public var executionRequirement: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Describes the origin of a path.
    public enum PathOrigin: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Indicates that `tool_path` is relative to the location of the
      /// crosstool. For legacy reasons, absolute paths are als0 allowed here.
      case crosstoolPackage // = 0

      /// Indicates that `tool_path` is an absolute path.
      /// This is enforced by Bazel.
      case filesystemRoot // = 1

      /// Indicates that `tool_path` is relative to the current workspace's
      /// exec root.
      case workspaceRoot // = 2

      public init() {
        self = .crosstoolPackage
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .crosstoolPackage
        case 1: self = .filesystemRoot
        case 2: self = .workspaceRoot
        default: return nil
        }
      }

      public var rawValue: Int {
        switch self {
        case .crosstoolPackage: return 0
        case .filesystemRoot: return 1
        case .workspaceRoot: return 2
        }
      }

    }

    public init() {}

    fileprivate var _toolPath: String? = nil
    fileprivate var _toolPathOrigin: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool.PathOrigin? = nil
  }

  /// The name for an artifact of a given category of input or output artifacts
  /// to an action.
  public struct ArtifactNamePattern {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The category of artifacts that this selection applies to.  This field
    /// is compared against a list of categories defined in bazel. Example
    /// categories include "linked_output" or "debug_symbols". An error is thrown
    /// if no category is matched.
    public var categoryName: String {
      get {return _categoryName ?? String()}
      set {_categoryName = newValue}
    }
    /// Returns true if `categoryName` has been explicitly set.
    public var hasCategoryName: Bool {return self._categoryName != nil}
    /// Clears the value of `categoryName`. Subsequent reads from it will return its default value.
    public mutating func clearCategoryName() {self._categoryName = nil}

    /// The prefix and extension for creating the artifact for this selection.
    /// They are used to create an artifact name based on the target name.
    public var prefix: String {
      get {return _prefix ?? String()}
      set {_prefix = newValue}
    }
    /// Returns true if `prefix` has been explicitly set.
    public var hasPrefix: Bool {return self._prefix != nil}
    /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
    public mutating func clearPrefix() {self._prefix = nil}

    public var `extension`: String {
      get {return _extension ?? String()}
      set {_extension = newValue}
    }
    /// Returns true if ``extension`` has been explicitly set.
    public var hasExtension: Bool {return self._extension != nil}
    /// Clears the value of ``extension``. Subsequent reads from it will return its default value.
    public mutating func clearExtension() {self._extension = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _categoryName: String? = nil
    fileprivate var _prefix: String? = nil
    fileprivate var _extension: String? = nil
  }

  /// An action config corresponds to a blaze action, and allows selection of
  /// a tool based on activated features.  Action configs come in two varieties:
  /// automatic (the blaze action will exist whether or not the action config
  /// is activated) and attachable (the blaze action will be added to the
  /// action graph only if the action config is activated).
  ///
  /// Action config activation occurs by the same semantics as features: a
  /// feature can 'require' or 'imply' an action config in the same way that it
  /// would another feature.
  /// Next ID: 9
  public struct ActionConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name other features will use to activate this action config.  Can
    /// be the same as action_name.
    public var configName: String {
      get {return _configName ?? String()}
      set {_configName = newValue}
    }
    /// Returns true if `configName` has been explicitly set.
    public var hasConfigName: Bool {return self._configName != nil}
    /// Clears the value of `configName`. Subsequent reads from it will return its default value.
    public mutating func clearConfigName() {self._configName = nil}

    /// The name of the blaze action that this config applies to, ex. 'c-compile'
    /// or 'c-module-compile'.
    public var actionName: String {
      get {return _actionName ?? String()}
      set {_actionName = newValue}
    }
    /// Returns true if `actionName` has been explicitly set.
    public var hasActionName: Bool {return self._actionName != nil}
    /// Clears the value of `actionName`. Subsequent reads from it will return its default value.
    public mutating func clearActionName() {self._actionName = nil}

    /// If 'true', this feature is enabled unless a rule type explicitly marks it
    /// as unsupported.  Such action_configs cannot be turned off from within a
    /// BUILD file or the command line.
    public var enabled: Bool {
      get {return _enabled ?? false}
      set {_enabled = newValue}
    }
    /// Returns true if `enabled` has been explicitly set.
    public var hasEnabled: Bool {return self._enabled != nil}
    /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
    public mutating func clearEnabled() {self._enabled = nil}

    /// The tool applied to the action will be the first Tool with a feature
    /// set that matches the feature configuration.  An error will be thrown
    /// if no tool matches a provided feature configuration - for that reason,
    /// it's a good idea to provide a default tool with an empty feature set.
    public var tool: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool] = []

    /// If the given action config is enabled, the flag sets will be applied
    /// to the corresponding action.
    public var flagSet: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagSet] = []

    /// If the given action config is enabled, the env sets will be applied
    /// to the corresponding action.
    public var envSet: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvSet] = []

    /// A list of feature sets defining when this action config
    /// is supported by the toolchain. The action config is supported if any of
    /// the feature sets fully apply, that is, when all features of a
    /// feature set are enabled.
    ///
    /// If 'requires' is omitted, the action config is supported independently
    /// of which other features are enabled.
    ///
    /// Use this for example to filter actions depending on the build
    /// mode enabled (opt / fastbuild / dbg).
    public var requires: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FeatureSet] = []

    /// A list of features or action configs that are automatically enabled when
    /// this action config is enabled. If any of the implied features or action
    /// configs cannot be enabled, this action config will (silently)
    /// not be enabled either.
    public var implies: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configName: String? = nil
    fileprivate var _actionName: String? = nil
    fileprivate var _enabled: Bool? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool.PathOrigin: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  public var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  public mutating func clearPath() {self._path = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _path: String? = nil
}

public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationMode {
    get {return _mode ?? .fastbuild}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  public var compilerFlag: [String] = []

  public var cxxFlag: [String] = []

  /// Linker flags that are added when compiling in a certain mode.
  public var linkerFlag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mode: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationMode? = nil
}

public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingMode {
    get {return _mode ?? .fullyStatic}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  public var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  public mutating func clearMode() {self._mode = nil}

  public var linkerFlag: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mode: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingMode? = nil
}

public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _value: String? = nil
}

public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_DefaultCpuToolchain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cpu: String {
    get {return _cpu ?? String()}
    set {_cpu = newValue}
  }
  /// Returns true if `cpu` has been explicitly set.
  public var hasCpu: Bool {return self._cpu != nil}
  /// Clears the value of `cpu`. Subsequent reads from it will return its default value.
  public mutating func clearCpu() {self._cpu = nil}

  public var toolchainIdentifier: String {
    get {return _toolchainIdentifier ?? String()}
    set {_toolchainIdentifier = newValue}
  }
  /// Returns true if `toolchainIdentifier` has been explicitly set.
  public var hasToolchainIdentifier: Bool {return self._toolchainIdentifier != nil}
  /// Clears the value of `toolchainIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearToolchainIdentifier() {self._toolchainIdentifier = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cpu: String? = nil
  fileprivate var _toolchainIdentifier: String? = nil
}

/// An entire crosstool release, containing the version number, and a set of
/// toolchains.
public struct Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CrosstoolRelease {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The major and minor version of the crosstool release.
  public var majorVersion: String {
    get {return _majorVersion ?? String()}
    set {_majorVersion = newValue}
  }
  /// Returns true if `majorVersion` has been explicitly set.
  public var hasMajorVersion: Bool {return self._majorVersion != nil}
  /// Clears the value of `majorVersion`. Subsequent reads from it will return its default value.
  public mutating func clearMajorVersion() {self._majorVersion = nil}

  public var minorVersion: String {
    get {return _minorVersion ?? String()}
    set {_minorVersion = newValue}
  }
  /// Returns true if `minorVersion` has been explicitly set.
  public var hasMinorVersion: Bool {return self._minorVersion != nil}
  /// Clears the value of `minorVersion`. Subsequent reads from it will return its default value.
  public mutating func clearMinorVersion() {self._minorVersion = nil}

  /// Legacy field, ignored by Bazel.
  public var defaultTargetCpu: String {
    get {return _defaultTargetCpu ?? String()}
    set {_defaultTargetCpu = newValue}
  }
  /// Returns true if `defaultTargetCpu` has been explicitly set.
  public var hasDefaultTargetCpu: Bool {return self._defaultTargetCpu != nil}
  /// Clears the value of `defaultTargetCpu`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultTargetCpu() {self._defaultTargetCpu = nil}

  /// Legacy field, ignored by Bazel.
  public var defaultToolchain: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_DefaultCpuToolchain] = []

  /// All the toolchains in this release.
  public var toolchain: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _majorVersion: String? = nil
  fileprivate var _minorVersion: String? = nil
  fileprivate var _defaultTargetCpu: String? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationMode: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingMode: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagGroup: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvEntry: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FeatureSet: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagSet: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvSet: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Feature: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool.PathOrigin: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ArtifactNamePattern: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ActionConfig: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_DefaultCpuToolchain: @unchecked Sendable {}
extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CrosstoolRelease: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "com.google.devtools.build.lib.view.config.crosstool"

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FASTBUILD"),
    2: .same(proto: "DBG"),
    3: .same(proto: "OPT"),
    4: .same(proto: "COVERAGE"),
  ]
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "FULLY_STATIC"),
    2: .same(proto: "MOSTLY_STATIC"),
    3: .same(proto: "DYNAMIC"),
    4: .same(proto: "MOSTLY_STATIC_LIBRARIES"),
  ]
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CToolchain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    50: .same(proto: "feature"),
    53: .standard(proto: "action_config"),
    54: .standard(proto: "artifact_name_pattern"),
    1: .standard(proto: "toolchain_identifier"),
    2: .standard(proto: "host_system_name"),
    3: .standard(proto: "target_system_name"),
    4: .standard(proto: "target_cpu"),
    5: .standard(proto: "target_libc"),
    6: .same(proto: "compiler"),
    7: .standard(proto: "abi_version"),
    8: .standard(proto: "abi_libc_version"),
    9: .standard(proto: "tool_path"),
    10: .standard(proto: "supports_gold_linker"),
    11: .standard(proto: "supports_thin_archives"),
    28: .standard(proto: "supports_start_end_lib"),
    32: .standard(proto: "supports_interface_shared_objects"),
    40: .standard(proto: "supports_embedded_runtimes"),
    45: .standard(proto: "static_runtimes_filegroup"),
    46: .standard(proto: "dynamic_runtimes_filegroup"),
    41: .standard(proto: "supports_incremental_linker"),
    26: .standard(proto: "supports_normalizing_ar"),
    43: .standard(proto: "supports_fission"),
    51: .standard(proto: "supports_dsym"),
    12: .same(proto: "needsPic"),
    13: .standard(proto: "compiler_flag"),
    14: .standard(proto: "cxx_flag"),
    25: .standard(proto: "unfiltered_cxx_flag"),
    15: .standard(proto: "linker_flag"),
    27: .standard(proto: "dynamic_library_linker_flag"),
    49: .standard(proto: "test_only_linker_flag"),
    16: .standard(proto: "objcopy_embed_flag"),
    23: .standard(proto: "ld_embed_flag"),
    47: .standard(proto: "ar_flag"),
    48: .standard(proto: "ar_thin_archives_flag"),
    34: .standard(proto: "gcc_plugin_compiler_flag"),
    17: .standard(proto: "compilation_mode_flags"),
    18: .standard(proto: "linking_mode_flags"),
    19: .standard(proto: "gcc_plugin_header_directory"),
    20: .standard(proto: "mao_plugin_header_directory"),
    21: .standard(proto: "make_variable"),
    22: .standard(proto: "cxx_builtin_include_directory"),
    24: .standard(proto: "builtin_sysroot"),
    29: .standard(proto: "default_python_top"),
    30: .standard(proto: "default_python_version"),
    42: .standard(proto: "python_preload_swigdeps"),
    31: .standard(proto: "default_grte_top"),
    33: .standard(proto: "debian_extra_requires"),
    55: .standard(proto: "cc_target_os"),
  ]

  fileprivate class _StorageClass {
    var _feature: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Feature] = []
    var _actionConfig: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ActionConfig] = []
    var _artifactNamePattern: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ArtifactNamePattern] = []
    var _toolchainIdentifier: String? = nil
    var _hostSystemName: String? = nil
    var _targetSystemName: String? = nil
    var _targetCpu: String? = nil
    var _targetLibc: String? = nil
    var _compiler: String? = nil
    var _abiVersion: String? = nil
    var _abiLibcVersion: String? = nil
    var _toolPath: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath] = []
    var _supportsGoldLinker: Bool? = nil
    var _supportsThinArchives: Bool? = nil
    var _supportsStartEndLib: Bool? = nil
    var _supportsInterfaceSharedObjects: Bool? = nil
    var _supportsEmbeddedRuntimes: Bool? = nil
    var _staticRuntimesFilegroup: String? = nil
    var _dynamicRuntimesFilegroup: String? = nil
    var _supportsIncrementalLinker: Bool? = nil
    var _supportsNormalizingAr: Bool? = nil
    var _supportsFission: Bool? = nil
    var _supportsDsym: Bool? = nil
    var _needsPic: Bool? = nil
    var _compilerFlag: [String] = []
    var _cxxFlag: [String] = []
    var _unfilteredCxxFlag: [String] = []
    var _linkerFlag: [String] = []
    var _dynamicLibraryLinkerFlag: [String] = []
    var _testOnlyLinkerFlag: [String] = []
    var _objcopyEmbedFlag: [String] = []
    var _ldEmbedFlag: [String] = []
    var _arFlag: [String] = []
    var _arThinArchivesFlag: [String] = []
    var _gccPluginCompilerFlag: [String] = []
    var _compilationModeFlags: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags] = []
    var _linkingModeFlags: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags] = []
    var _gccPluginHeaderDirectory: [String] = []
    var _maoPluginHeaderDirectory: [String] = []
    var _makeVariable: [Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable] = []
    var _cxxBuiltinIncludeDirectory: [String] = []
    var _builtinSysroot: String? = nil
    var _defaultPythonTop: String? = nil
    var _defaultPythonVersion: String? = nil
    var _pythonPreloadSwigdeps: Bool? = nil
    var _defaultGrteTop: String? = nil
    var _debianExtraRequires: [String] = []
    var _ccTargetOs: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _feature = source._feature
      _actionConfig = source._actionConfig
      _artifactNamePattern = source._artifactNamePattern
      _toolchainIdentifier = source._toolchainIdentifier
      _hostSystemName = source._hostSystemName
      _targetSystemName = source._targetSystemName
      _targetCpu = source._targetCpu
      _targetLibc = source._targetLibc
      _compiler = source._compiler
      _abiVersion = source._abiVersion
      _abiLibcVersion = source._abiLibcVersion
      _toolPath = source._toolPath
      _supportsGoldLinker = source._supportsGoldLinker
      _supportsThinArchives = source._supportsThinArchives
      _supportsStartEndLib = source._supportsStartEndLib
      _supportsInterfaceSharedObjects = source._supportsInterfaceSharedObjects
      _supportsEmbeddedRuntimes = source._supportsEmbeddedRuntimes
      _staticRuntimesFilegroup = source._staticRuntimesFilegroup
      _dynamicRuntimesFilegroup = source._dynamicRuntimesFilegroup
      _supportsIncrementalLinker = source._supportsIncrementalLinker
      _supportsNormalizingAr = source._supportsNormalizingAr
      _supportsFission = source._supportsFission
      _supportsDsym = source._supportsDsym
      _needsPic = source._needsPic
      _compilerFlag = source._compilerFlag
      _cxxFlag = source._cxxFlag
      _unfilteredCxxFlag = source._unfilteredCxxFlag
      _linkerFlag = source._linkerFlag
      _dynamicLibraryLinkerFlag = source._dynamicLibraryLinkerFlag
      _testOnlyLinkerFlag = source._testOnlyLinkerFlag
      _objcopyEmbedFlag = source._objcopyEmbedFlag
      _ldEmbedFlag = source._ldEmbedFlag
      _arFlag = source._arFlag
      _arThinArchivesFlag = source._arThinArchivesFlag
      _gccPluginCompilerFlag = source._gccPluginCompilerFlag
      _compilationModeFlags = source._compilationModeFlags
      _linkingModeFlags = source._linkingModeFlags
      _gccPluginHeaderDirectory = source._gccPluginHeaderDirectory
      _maoPluginHeaderDirectory = source._maoPluginHeaderDirectory
      _makeVariable = source._makeVariable
      _cxxBuiltinIncludeDirectory = source._cxxBuiltinIncludeDirectory
      _builtinSysroot = source._builtinSysroot
      _defaultPythonTop = source._defaultPythonTop
      _defaultPythonVersion = source._defaultPythonVersion
      _pythonPreloadSwigdeps = source._pythonPreloadSwigdeps
      _defaultGrteTop = source._defaultGrteTop
      _debianExtraRequires = source._debianExtraRequires
      _ccTargetOs = source._ccTargetOs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._toolchainIdentifier == nil {return false}
      if _storage._hostSystemName == nil {return false}
      if _storage._targetSystemName == nil {return false}
      if _storage._targetCpu == nil {return false}
      if _storage._targetLibc == nil {return false}
      if _storage._compiler == nil {return false}
      if _storage._abiVersion == nil {return false}
      if _storage._abiLibcVersion == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._feature) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._actionConfig) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._artifactNamePattern) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._toolPath) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._compilationModeFlags) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._linkingModeFlags) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._makeVariable) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._toolchainIdentifier) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._hostSystemName) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._targetSystemName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._targetCpu) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._targetLibc) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._compiler) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._abiVersion) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._abiLibcVersion) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._toolPath) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._supportsGoldLinker) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._supportsThinArchives) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._needsPic) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._compilerFlag) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._cxxFlag) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._linkerFlag) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._objcopyEmbedFlag) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._compilationModeFlags) }()
        case 18: try { try decoder.decodeRepeatedMessageField(value: &_storage._linkingModeFlags) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._gccPluginHeaderDirectory) }()
        case 20: try { try decoder.decodeRepeatedStringField(value: &_storage._maoPluginHeaderDirectory) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._makeVariable) }()
        case 22: try { try decoder.decodeRepeatedStringField(value: &_storage._cxxBuiltinIncludeDirectory) }()
        case 23: try { try decoder.decodeRepeatedStringField(value: &_storage._ldEmbedFlag) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._builtinSysroot) }()
        case 25: try { try decoder.decodeRepeatedStringField(value: &_storage._unfilteredCxxFlag) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._supportsNormalizingAr) }()
        case 27: try { try decoder.decodeRepeatedStringField(value: &_storage._dynamicLibraryLinkerFlag) }()
        case 28: try { try decoder.decodeSingularBoolField(value: &_storage._supportsStartEndLib) }()
        case 29: try { try decoder.decodeSingularStringField(value: &_storage._defaultPythonTop) }()
        case 30: try { try decoder.decodeSingularStringField(value: &_storage._defaultPythonVersion) }()
        case 31: try { try decoder.decodeSingularStringField(value: &_storage._defaultGrteTop) }()
        case 32: try { try decoder.decodeSingularBoolField(value: &_storage._supportsInterfaceSharedObjects) }()
        case 33: try { try decoder.decodeRepeatedStringField(value: &_storage._debianExtraRequires) }()
        case 34: try { try decoder.decodeRepeatedStringField(value: &_storage._gccPluginCompilerFlag) }()
        case 40: try { try decoder.decodeSingularBoolField(value: &_storage._supportsEmbeddedRuntimes) }()
        case 41: try { try decoder.decodeSingularBoolField(value: &_storage._supportsIncrementalLinker) }()
        case 42: try { try decoder.decodeSingularBoolField(value: &_storage._pythonPreloadSwigdeps) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._supportsFission) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._staticRuntimesFilegroup) }()
        case 46: try { try decoder.decodeSingularStringField(value: &_storage._dynamicRuntimesFilegroup) }()
        case 47: try { try decoder.decodeRepeatedStringField(value: &_storage._arFlag) }()
        case 48: try { try decoder.decodeRepeatedStringField(value: &_storage._arThinArchivesFlag) }()
        case 49: try { try decoder.decodeRepeatedStringField(value: &_storage._testOnlyLinkerFlag) }()
        case 50: try { try decoder.decodeRepeatedMessageField(value: &_storage._feature) }()
        case 51: try { try decoder.decodeSingularBoolField(value: &_storage._supportsDsym) }()
        case 53: try { try decoder.decodeRepeatedMessageField(value: &_storage._actionConfig) }()
        case 54: try { try decoder.decodeRepeatedMessageField(value: &_storage._artifactNamePattern) }()
        case 55: try { try decoder.decodeSingularStringField(value: &_storage._ccTargetOs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._toolchainIdentifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._hostSystemName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._targetSystemName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._targetCpu {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._targetLibc {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._compiler {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._abiVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._abiLibcVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      } }()
      if !_storage._toolPath.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._toolPath, fieldNumber: 9)
      }
      try { if let v = _storage._supportsGoldLinker {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._supportsThinArchives {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._needsPic {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      if !_storage._compilerFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._compilerFlag, fieldNumber: 13)
      }
      if !_storage._cxxFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cxxFlag, fieldNumber: 14)
      }
      if !_storage._linkerFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._linkerFlag, fieldNumber: 15)
      }
      if !_storage._objcopyEmbedFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._objcopyEmbedFlag, fieldNumber: 16)
      }
      if !_storage._compilationModeFlags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._compilationModeFlags, fieldNumber: 17)
      }
      if !_storage._linkingModeFlags.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._linkingModeFlags, fieldNumber: 18)
      }
      if !_storage._gccPluginHeaderDirectory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._gccPluginHeaderDirectory, fieldNumber: 19)
      }
      if !_storage._maoPluginHeaderDirectory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._maoPluginHeaderDirectory, fieldNumber: 20)
      }
      if !_storage._makeVariable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._makeVariable, fieldNumber: 21)
      }
      if !_storage._cxxBuiltinIncludeDirectory.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._cxxBuiltinIncludeDirectory, fieldNumber: 22)
      }
      if !_storage._ldEmbedFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ldEmbedFlag, fieldNumber: 23)
      }
      try { if let v = _storage._builtinSysroot {
        try visitor.visitSingularStringField(value: v, fieldNumber: 24)
      } }()
      if !_storage._unfilteredCxxFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._unfilteredCxxFlag, fieldNumber: 25)
      }
      try { if let v = _storage._supportsNormalizingAr {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 26)
      } }()
      if !_storage._dynamicLibraryLinkerFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._dynamicLibraryLinkerFlag, fieldNumber: 27)
      }
      try { if let v = _storage._supportsStartEndLib {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 28)
      } }()
      try { if let v = _storage._defaultPythonTop {
        try visitor.visitSingularStringField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._defaultPythonVersion {
        try visitor.visitSingularStringField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._defaultGrteTop {
        try visitor.visitSingularStringField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._supportsInterfaceSharedObjects {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 32)
      } }()
      if !_storage._debianExtraRequires.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._debianExtraRequires, fieldNumber: 33)
      }
      if !_storage._gccPluginCompilerFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._gccPluginCompilerFlag, fieldNumber: 34)
      }
      try { if let v = _storage._supportsEmbeddedRuntimes {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 40)
      } }()
      try { if let v = _storage._supportsIncrementalLinker {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 41)
      } }()
      try { if let v = _storage._pythonPreloadSwigdeps {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 42)
      } }()
      try { if let v = _storage._supportsFission {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 43)
      } }()
      try { if let v = _storage._staticRuntimesFilegroup {
        try visitor.visitSingularStringField(value: v, fieldNumber: 45)
      } }()
      try { if let v = _storage._dynamicRuntimesFilegroup {
        try visitor.visitSingularStringField(value: v, fieldNumber: 46)
      } }()
      if !_storage._arFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._arFlag, fieldNumber: 47)
      }
      if !_storage._arThinArchivesFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._arThinArchivesFlag, fieldNumber: 48)
      }
      if !_storage._testOnlyLinkerFlag.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._testOnlyLinkerFlag, fieldNumber: 49)
      }
      if !_storage._feature.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._feature, fieldNumber: 50)
      }
      try { if let v = _storage._supportsDsym {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 51)
      } }()
      if !_storage._actionConfig.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionConfig, fieldNumber: 53)
      }
      if !_storage._artifactNamePattern.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._artifactNamePattern, fieldNumber: 54)
      }
      try { if let v = _storage._ccTargetOs {
        try visitor.visitSingularStringField(value: v, fieldNumber: 55)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._feature != rhs_storage._feature {return false}
        if _storage._actionConfig != rhs_storage._actionConfig {return false}
        if _storage._artifactNamePattern != rhs_storage._artifactNamePattern {return false}
        if _storage._toolchainIdentifier != rhs_storage._toolchainIdentifier {return false}
        if _storage._hostSystemName != rhs_storage._hostSystemName {return false}
        if _storage._targetSystemName != rhs_storage._targetSystemName {return false}
        if _storage._targetCpu != rhs_storage._targetCpu {return false}
        if _storage._targetLibc != rhs_storage._targetLibc {return false}
        if _storage._compiler != rhs_storage._compiler {return false}
        if _storage._abiVersion != rhs_storage._abiVersion {return false}
        if _storage._abiLibcVersion != rhs_storage._abiLibcVersion {return false}
        if _storage._toolPath != rhs_storage._toolPath {return false}
        if _storage._supportsGoldLinker != rhs_storage._supportsGoldLinker {return false}
        if _storage._supportsThinArchives != rhs_storage._supportsThinArchives {return false}
        if _storage._supportsStartEndLib != rhs_storage._supportsStartEndLib {return false}
        if _storage._supportsInterfaceSharedObjects != rhs_storage._supportsInterfaceSharedObjects {return false}
        if _storage._supportsEmbeddedRuntimes != rhs_storage._supportsEmbeddedRuntimes {return false}
        if _storage._staticRuntimesFilegroup != rhs_storage._staticRuntimesFilegroup {return false}
        if _storage._dynamicRuntimesFilegroup != rhs_storage._dynamicRuntimesFilegroup {return false}
        if _storage._supportsIncrementalLinker != rhs_storage._supportsIncrementalLinker {return false}
        if _storage._supportsNormalizingAr != rhs_storage._supportsNormalizingAr {return false}
        if _storage._supportsFission != rhs_storage._supportsFission {return false}
        if _storage._supportsDsym != rhs_storage._supportsDsym {return false}
        if _storage._needsPic != rhs_storage._needsPic {return false}
        if _storage._compilerFlag != rhs_storage._compilerFlag {return false}
        if _storage._cxxFlag != rhs_storage._cxxFlag {return false}
        if _storage._unfilteredCxxFlag != rhs_storage._unfilteredCxxFlag {return false}
        if _storage._linkerFlag != rhs_storage._linkerFlag {return false}
        if _storage._dynamicLibraryLinkerFlag != rhs_storage._dynamicLibraryLinkerFlag {return false}
        if _storage._testOnlyLinkerFlag != rhs_storage._testOnlyLinkerFlag {return false}
        if _storage._objcopyEmbedFlag != rhs_storage._objcopyEmbedFlag {return false}
        if _storage._ldEmbedFlag != rhs_storage._ldEmbedFlag {return false}
        if _storage._arFlag != rhs_storage._arFlag {return false}
        if _storage._arThinArchivesFlag != rhs_storage._arThinArchivesFlag {return false}
        if _storage._gccPluginCompilerFlag != rhs_storage._gccPluginCompilerFlag {return false}
        if _storage._compilationModeFlags != rhs_storage._compilationModeFlags {return false}
        if _storage._linkingModeFlags != rhs_storage._linkingModeFlags {return false}
        if _storage._gccPluginHeaderDirectory != rhs_storage._gccPluginHeaderDirectory {return false}
        if _storage._maoPluginHeaderDirectory != rhs_storage._maoPluginHeaderDirectory {return false}
        if _storage._makeVariable != rhs_storage._makeVariable {return false}
        if _storage._cxxBuiltinIncludeDirectory != rhs_storage._cxxBuiltinIncludeDirectory {return false}
        if _storage._builtinSysroot != rhs_storage._builtinSysroot {return false}
        if _storage._defaultPythonTop != rhs_storage._defaultPythonTop {return false}
        if _storage._defaultPythonVersion != rhs_storage._defaultPythonVersion {return false}
        if _storage._pythonPreloadSwigdeps != rhs_storage._pythonPreloadSwigdeps {return false}
        if _storage._defaultGrteTop != rhs_storage._defaultGrteTop {return false}
        if _storage._debianExtraRequires != rhs_storage._debianExtraRequires {return false}
        if _storage._ccTargetOs != rhs_storage._ccTargetOs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".FlagGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flag"),
    2: .standard(proto: "flag_group"),
    3: .standard(proto: "iterate_over"),
    4: .standard(proto: "expand_if_all_available"),
    5: .standard(proto: "expand_if_none_available"),
    6: .standard(proto: "expand_if_true"),
    7: .standard(proto: "expand_if_false"),
    8: .standard(proto: "expand_if_equal"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.flagGroup) {return false}
    if let v = self._expandIfEqual, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.flag) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.flagGroup) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._iterateOver) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.expandIfAllAvailable) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.expandIfNoneAvailable) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._expandIfTrue) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._expandIfFalse) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._expandIfEqual) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.flag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.flag, fieldNumber: 1)
    }
    if !self.flagGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagGroup, fieldNumber: 2)
    }
    try { if let v = self._iterateOver {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.expandIfAllAvailable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.expandIfAllAvailable, fieldNumber: 4)
    }
    if !self.expandIfNoneAvailable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.expandIfNoneAvailable, fieldNumber: 5)
    }
    try { if let v = self._expandIfTrue {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._expandIfFalse {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._expandIfEqual {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagGroup, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagGroup) -> Bool {
    if lhs.flag != rhs.flag {return false}
    if lhs.flagGroup != rhs.flagGroup {return false}
    if lhs._iterateOver != rhs._iterateOver {return false}
    if lhs.expandIfAllAvailable != rhs.expandIfAllAvailable {return false}
    if lhs.expandIfNoneAvailable != rhs.expandIfNoneAvailable {return false}
    if lhs._expandIfTrue != rhs._expandIfTrue {return false}
    if lhs._expandIfFalse != rhs._expandIfFalse {return false}
    if lhs._expandIfEqual != rhs._expandIfEqual {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".VariableWithValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "variable"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._variable == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._variable) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._variable {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.VariableWithValue) -> Bool {
    if lhs._variable != rhs._variable {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".EnvEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvEntry, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FeatureSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".FeatureSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.feature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feature.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feature, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FeatureSet, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FeatureSet) -> Bool {
    if lhs.feature != rhs.feature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".WithFeatureSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feature"),
    2: .standard(proto: "not_feature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.feature) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.notFeature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feature.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feature, fieldNumber: 1)
    }
    if !self.notFeature.isEmpty {
      try visitor.visitRepeatedStringField(value: self.notFeature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.WithFeatureSet) -> Bool {
    if lhs.feature != rhs.feature {return false}
    if lhs.notFeature != rhs.notFeature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".FlagSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "flag_group"),
    3: .standard(proto: "with_feature"),
    4: .standard(proto: "expand_if_all_available"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.flagGroup) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.action) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.flagGroup) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.withFeature) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.expandIfAllAvailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitRepeatedStringField(value: self.action, fieldNumber: 1)
    }
    if !self.flagGroup.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagGroup, fieldNumber: 2)
    }
    if !self.withFeature.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withFeature, fieldNumber: 3)
    }
    if !self.expandIfAllAvailable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.expandIfAllAvailable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagSet, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.FlagSet) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.flagGroup != rhs.flagGroup {return false}
    if lhs.withFeature != rhs.withFeature {return false}
    if lhs.expandIfAllAvailable != rhs.expandIfAllAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".EnvSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "env_entry"),
    3: .standard(proto: "with_feature"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.envEntry) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.action) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.envEntry) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.withFeature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitRepeatedStringField(value: self.action, fieldNumber: 1)
    }
    if !self.envEntry.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.envEntry, fieldNumber: 2)
    }
    if !self.withFeature.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withFeature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvSet, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.EnvSet) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.envEntry != rhs.envEntry {return false}
    if lhs.withFeature != rhs.withFeature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Feature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".Feature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    7: .same(proto: "enabled"),
    2: .standard(proto: "flag_set"),
    6: .standard(proto: "env_set"),
    3: .same(proto: "requires"),
    4: .same(proto: "implies"),
    5: .same(proto: "provides"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.flagSet) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.envSet) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.flagSet) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.requires) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.implies) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.provides) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.envSet) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.flagSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagSet, fieldNumber: 2)
    }
    if !self.requires.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requires, fieldNumber: 3)
    }
    if !self.implies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.implies, fieldNumber: 4)
    }
    if !self.provides.isEmpty {
      try visitor.visitRepeatedStringField(value: self.provides, fieldNumber: 5)
    }
    if !self.envSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.envSet, fieldNumber: 6)
    }
    try { if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Feature, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Feature) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.flagSet != rhs.flagSet {return false}
    if lhs.envSet != rhs.envSet {return false}
    if lhs.requires != rhs.requires {return false}
    if lhs.implies != rhs.implies {return false}
    if lhs.provides != rhs.provides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".Tool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tool_path"),
    4: .standard(proto: "tool_path_origin"),
    2: .standard(proto: "with_feature"),
    3: .standard(proto: "execution_requirement"),
  ]

  public var isInitialized: Bool {
    if self._toolPath == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._toolPath) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.withFeature) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.executionRequirement) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._toolPathOrigin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._toolPath {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.withFeature.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.withFeature, fieldNumber: 2)
    }
    if !self.executionRequirement.isEmpty {
      try visitor.visitRepeatedStringField(value: self.executionRequirement, fieldNumber: 3)
    }
    try { if let v = self._toolPathOrigin {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool) -> Bool {
    if lhs._toolPath != rhs._toolPath {return false}
    if lhs._toolPathOrigin != rhs._toolPathOrigin {return false}
    if lhs.withFeature != rhs.withFeature {return false}
    if lhs.executionRequirement != rhs.executionRequirement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.Tool.PathOrigin: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CROSSTOOL_PACKAGE"),
    1: .same(proto: "FILESYSTEM_ROOT"),
    2: .same(proto: "WORKSPACE_ROOT"),
  ]
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ArtifactNamePattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".ArtifactNamePattern"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "category_name"),
    2: .same(proto: "prefix"),
    3: .same(proto: "extension"),
  ]

  public var isInitialized: Bool {
    if self._categoryName == nil {return false}
    if self._prefix == nil {return false}
    if self._extension == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._categoryName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._extension) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._categoryName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._extension {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ArtifactNamePattern, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ArtifactNamePattern) -> Bool {
    if lhs._categoryName != rhs._categoryName {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._extension != rhs._extension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ActionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.protoMessageName + ".ActionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_name"),
    2: .standard(proto: "action_name"),
    8: .same(proto: "enabled"),
    3: .same(proto: "tool"),
    4: .standard(proto: "flag_set"),
    5: .standard(proto: "env_set"),
    6: .same(proto: "requires"),
    7: .same(proto: "implies"),
  ]

  public var isInitialized: Bool {
    if self._configName == nil {return false}
    if self._actionName == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.tool) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.flagSet) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.envSet) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._configName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._actionName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.tool) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.flagSet) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.envSet) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.requires) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.implies) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._configName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actionName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.tool.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tool, fieldNumber: 3)
    }
    if !self.flagSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagSet, fieldNumber: 4)
    }
    if !self.envSet.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.envSet, fieldNumber: 5)
    }
    if !self.requires.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requires, fieldNumber: 6)
    }
    if !self.implies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.implies, fieldNumber: 7)
    }
    try { if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ActionConfig, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CToolchain.ActionConfig) -> Bool {
    if lhs._configName != rhs._configName {return false}
    if lhs._actionName != rhs._actionName {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.tool != rhs.tool {return false}
    if lhs.flagSet != rhs.flagSet {return false}
    if lhs.envSet != rhs.envSet {return false}
    if lhs.requires != rhs.requires {return false}
    if lhs.implies != rhs.implies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ToolPath"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "path"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._path == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_ToolPath) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompilationModeFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .standard(proto: "compiler_flag"),
    3: .standard(proto: "cxx_flag"),
    4: .standard(proto: "linker_flag"),
  ]

  public var isInitialized: Bool {
    if self._mode == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.compilerFlag) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.cxxFlag) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.linkerFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.compilerFlag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.compilerFlag, fieldNumber: 2)
    }
    if !self.cxxFlag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cxxFlag, fieldNumber: 3)
    }
    if !self.linkerFlag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.linkerFlag, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CompilationModeFlags) -> Bool {
    if lhs._mode != rhs._mode {return false}
    if lhs.compilerFlag != rhs.compilerFlag {return false}
    if lhs.cxxFlag != rhs.cxxFlag {return false}
    if lhs.linkerFlag != rhs.linkerFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LinkingModeFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .standard(proto: "linker_flag"),
  ]

  public var isInitialized: Bool {
    if self._mode == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.linkerFlag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.linkerFlag.isEmpty {
      try visitor.visitRepeatedStringField(value: self.linkerFlag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_LinkingModeFlags) -> Bool {
    if lhs._mode != rhs._mode {return false}
    if lhs.linkerFlag != rhs.linkerFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MakeVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_MakeVariable) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_DefaultCpuToolchain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DefaultCpuToolchain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cpu"),
    2: .standard(proto: "toolchain_identifier"),
  ]

  public var isInitialized: Bool {
    if self._cpu == nil {return false}
    if self._toolchainIdentifier == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._cpu) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._toolchainIdentifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cpu {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._toolchainIdentifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_DefaultCpuToolchain, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_DefaultCpuToolchain) -> Bool {
    if lhs._cpu != rhs._cpu {return false}
    if lhs._toolchainIdentifier != rhs._toolchainIdentifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CrosstoolRelease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CrosstoolRelease"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "major_version"),
    2: .standard(proto: "minor_version"),
    3: .standard(proto: "default_target_cpu"),
    4: .standard(proto: "default_toolchain"),
    5: .same(proto: "toolchain"),
  ]

  public var isInitialized: Bool {
    if self._majorVersion == nil {return false}
    if self._minorVersion == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.defaultToolchain) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.toolchain) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._majorVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._minorVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._defaultTargetCpu) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.defaultToolchain) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.toolchain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._majorVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minorVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._defaultTargetCpu {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.defaultToolchain.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.defaultToolchain, fieldNumber: 4)
    }
    if !self.toolchain.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.toolchain, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CrosstoolRelease, rhs: Com_Google_Devtools_Build_Lib_View_Config_Crosstool_CrosstoolRelease) -> Bool {
    if lhs._majorVersion != rhs._majorVersion {return false}
    if lhs._minorVersion != rhs._minorVersion {return false}
    if lhs._defaultTargetCpu != rhs._defaultTargetCpu {return false}
    if lhs.defaultToolchain != rhs.defaultToolchain {return false}
    if lhs.toolchain != rhs.toolchain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
