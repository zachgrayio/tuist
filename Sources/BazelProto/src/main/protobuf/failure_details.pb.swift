// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/failure_details.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file's messages describe any failure(s) that occurred during Bazel's
// handling of a request. The intent is to provide more detail to a Bazel client
// than is conveyed with an exit code, to help those clients decide how to
// respond to, or classify, a failure.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct FailureDetails_FailureDetailMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exitCode: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The FailureDetail message type is designed such that consumers can extract a
/// basic classification of a FailureDetail message even if the consumer was
/// built with a stale definition. This forward compatibility is implemented via
/// conventions on FailureDetail and its submessage types, as follows.
///
/// *** FailureDetail field numbers
///
/// Field numbers 1 through 100 (inclusive) are reserved for generally applicable
/// values. Any number of these fields may be set on a FailureDetail message.
///
/// Field numbers 101 through 10,000 (inclusive) are reserved for use inside the
/// "oneof" structure. Only one of these values should be set on a FailureDetail
/// message.
///
/// Additional fields numbers are unlikely to be needed, but, for extreme future-
/// proofing purposes, field numbers 10,001 through 1,000,000 (inclusive;
/// excluding protobuf's reserved range 19000 through 19999) are reserved for
/// additional generally applicable values.
///
/// *** FailureDetail's "oneof" submessages
///
/// Each field in the "oneof" structure is a submessage corresponding to a
/// category of failure.
///
/// In each of these submessage types, field number 1 is an enum whose values
/// correspond to a subcategory of the failure. Generally, the enum's constant
/// which maps to 0 should be interpreted as "unspecified", though this is not
/// required.
///
/// *** Recommended forward compatibility strategy
///
/// The recommended forward compatibility strategy is to reduce a FailureDetail
/// message to a pair of integers.
///
/// The first integer corresponds to the field number of the submessage set
/// inside FailureDetail's "oneof", which corresponds with the failure's
/// category.
///
/// The second integer corresponds to the value of the enum at field number 1
/// within that submessage, which corresponds with the failure's subcategory.
///
/// WARNING: This functionality is experimental and should not be relied on at
/// this time.
/// TODO(mschaller): remove experimental warning
public struct FailureDetails_FailureDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A short human-readable message describing the failure, for debugging.
  ///
  /// This value is *not* intended to be used algorithmically.
  public var message: String = String()

  public var category: FailureDetails_FailureDetail.OneOf_Category? = nil

  public var interrupted: FailureDetails_Interrupted {
    get {
      if case .interrupted(let v)? = category {return v}
      return FailureDetails_Interrupted()
    }
    set {category = .interrupted(newValue)}
  }

  public var externalRepository: FailureDetails_ExternalRepository {
    get {
      if case .externalRepository(let v)? = category {return v}
      return FailureDetails_ExternalRepository()
    }
    set {category = .externalRepository(newValue)}
  }

  public var buildProgress: FailureDetails_BuildProgress {
    get {
      if case .buildProgress(let v)? = category {return v}
      return FailureDetails_BuildProgress()
    }
    set {category = .buildProgress(newValue)}
  }

  public var remoteOptions: FailureDetails_RemoteOptions {
    get {
      if case .remoteOptions(let v)? = category {return v}
      return FailureDetails_RemoteOptions()
    }
    set {category = .remoteOptions(newValue)}
  }

  public var clientEnvironment: FailureDetails_ClientEnvironment {
    get {
      if case .clientEnvironment(let v)? = category {return v}
      return FailureDetails_ClientEnvironment()
    }
    set {category = .clientEnvironment(newValue)}
  }

  public var crash: FailureDetails_Crash {
    get {
      if case .crash(let v)? = category {return v}
      return FailureDetails_Crash()
    }
    set {category = .crash(newValue)}
  }

  public var symlinkForest: FailureDetails_SymlinkForest {
    get {
      if case .symlinkForest(let v)? = category {return v}
      return FailureDetails_SymlinkForest()
    }
    set {category = .symlinkForest(newValue)}
  }

  public var packageOptions: FailureDetails_PackageOptions {
    get {
      if case .packageOptions(let v)? = category {return v}
      return FailureDetails_PackageOptions()
    }
    set {category = .packageOptions(newValue)}
  }

  public var remoteExecution: FailureDetails_RemoteExecution {
    get {
      if case .remoteExecution(let v)? = category {return v}
      return FailureDetails_RemoteExecution()
    }
    set {category = .remoteExecution(newValue)}
  }

  public var execution: FailureDetails_Execution {
    get {
      if case .execution(let v)? = category {return v}
      return FailureDetails_Execution()
    }
    set {category = .execution(newValue)}
  }

  public var workspaces: FailureDetails_Workspaces {
    get {
      if case .workspaces(let v)? = category {return v}
      return FailureDetails_Workspaces()
    }
    set {category = .workspaces(newValue)}
  }

  public var crashOptions: FailureDetails_CrashOptions {
    get {
      if case .crashOptions(let v)? = category {return v}
      return FailureDetails_CrashOptions()
    }
    set {category = .crashOptions(newValue)}
  }

  public var filesystem: FailureDetails_Filesystem {
    get {
      if case .filesystem(let v)? = category {return v}
      return FailureDetails_Filesystem()
    }
    set {category = .filesystem(newValue)}
  }

  public var executionOptions: FailureDetails_ExecutionOptions {
    get {
      if case .executionOptions(let v)? = category {return v}
      return FailureDetails_ExecutionOptions()
    }
    set {category = .executionOptions(newValue)}
  }

  public var command: FailureDetails_Command {
    get {
      if case .command(let v)? = category {return v}
      return FailureDetails_Command()
    }
    set {category = .command(newValue)}
  }

  public var spawn: FailureDetails_Spawn {
    get {
      if case .spawn(let v)? = category {return v}
      return FailureDetails_Spawn()
    }
    set {category = .spawn(newValue)}
  }

  public var grpcServer: FailureDetails_GrpcServer {
    get {
      if case .grpcServer(let v)? = category {return v}
      return FailureDetails_GrpcServer()
    }
    set {category = .grpcServer(newValue)}
  }

  public var canonicalizeFlags: FailureDetails_CanonicalizeFlags {
    get {
      if case .canonicalizeFlags(let v)? = category {return v}
      return FailureDetails_CanonicalizeFlags()
    }
    set {category = .canonicalizeFlags(newValue)}
  }

  public var buildConfiguration: FailureDetails_BuildConfiguration {
    get {
      if case .buildConfiguration(let v)? = category {return v}
      return FailureDetails_BuildConfiguration()
    }
    set {category = .buildConfiguration(newValue)}
  }

  public var infoCommand: FailureDetails_InfoCommand {
    get {
      if case .infoCommand(let v)? = category {return v}
      return FailureDetails_InfoCommand()
    }
    set {category = .infoCommand(newValue)}
  }

  public var memoryOptions: FailureDetails_MemoryOptions {
    get {
      if case .memoryOptions(let v)? = category {return v}
      return FailureDetails_MemoryOptions()
    }
    set {category = .memoryOptions(newValue)}
  }

  public var query: FailureDetails_Query {
    get {
      if case .query(let v)? = category {return v}
      return FailureDetails_Query()
    }
    set {category = .query(newValue)}
  }

  public var localExecution: FailureDetails_LocalExecution {
    get {
      if case .localExecution(let v)? = category {return v}
      return FailureDetails_LocalExecution()
    }
    set {category = .localExecution(newValue)}
  }

  public var actionCache: FailureDetails_ActionCache {
    get {
      if case .actionCache(let v)? = category {return v}
      return FailureDetails_ActionCache()
    }
    set {category = .actionCache(newValue)}
  }

  public var fetchCommand: FailureDetails_FetchCommand {
    get {
      if case .fetchCommand(let v)? = category {return v}
      return FailureDetails_FetchCommand()
    }
    set {category = .fetchCommand(newValue)}
  }

  public var syncCommand: FailureDetails_SyncCommand {
    get {
      if case .syncCommand(let v)? = category {return v}
      return FailureDetails_SyncCommand()
    }
    set {category = .syncCommand(newValue)}
  }

  public var sandbox: FailureDetails_Sandbox {
    get {
      if case .sandbox(let v)? = category {return v}
      return FailureDetails_Sandbox()
    }
    set {category = .sandbox(newValue)}
  }

  public var includeScanning: FailureDetails_IncludeScanning {
    get {
      if case .includeScanning(let v)? = category {return v}
      return FailureDetails_IncludeScanning()
    }
    set {category = .includeScanning(newValue)}
  }

  public var testCommand: FailureDetails_TestCommand {
    get {
      if case .testCommand(let v)? = category {return v}
      return FailureDetails_TestCommand()
    }
    set {category = .testCommand(newValue)}
  }

  public var actionQuery: FailureDetails_ActionQuery {
    get {
      if case .actionQuery(let v)? = category {return v}
      return FailureDetails_ActionQuery()
    }
    set {category = .actionQuery(newValue)}
  }

  public var targetPatterns: FailureDetails_TargetPatterns {
    get {
      if case .targetPatterns(let v)? = category {return v}
      return FailureDetails_TargetPatterns()
    }
    set {category = .targetPatterns(newValue)}
  }

  public var cleanCommand: FailureDetails_CleanCommand {
    get {
      if case .cleanCommand(let v)? = category {return v}
      return FailureDetails_CleanCommand()
    }
    set {category = .cleanCommand(newValue)}
  }

  public var configCommand: FailureDetails_ConfigCommand {
    get {
      if case .configCommand(let v)? = category {return v}
      return FailureDetails_ConfigCommand()
    }
    set {category = .configCommand(newValue)}
  }

  public var configurableQuery: FailureDetails_ConfigurableQuery {
    get {
      if case .configurableQuery(let v)? = category {return v}
      return FailureDetails_ConfigurableQuery()
    }
    set {category = .configurableQuery(newValue)}
  }

  public var dumpCommand: FailureDetails_DumpCommand {
    get {
      if case .dumpCommand(let v)? = category {return v}
      return FailureDetails_DumpCommand()
    }
    set {category = .dumpCommand(newValue)}
  }

  public var helpCommand: FailureDetails_HelpCommand {
    get {
      if case .helpCommand(let v)? = category {return v}
      return FailureDetails_HelpCommand()
    }
    set {category = .helpCommand(newValue)}
  }

  public var mobileInstall: FailureDetails_MobileInstall {
    get {
      if case .mobileInstall(let v)? = category {return v}
      return FailureDetails_MobileInstall()
    }
    set {category = .mobileInstall(newValue)}
  }

  public var profileCommand: FailureDetails_ProfileCommand {
    get {
      if case .profileCommand(let v)? = category {return v}
      return FailureDetails_ProfileCommand()
    }
    set {category = .profileCommand(newValue)}
  }

  public var runCommand: FailureDetails_RunCommand {
    get {
      if case .runCommand(let v)? = category {return v}
      return FailureDetails_RunCommand()
    }
    set {category = .runCommand(newValue)}
  }

  public var versionCommand: FailureDetails_VersionCommand {
    get {
      if case .versionCommand(let v)? = category {return v}
      return FailureDetails_VersionCommand()
    }
    set {category = .versionCommand(newValue)}
  }

  public var printActionCommand: FailureDetails_PrintActionCommand {
    get {
      if case .printActionCommand(let v)? = category {return v}
      return FailureDetails_PrintActionCommand()
    }
    set {category = .printActionCommand(newValue)}
  }

  public var workspaceStatus: FailureDetails_WorkspaceStatus {
    get {
      if case .workspaceStatus(let v)? = category {return v}
      return FailureDetails_WorkspaceStatus()
    }
    set {category = .workspaceStatus(newValue)}
  }

  public var javaCompile: FailureDetails_JavaCompile {
    get {
      if case .javaCompile(let v)? = category {return v}
      return FailureDetails_JavaCompile()
    }
    set {category = .javaCompile(newValue)}
  }

  public var actionRewinding: FailureDetails_ActionRewinding {
    get {
      if case .actionRewinding(let v)? = category {return v}
      return FailureDetails_ActionRewinding()
    }
    set {category = .actionRewinding(newValue)}
  }

  public var cppCompile: FailureDetails_CppCompile {
    get {
      if case .cppCompile(let v)? = category {return v}
      return FailureDetails_CppCompile()
    }
    set {category = .cppCompile(newValue)}
  }

  public var starlarkAction: FailureDetails_StarlarkAction {
    get {
      if case .starlarkAction(let v)? = category {return v}
      return FailureDetails_StarlarkAction()
    }
    set {category = .starlarkAction(newValue)}
  }

  public var ninjaAction: FailureDetails_NinjaAction {
    get {
      if case .ninjaAction(let v)? = category {return v}
      return FailureDetails_NinjaAction()
    }
    set {category = .ninjaAction(newValue)}
  }

  public var dynamicExecution: FailureDetails_DynamicExecution {
    get {
      if case .dynamicExecution(let v)? = category {return v}
      return FailureDetails_DynamicExecution()
    }
    set {category = .dynamicExecution(newValue)}
  }

  public var failAction: FailureDetails_FailAction {
    get {
      if case .failAction(let v)? = category {return v}
      return FailureDetails_FailAction()
    }
    set {category = .failAction(newValue)}
  }

  public var symlinkAction: FailureDetails_SymlinkAction {
    get {
      if case .symlinkAction(let v)? = category {return v}
      return FailureDetails_SymlinkAction()
    }
    set {category = .symlinkAction(newValue)}
  }

  public var cppLink: FailureDetails_CppLink {
    get {
      if case .cppLink(let v)? = category {return v}
      return FailureDetails_CppLink()
    }
    set {category = .cppLink(newValue)}
  }

  public var ltoAction: FailureDetails_LtoAction {
    get {
      if case .ltoAction(let v)? = category {return v}
      return FailureDetails_LtoAction()
    }
    set {category = .ltoAction(newValue)}
  }

  public var testAction: FailureDetails_TestAction {
    get {
      if case .testAction(let v)? = category {return v}
      return FailureDetails_TestAction()
    }
    set {category = .testAction(newValue)}
  }

  public var worker: FailureDetails_Worker {
    get {
      if case .worker(let v)? = category {return v}
      return FailureDetails_Worker()
    }
    set {category = .worker(newValue)}
  }

  public var analysis: FailureDetails_Analysis {
    get {
      if case .analysis(let v)? = category {return v}
      return FailureDetails_Analysis()
    }
    set {category = .analysis(newValue)}
  }

  public var packageLoading: FailureDetails_PackageLoading {
    get {
      if case .packageLoading(let v)? = category {return v}
      return FailureDetails_PackageLoading()
    }
    set {category = .packageLoading(newValue)}
  }

  public var toolchain: FailureDetails_Toolchain {
    get {
      if case .toolchain(let v)? = category {return v}
      return FailureDetails_Toolchain()
    }
    set {category = .toolchain(newValue)}
  }

  public var starlarkLoading: FailureDetails_StarlarkLoading {
    get {
      if case .starlarkLoading(let v)? = category {return v}
      return FailureDetails_StarlarkLoading()
    }
    set {category = .starlarkLoading(newValue)}
  }

  public var externalDeps: FailureDetails_ExternalDeps {
    get {
      if case .externalDeps(let v)? = category {return v}
      return FailureDetails_ExternalDeps()
    }
    set {category = .externalDeps(newValue)}
  }

  public var diffAwareness: FailureDetails_DiffAwareness {
    get {
      if case .diffAwareness(let v)? = category {return v}
      return FailureDetails_DiffAwareness()
    }
    set {category = .diffAwareness(newValue)}
  }

  public var modqueryCommand: FailureDetails_ModqueryCommand {
    get {
      if case .modqueryCommand(let v)? = category {return v}
      return FailureDetails_ModqueryCommand()
    }
    set {category = .modqueryCommand(newValue)}
  }

  public var buildReport: FailureDetails_BuildReport {
    get {
      if case .buildReport(let v)? = category {return v}
      return FailureDetails_BuildReport()
    }
    set {category = .buildReport(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Category: Equatable {
    case interrupted(FailureDetails_Interrupted)
    case externalRepository(FailureDetails_ExternalRepository)
    case buildProgress(FailureDetails_BuildProgress)
    case remoteOptions(FailureDetails_RemoteOptions)
    case clientEnvironment(FailureDetails_ClientEnvironment)
    case crash(FailureDetails_Crash)
    case symlinkForest(FailureDetails_SymlinkForest)
    case packageOptions(FailureDetails_PackageOptions)
    case remoteExecution(FailureDetails_RemoteExecution)
    case execution(FailureDetails_Execution)
    case workspaces(FailureDetails_Workspaces)
    case crashOptions(FailureDetails_CrashOptions)
    case filesystem(FailureDetails_Filesystem)
    case executionOptions(FailureDetails_ExecutionOptions)
    case command(FailureDetails_Command)
    case spawn(FailureDetails_Spawn)
    case grpcServer(FailureDetails_GrpcServer)
    case canonicalizeFlags(FailureDetails_CanonicalizeFlags)
    case buildConfiguration(FailureDetails_BuildConfiguration)
    case infoCommand(FailureDetails_InfoCommand)
    case memoryOptions(FailureDetails_MemoryOptions)
    case query(FailureDetails_Query)
    case localExecution(FailureDetails_LocalExecution)
    case actionCache(FailureDetails_ActionCache)
    case fetchCommand(FailureDetails_FetchCommand)
    case syncCommand(FailureDetails_SyncCommand)
    case sandbox(FailureDetails_Sandbox)
    case includeScanning(FailureDetails_IncludeScanning)
    case testCommand(FailureDetails_TestCommand)
    case actionQuery(FailureDetails_ActionQuery)
    case targetPatterns(FailureDetails_TargetPatterns)
    case cleanCommand(FailureDetails_CleanCommand)
    case configCommand(FailureDetails_ConfigCommand)
    case configurableQuery(FailureDetails_ConfigurableQuery)
    case dumpCommand(FailureDetails_DumpCommand)
    case helpCommand(FailureDetails_HelpCommand)
    case mobileInstall(FailureDetails_MobileInstall)
    case profileCommand(FailureDetails_ProfileCommand)
    case runCommand(FailureDetails_RunCommand)
    case versionCommand(FailureDetails_VersionCommand)
    case printActionCommand(FailureDetails_PrintActionCommand)
    case workspaceStatus(FailureDetails_WorkspaceStatus)
    case javaCompile(FailureDetails_JavaCompile)
    case actionRewinding(FailureDetails_ActionRewinding)
    case cppCompile(FailureDetails_CppCompile)
    case starlarkAction(FailureDetails_StarlarkAction)
    case ninjaAction(FailureDetails_NinjaAction)
    case dynamicExecution(FailureDetails_DynamicExecution)
    case failAction(FailureDetails_FailAction)
    case symlinkAction(FailureDetails_SymlinkAction)
    case cppLink(FailureDetails_CppLink)
    case ltoAction(FailureDetails_LtoAction)
    case testAction(FailureDetails_TestAction)
    case worker(FailureDetails_Worker)
    case analysis(FailureDetails_Analysis)
    case packageLoading(FailureDetails_PackageLoading)
    case toolchain(FailureDetails_Toolchain)
    case starlarkLoading(FailureDetails_StarlarkLoading)
    case externalDeps(FailureDetails_ExternalDeps)
    case diffAwareness(FailureDetails_DiffAwareness)
    case modqueryCommand(FailureDetails_ModqueryCommand)
    case buildReport(FailureDetails_BuildReport)

  #if !swift(>=4.1)
    public static func ==(lhs: FailureDetails_FailureDetail.OneOf_Category, rhs: FailureDetails_FailureDetail.OneOf_Category) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.interrupted, .interrupted): return {
        guard case .interrupted(let l) = lhs, case .interrupted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalRepository, .externalRepository): return {
        guard case .externalRepository(let l) = lhs, case .externalRepository(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildProgress, .buildProgress): return {
        guard case .buildProgress(let l) = lhs, case .buildProgress(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteOptions, .remoteOptions): return {
        guard case .remoteOptions(let l) = lhs, case .remoteOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clientEnvironment, .clientEnvironment): return {
        guard case .clientEnvironment(let l) = lhs, case .clientEnvironment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.crash, .crash): return {
        guard case .crash(let l) = lhs, case .crash(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.symlinkForest, .symlinkForest): return {
        guard case .symlinkForest(let l) = lhs, case .symlinkForest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.packageOptions, .packageOptions): return {
        guard case .packageOptions(let l) = lhs, case .packageOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteExecution, .remoteExecution): return {
        guard case .remoteExecution(let l) = lhs, case .remoteExecution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.execution, .execution): return {
        guard case .execution(let l) = lhs, case .execution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaces, .workspaces): return {
        guard case .workspaces(let l) = lhs, case .workspaces(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.crashOptions, .crashOptions): return {
        guard case .crashOptions(let l) = lhs, case .crashOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filesystem, .filesystem): return {
        guard case .filesystem(let l) = lhs, case .filesystem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.executionOptions, .executionOptions): return {
        guard case .executionOptions(let l) = lhs, case .executionOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.command, .command): return {
        guard case .command(let l) = lhs, case .command(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spawn, .spawn): return {
        guard case .spawn(let l) = lhs, case .spawn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.grpcServer, .grpcServer): return {
        guard case .grpcServer(let l) = lhs, case .grpcServer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.canonicalizeFlags, .canonicalizeFlags): return {
        guard case .canonicalizeFlags(let l) = lhs, case .canonicalizeFlags(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildConfiguration, .buildConfiguration): return {
        guard case .buildConfiguration(let l) = lhs, case .buildConfiguration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.infoCommand, .infoCommand): return {
        guard case .infoCommand(let l) = lhs, case .infoCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.memoryOptions, .memoryOptions): return {
        guard case .memoryOptions(let l) = lhs, case .memoryOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localExecution, .localExecution): return {
        guard case .localExecution(let l) = lhs, case .localExecution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionCache, .actionCache): return {
        guard case .actionCache(let l) = lhs, case .actionCache(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fetchCommand, .fetchCommand): return {
        guard case .fetchCommand(let l) = lhs, case .fetchCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.syncCommand, .syncCommand): return {
        guard case .syncCommand(let l) = lhs, case .syncCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sandbox, .sandbox): return {
        guard case .sandbox(let l) = lhs, case .sandbox(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.includeScanning, .includeScanning): return {
        guard case .includeScanning(let l) = lhs, case .includeScanning(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testCommand, .testCommand): return {
        guard case .testCommand(let l) = lhs, case .testCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionQuery, .actionQuery): return {
        guard case .actionQuery(let l) = lhs, case .actionQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.targetPatterns, .targetPatterns): return {
        guard case .targetPatterns(let l) = lhs, case .targetPatterns(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cleanCommand, .cleanCommand): return {
        guard case .cleanCommand(let l) = lhs, case .cleanCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configCommand, .configCommand): return {
        guard case .configCommand(let l) = lhs, case .configCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configurableQuery, .configurableQuery): return {
        guard case .configurableQuery(let l) = lhs, case .configurableQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dumpCommand, .dumpCommand): return {
        guard case .dumpCommand(let l) = lhs, case .dumpCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.helpCommand, .helpCommand): return {
        guard case .helpCommand(let l) = lhs, case .helpCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mobileInstall, .mobileInstall): return {
        guard case .mobileInstall(let l) = lhs, case .mobileInstall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profileCommand, .profileCommand): return {
        guard case .profileCommand(let l) = lhs, case .profileCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.runCommand, .runCommand): return {
        guard case .runCommand(let l) = lhs, case .runCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.versionCommand, .versionCommand): return {
        guard case .versionCommand(let l) = lhs, case .versionCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.printActionCommand, .printActionCommand): return {
        guard case .printActionCommand(let l) = lhs, case .printActionCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.workspaceStatus, .workspaceStatus): return {
        guard case .workspaceStatus(let l) = lhs, case .workspaceStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.javaCompile, .javaCompile): return {
        guard case .javaCompile(let l) = lhs, case .javaCompile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionRewinding, .actionRewinding): return {
        guard case .actionRewinding(let l) = lhs, case .actionRewinding(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cppCompile, .cppCompile): return {
        guard case .cppCompile(let l) = lhs, case .cppCompile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.starlarkAction, .starlarkAction): return {
        guard case .starlarkAction(let l) = lhs, case .starlarkAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ninjaAction, .ninjaAction): return {
        guard case .ninjaAction(let l) = lhs, case .ninjaAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dynamicExecution, .dynamicExecution): return {
        guard case .dynamicExecution(let l) = lhs, case .dynamicExecution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.failAction, .failAction): return {
        guard case .failAction(let l) = lhs, case .failAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.symlinkAction, .symlinkAction): return {
        guard case .symlinkAction(let l) = lhs, case .symlinkAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cppLink, .cppLink): return {
        guard case .cppLink(let l) = lhs, case .cppLink(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ltoAction, .ltoAction): return {
        guard case .ltoAction(let l) = lhs, case .ltoAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testAction, .testAction): return {
        guard case .testAction(let l) = lhs, case .testAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.worker, .worker): return {
        guard case .worker(let l) = lhs, case .worker(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.analysis, .analysis): return {
        guard case .analysis(let l) = lhs, case .analysis(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.packageLoading, .packageLoading): return {
        guard case .packageLoading(let l) = lhs, case .packageLoading(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.toolchain, .toolchain): return {
        guard case .toolchain(let l) = lhs, case .toolchain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.starlarkLoading, .starlarkLoading): return {
        guard case .starlarkLoading(let l) = lhs, case .starlarkLoading(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.externalDeps, .externalDeps): return {
        guard case .externalDeps(let l) = lhs, case .externalDeps(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diffAwareness, .diffAwareness): return {
        guard case .diffAwareness(let l) = lhs, case .diffAwareness(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.modqueryCommand, .modqueryCommand): return {
        guard case .modqueryCommand(let l) = lhs, case .modqueryCommand(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.buildReport, .buildReport): return {
        guard case .buildReport(let l) = lhs, case .buildReport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct FailureDetails_Interrupted {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Interrupted.Code = .interruptedUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown interrupt. Avoid using this code, instead use INTERRUPTED.
    case interruptedUnknown // = 0

    /// Command was interrupted (cancelled).
    case interrupted // = 28

    /// The following more specific interrupt codes have been deprecated and
    /// consolidated into INTERRUPTED.
    case deprecatedBuild // = 4
    case deprecatedBuildCompletion // = 5
    case deprecatedPackageLoadingSync // = 6
    case deprecatedExecutorCompletion // = 7
    case deprecatedCommandDispatch // = 8
    case deprecatedInfoItem // = 9
    case deprecatedAfterQuery // = 10
    case deprecatedFetchCommand // = 17
    case deprecatedSyncCommand // = 18
    case deprecatedCleanCommand // = 20
    case deprecatedMobileInstallCommand // = 21
    case deprecatedQuery // = 22
    case deprecatedRunCommand // = 23
    case deprecatedOptionsParsing // = 27
    case UNRECOGNIZED(Int)

    public init() {
      self = .interruptedUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .interruptedUnknown
      case 4: self = .deprecatedBuild
      case 5: self = .deprecatedBuildCompletion
      case 6: self = .deprecatedPackageLoadingSync
      case 7: self = .deprecatedExecutorCompletion
      case 8: self = .deprecatedCommandDispatch
      case 9: self = .deprecatedInfoItem
      case 10: self = .deprecatedAfterQuery
      case 17: self = .deprecatedFetchCommand
      case 18: self = .deprecatedSyncCommand
      case 20: self = .deprecatedCleanCommand
      case 21: self = .deprecatedMobileInstallCommand
      case 22: self = .deprecatedQuery
      case 23: self = .deprecatedRunCommand
      case 27: self = .deprecatedOptionsParsing
      case 28: self = .interrupted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .interruptedUnknown: return 0
      case .deprecatedBuild: return 4
      case .deprecatedBuildCompletion: return 5
      case .deprecatedPackageLoadingSync: return 6
      case .deprecatedExecutorCompletion: return 7
      case .deprecatedCommandDispatch: return 8
      case .deprecatedInfoItem: return 9
      case .deprecatedAfterQuery: return 10
      case .deprecatedFetchCommand: return 17
      case .deprecatedSyncCommand: return 18
      case .deprecatedCleanCommand: return 20
      case .deprecatedMobileInstallCommand: return 21
      case .deprecatedQuery: return 22
      case .deprecatedRunCommand: return 23
      case .deprecatedOptionsParsing: return 27
      case .interrupted: return 28
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Interrupted.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Interrupted.Code] = [
    .interruptedUnknown,
    .interrupted,
    .deprecatedBuild,
    .deprecatedBuildCompletion,
    .deprecatedPackageLoadingSync,
    .deprecatedExecutorCompletion,
    .deprecatedCommandDispatch,
    .deprecatedInfoItem,
    .deprecatedAfterQuery,
    .deprecatedFetchCommand,
    .deprecatedSyncCommand,
    .deprecatedCleanCommand,
    .deprecatedMobileInstallCommand,
    .deprecatedQuery,
    .deprecatedRunCommand,
    .deprecatedOptionsParsing,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Spawn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Spawn.Code = .spawnUnknown

  /// For Codes describing generic failure to spawn (eg. EXECUTION_FAILED and
  /// EXECUTION_DENIED) the `catastrophic` field may be set to true indicating a
  /// failure that immediately terminated the entire build tool.
  public var catastrophic: Bool = false

  /// If Code is NON_ZERO_EXIT, the `spawn_exit_code` field may be set to the
  /// non-zero exit code returned by the spawned process to the OS.
  ///
  /// NOTE: This field must not be confused with the build tool's overall
  /// exit code.
  public var spawnExitCode: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case spawnUnknown // = 0

    /// See the SpawnResult.Status Java enum for definitions of the following
    /// Spawn failure codes.
    case nonZeroExit // = 1
    case timeout // = 2

    /// Note: Spawn OUT_OF_MEMORY leads to a BUILD_FAILURE exit_code because the
    /// build tool itself did not run out of memory.
    case outOfMemory // = 3
    case executionFailed // = 4
    case executionDenied // = 5
    case remoteCacheFailed // = 6
    case commandLineExpansionFailure // = 7
    case execIoException // = 8
    case invalidTimeout // = 9
    case invalidRemoteExecutionProperties // = 10
    case noUsableStrategyFound // = 11

    /// TODO(b/138456686): this code should be deprecated when SpawnResult is
    ///   refactored to prohibit undetailed failures
    case unspecifiedExecutionFailure // = 12
    case forbiddenInput // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .spawnUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .spawnUnknown
      case 1: self = .nonZeroExit
      case 2: self = .timeout
      case 3: self = .outOfMemory
      case 4: self = .executionFailed
      case 5: self = .executionDenied
      case 6: self = .remoteCacheFailed
      case 7: self = .commandLineExpansionFailure
      case 8: self = .execIoException
      case 9: self = .invalidTimeout
      case 10: self = .invalidRemoteExecutionProperties
      case 11: self = .noUsableStrategyFound
      case 12: self = .unspecifiedExecutionFailure
      case 13: self = .forbiddenInput
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .spawnUnknown: return 0
      case .nonZeroExit: return 1
      case .timeout: return 2
      case .outOfMemory: return 3
      case .executionFailed: return 4
      case .executionDenied: return 5
      case .remoteCacheFailed: return 6
      case .commandLineExpansionFailure: return 7
      case .execIoException: return 8
      case .invalidTimeout: return 9
      case .invalidRemoteExecutionProperties: return 10
      case .noUsableStrategyFound: return 11
      case .unspecifiedExecutionFailure: return 12
      case .forbiddenInput: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Spawn.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Spawn.Code] = [
    .spawnUnknown,
    .nonZeroExit,
    .timeout,
    .outOfMemory,
    .executionFailed,
    .executionDenied,
    .remoteCacheFailed,
    .commandLineExpansionFailure,
    .execIoException,
    .invalidTimeout,
    .invalidRemoteExecutionProperties,
    .noUsableStrategyFound,
    .unspecifiedExecutionFailure,
    .forbiddenInput,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ExternalRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Additional data could include external repository names.
  public var code: FailureDetails_ExternalRepository.Code = .externalRepositoryUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case externalRepositoryUnknown // = 0
    case overrideDisallowedManagedDirectories // = 1
    case badDownloaderConfig // = 2
    case repositoryMappingResolutionFailed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .externalRepositoryUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .externalRepositoryUnknown
      case 1: self = .overrideDisallowedManagedDirectories
      case 2: self = .badDownloaderConfig
      case 3: self = .repositoryMappingResolutionFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .externalRepositoryUnknown: return 0
      case .overrideDisallowedManagedDirectories: return 1
      case .badDownloaderConfig: return 2
      case .repositoryMappingResolutionFailed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ExternalRepository.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ExternalRepository.Code] = [
    .externalRepositoryUnknown,
    .overrideDisallowedManagedDirectories,
    .badDownloaderConfig,
    .repositoryMappingResolutionFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_BuildProgress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Additional data could include the build progress upload endpoint.
  public var code: FailureDetails_BuildProgress.Code = .buildProgressUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case buildProgressUnknown // = 0
    case outputInitialization // = 3
    case besRunsPerTestLimitUnsupported // = 4
    case besLocalWriteError // = 5
    case besInitializationError // = 6
    case besUploadTimeoutError // = 7
    case besFileWriteTimeout // = 8
    case besFileWriteIoError // = 9
    case besFileWriteInterrupted // = 10
    case besFileWriteCanceled // = 11
    case besFileWriteUnknownError // = 12
    case besUploadLocalFileError // = 13
    case besStreamNotRetryingFailure // = 14
    case besStreamCompletedWithUnackEventsError // = 15
    case besStreamCompletedWithUnsentEventsError // = 16
    case besStreamCompletedWithRemoteError // = 19
    case besUploadRetryLimitExceededFailure // = 17
    case UNRECOGNIZED(Int)

    public init() {
      self = .buildProgressUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .buildProgressUnknown
      case 3: self = .outputInitialization
      case 4: self = .besRunsPerTestLimitUnsupported
      case 5: self = .besLocalWriteError
      case 6: self = .besInitializationError
      case 7: self = .besUploadTimeoutError
      case 8: self = .besFileWriteTimeout
      case 9: self = .besFileWriteIoError
      case 10: self = .besFileWriteInterrupted
      case 11: self = .besFileWriteCanceled
      case 12: self = .besFileWriteUnknownError
      case 13: self = .besUploadLocalFileError
      case 14: self = .besStreamNotRetryingFailure
      case 15: self = .besStreamCompletedWithUnackEventsError
      case 16: self = .besStreamCompletedWithUnsentEventsError
      case 17: self = .besUploadRetryLimitExceededFailure
      case 19: self = .besStreamCompletedWithRemoteError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .buildProgressUnknown: return 0
      case .outputInitialization: return 3
      case .besRunsPerTestLimitUnsupported: return 4
      case .besLocalWriteError: return 5
      case .besInitializationError: return 6
      case .besUploadTimeoutError: return 7
      case .besFileWriteTimeout: return 8
      case .besFileWriteIoError: return 9
      case .besFileWriteInterrupted: return 10
      case .besFileWriteCanceled: return 11
      case .besFileWriteUnknownError: return 12
      case .besUploadLocalFileError: return 13
      case .besStreamNotRetryingFailure: return 14
      case .besStreamCompletedWithUnackEventsError: return 15
      case .besStreamCompletedWithUnsentEventsError: return 16
      case .besUploadRetryLimitExceededFailure: return 17
      case .besStreamCompletedWithRemoteError: return 19
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_BuildProgress.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_BuildProgress.Code] = [
    .buildProgressUnknown,
    .outputInitialization,
    .besRunsPerTestLimitUnsupported,
    .besLocalWriteError,
    .besInitializationError,
    .besUploadTimeoutError,
    .besFileWriteTimeout,
    .besFileWriteIoError,
    .besFileWriteInterrupted,
    .besFileWriteCanceled,
    .besFileWriteUnknownError,
    .besUploadLocalFileError,
    .besStreamNotRetryingFailure,
    .besStreamCompletedWithUnackEventsError,
    .besStreamCompletedWithUnsentEventsError,
    .besStreamCompletedWithRemoteError,
    .besUploadRetryLimitExceededFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_RemoteOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_RemoteOptions.Code = .remoteOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case remoteOptionsUnknown // = 0
    case remoteDefaultExecPropertiesLogicError // = 1

    /// Credentials could not be read from the requested file/socket/process/etc.
    case credentialsReadFailure // = 2

    /// Credentials could not be written to a shared, temporary file.
    case credentialsWriteFailure // = 3
    case downloaderWithoutGrpcCache // = 4
    case executionWithInvalidCache // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .remoteOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .remoteOptionsUnknown
      case 1: self = .remoteDefaultExecPropertiesLogicError
      case 2: self = .credentialsReadFailure
      case 3: self = .credentialsWriteFailure
      case 4: self = .downloaderWithoutGrpcCache
      case 5: self = .executionWithInvalidCache
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .remoteOptionsUnknown: return 0
      case .remoteDefaultExecPropertiesLogicError: return 1
      case .credentialsReadFailure: return 2
      case .credentialsWriteFailure: return 3
      case .downloaderWithoutGrpcCache: return 4
      case .executionWithInvalidCache: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_RemoteOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_RemoteOptions.Code] = [
    .remoteOptionsUnknown,
    .remoteDefaultExecPropertiesLogicError,
    .credentialsReadFailure,
    .credentialsWriteFailure,
    .downloaderWithoutGrpcCache,
    .executionWithInvalidCache,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ClientEnvironment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ClientEnvironment.Code = .clientEnvironmentUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case clientEnvironmentUnknown // = 0
    case clientCwdMalformed // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .clientEnvironmentUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .clientEnvironmentUnknown
      case 1: self = .clientCwdMalformed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .clientEnvironmentUnknown: return 0
      case .clientCwdMalformed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ClientEnvironment.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ClientEnvironment.Code] = [
    .clientEnvironmentUnknown,
    .clientCwdMalformed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Crash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Crash.Code = .crashUnknown

  /// The cause chain of the crash, with the outermost throwable first. Limited
  /// to the outermost exception and at most 4 nested causes (so, max size of 5).
  public var causes: [FailureDetails_Throwable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case crashUnknown // = 0
    case crashOom // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .crashUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .crashUnknown
      case 1: self = .crashOom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .crashUnknown: return 0
      case .crashOom: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Crash.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Crash.Code] = [
    .crashUnknown,
    .crashOom,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Throwable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The class name of the java.lang.Throwable.
  public var throwableClass: String = String()

  /// The throwable's message.
  public var message: String = String()

  /// The result of calling toString on the deepest (i.e. closest to the
  /// throwable's construction site) 1000 (or fewer) StackTraceElements.
  /// Unstructured to simplify string matching.
  public var stackTrace: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FailureDetails_SymlinkForest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_SymlinkForest.Code = .symlinkForestUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case symlinkForestUnknown // = 0
    case toplevelOutdirPackagePathConflict // = 1
    case toplevelOutdirUsedAsSource // = 2
    case creationFailed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .symlinkForestUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .symlinkForestUnknown
      case 1: self = .toplevelOutdirPackagePathConflict
      case 2: self = .toplevelOutdirUsedAsSource
      case 3: self = .creationFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .symlinkForestUnknown: return 0
      case .toplevelOutdirPackagePathConflict: return 1
      case .toplevelOutdirUsedAsSource: return 2
      case .creationFailed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_SymlinkForest.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_SymlinkForest.Code] = [
    .symlinkForestUnknown,
    .toplevelOutdirPackagePathConflict,
    .toplevelOutdirUsedAsSource,
    .creationFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_BuildReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Additional data for partial failures might include the build report that
  /// failed to be written.
  public var code: FailureDetails_BuildReport.Code = .buildReportUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case buildReportUnknown // = 0
    case buildReportUploaderNeedsPackagePaths // = 1
    case buildReportWriteFailed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .buildReportUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .buildReportUnknown
      case 1: self = .buildReportUploaderNeedsPackagePaths
      case 2: self = .buildReportWriteFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .buildReportUnknown: return 0
      case .buildReportUploaderNeedsPackagePaths: return 1
      case .buildReportWriteFailed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_BuildReport.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_BuildReport.Code] = [
    .buildReportUnknown,
    .buildReportUploaderNeedsPackagePaths,
    .buildReportWriteFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_PackageOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_PackageOptions.Code = .packageOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case packageOptionsUnknown // = 0
    case packagePathInvalid // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .packageOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .packageOptionsUnknown
      case 1: self = .packagePathInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .packageOptionsUnknown: return 0
      case .packagePathInvalid: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_PackageOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_PackageOptions.Code] = [
    .packageOptionsUnknown,
    .packagePathInvalid,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_RemoteExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_RemoteExecution.Code = .remoteExecutionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The association of some of these options with exit code 2, "command line
  /// error", seems sketchy. Especially worth reconsidering are the channel init
  /// failure modes, which can correspond to failures occurring in gRPC setup.
  /// These all correspond with current Bazel behavior.
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case remoteExecutionUnknown // = 0
    case capabilitiesQueryFailure // = 1
    case credentialsInitFailure // = 2
    case cacheInitFailure // = 3
    case rpcLogFailure // = 4
    case execChannelInitFailure // = 5
    case cacheChannelInitFailure // = 6
    case downloaderChannelInitFailure // = 7
    case logDirCleanupFailure // = 8
    case clientServerIncompatible // = 9
    case downloadedInputsDeletionFailure // = 10
    case remoteDownloadOutputsMinimalWithoutInmemoryDotd // = 11
    case remoteDownloadOutputsMinimalWithoutInmemoryJdeps // = 12
    case incompleteOutputDownloadCleanupFailure // = 13
    case remoteDefaultPlatformPropertiesParseFailure // = 14
    case illegalOutput // = 15
    case invalidExecAndPlatformProperties // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .remoteExecutionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .remoteExecutionUnknown
      case 1: self = .capabilitiesQueryFailure
      case 2: self = .credentialsInitFailure
      case 3: self = .cacheInitFailure
      case 4: self = .rpcLogFailure
      case 5: self = .execChannelInitFailure
      case 6: self = .cacheChannelInitFailure
      case 7: self = .downloaderChannelInitFailure
      case 8: self = .logDirCleanupFailure
      case 9: self = .clientServerIncompatible
      case 10: self = .downloadedInputsDeletionFailure
      case 11: self = .remoteDownloadOutputsMinimalWithoutInmemoryDotd
      case 12: self = .remoteDownloadOutputsMinimalWithoutInmemoryJdeps
      case 13: self = .incompleteOutputDownloadCleanupFailure
      case 14: self = .remoteDefaultPlatformPropertiesParseFailure
      case 15: self = .illegalOutput
      case 16: self = .invalidExecAndPlatformProperties
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .remoteExecutionUnknown: return 0
      case .capabilitiesQueryFailure: return 1
      case .credentialsInitFailure: return 2
      case .cacheInitFailure: return 3
      case .rpcLogFailure: return 4
      case .execChannelInitFailure: return 5
      case .cacheChannelInitFailure: return 6
      case .downloaderChannelInitFailure: return 7
      case .logDirCleanupFailure: return 8
      case .clientServerIncompatible: return 9
      case .downloadedInputsDeletionFailure: return 10
      case .remoteDownloadOutputsMinimalWithoutInmemoryDotd: return 11
      case .remoteDownloadOutputsMinimalWithoutInmemoryJdeps: return 12
      case .incompleteOutputDownloadCleanupFailure: return 13
      case .remoteDefaultPlatformPropertiesParseFailure: return 14
      case .illegalOutput: return 15
      case .invalidExecAndPlatformProperties: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_RemoteExecution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_RemoteExecution.Code] = [
    .remoteExecutionUnknown,
    .capabilitiesQueryFailure,
    .credentialsInitFailure,
    .cacheInitFailure,
    .rpcLogFailure,
    .execChannelInitFailure,
    .cacheChannelInitFailure,
    .downloaderChannelInitFailure,
    .logDirCleanupFailure,
    .clientServerIncompatible,
    .downloadedInputsDeletionFailure,
    .remoteDownloadOutputsMinimalWithoutInmemoryDotd,
    .remoteDownloadOutputsMinimalWithoutInmemoryJdeps,
    .incompleteOutputDownloadCleanupFailure,
    .remoteDefaultPlatformPropertiesParseFailure,
    .illegalOutput,
    .invalidExecAndPlatformProperties,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Execution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Execution.Code = .executionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case executionUnknown // = 0
    case executionLogInitializationFailure // = 1
    case executionLogWriteFailure // = 2
    case execrootCreationFailure // = 3
    case tempActionOutputDirectoryDeletionFailure // = 4
    case tempActionOutputDirectoryCreationFailure // = 5
    case persistentActionOutputDirectoryCreationFailure // = 6
    case localOutputDirectorySymlinkFailure // = 7

    /// SOURCE_INPUT_MISSING
    case localTemplateExpansionFailure // = 9
    case inputDirectoryCheckIoException // = 10
    case extraActionOutputCreationFailure // = 11
    case testRunnerIoException // = 12
    case fileWriteIoException // = 13
    case testOutErrIoException // = 14
    case symlinkTreeManifestCopyIoException // = 15
    case symlinkTreeManifestLinkIoException // = 16
    case symlinkTreeCreationIoException // = 17
    case symlinkTreeCreationCommandException // = 18
    case actionInputReadIoException // = 19
    case actionNotUpToDate // = 20
    case pseudoActionExecutionProhibited // = 21
    case discoveredInputDoesNotExist // = 22
    case actionOutputsDeletionFailure // = 23
    case actionOutputsNotCreated // = 24
    case actionFinalizationFailure // = 25
    case actionInputLost // = 26
    case filesystemContextUpdateFailure // = 27
    case actionOutputCloseFailure // = 28
    case inputDiscoveryIoException // = 29
    case treeArtifactDirectoryCreationFailure // = 30
    case actionOutputDirectoryCreationFailure // = 31
    case actionFsOutputDirectoryCreationFailure // = 32
    case actionFsOutErrDirectoryCreationFailure // = 33
    case nonActionExecutionFailure // = 34
    case cycle // = 35
    case sourceInputMissing // = 36
    case unexpectedException // = 37
    case sourceInputIoException // = 39
    case UNRECOGNIZED(Int)

    public init() {
      self = .executionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .executionUnknown
      case 1: self = .executionLogInitializationFailure
      case 2: self = .executionLogWriteFailure
      case 3: self = .execrootCreationFailure
      case 4: self = .tempActionOutputDirectoryDeletionFailure
      case 5: self = .tempActionOutputDirectoryCreationFailure
      case 6: self = .persistentActionOutputDirectoryCreationFailure
      case 7: self = .localOutputDirectorySymlinkFailure
      case 9: self = .localTemplateExpansionFailure
      case 10: self = .inputDirectoryCheckIoException
      case 11: self = .extraActionOutputCreationFailure
      case 12: self = .testRunnerIoException
      case 13: self = .fileWriteIoException
      case 14: self = .testOutErrIoException
      case 15: self = .symlinkTreeManifestCopyIoException
      case 16: self = .symlinkTreeManifestLinkIoException
      case 17: self = .symlinkTreeCreationIoException
      case 18: self = .symlinkTreeCreationCommandException
      case 19: self = .actionInputReadIoException
      case 20: self = .actionNotUpToDate
      case 21: self = .pseudoActionExecutionProhibited
      case 22: self = .discoveredInputDoesNotExist
      case 23: self = .actionOutputsDeletionFailure
      case 24: self = .actionOutputsNotCreated
      case 25: self = .actionFinalizationFailure
      case 26: self = .actionInputLost
      case 27: self = .filesystemContextUpdateFailure
      case 28: self = .actionOutputCloseFailure
      case 29: self = .inputDiscoveryIoException
      case 30: self = .treeArtifactDirectoryCreationFailure
      case 31: self = .actionOutputDirectoryCreationFailure
      case 32: self = .actionFsOutputDirectoryCreationFailure
      case 33: self = .actionFsOutErrDirectoryCreationFailure
      case 34: self = .nonActionExecutionFailure
      case 35: self = .cycle
      case 36: self = .sourceInputMissing
      case 37: self = .unexpectedException
      case 39: self = .sourceInputIoException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .executionUnknown: return 0
      case .executionLogInitializationFailure: return 1
      case .executionLogWriteFailure: return 2
      case .execrootCreationFailure: return 3
      case .tempActionOutputDirectoryDeletionFailure: return 4
      case .tempActionOutputDirectoryCreationFailure: return 5
      case .persistentActionOutputDirectoryCreationFailure: return 6
      case .localOutputDirectorySymlinkFailure: return 7
      case .localTemplateExpansionFailure: return 9
      case .inputDirectoryCheckIoException: return 10
      case .extraActionOutputCreationFailure: return 11
      case .testRunnerIoException: return 12
      case .fileWriteIoException: return 13
      case .testOutErrIoException: return 14
      case .symlinkTreeManifestCopyIoException: return 15
      case .symlinkTreeManifestLinkIoException: return 16
      case .symlinkTreeCreationIoException: return 17
      case .symlinkTreeCreationCommandException: return 18
      case .actionInputReadIoException: return 19
      case .actionNotUpToDate: return 20
      case .pseudoActionExecutionProhibited: return 21
      case .discoveredInputDoesNotExist: return 22
      case .actionOutputsDeletionFailure: return 23
      case .actionOutputsNotCreated: return 24
      case .actionFinalizationFailure: return 25
      case .actionInputLost: return 26
      case .filesystemContextUpdateFailure: return 27
      case .actionOutputCloseFailure: return 28
      case .inputDiscoveryIoException: return 29
      case .treeArtifactDirectoryCreationFailure: return 30
      case .actionOutputDirectoryCreationFailure: return 31
      case .actionFsOutputDirectoryCreationFailure: return 32
      case .actionFsOutErrDirectoryCreationFailure: return 33
      case .nonActionExecutionFailure: return 34
      case .cycle: return 35
      case .sourceInputMissing: return 36
      case .unexpectedException: return 37
      case .sourceInputIoException: return 39
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Execution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Execution.Code] = [
    .executionUnknown,
    .executionLogInitializationFailure,
    .executionLogWriteFailure,
    .execrootCreationFailure,
    .tempActionOutputDirectoryDeletionFailure,
    .tempActionOutputDirectoryCreationFailure,
    .persistentActionOutputDirectoryCreationFailure,
    .localOutputDirectorySymlinkFailure,
    .localTemplateExpansionFailure,
    .inputDirectoryCheckIoException,
    .extraActionOutputCreationFailure,
    .testRunnerIoException,
    .fileWriteIoException,
    .testOutErrIoException,
    .symlinkTreeManifestCopyIoException,
    .symlinkTreeManifestLinkIoException,
    .symlinkTreeCreationIoException,
    .symlinkTreeCreationCommandException,
    .actionInputReadIoException,
    .actionNotUpToDate,
    .pseudoActionExecutionProhibited,
    .discoveredInputDoesNotExist,
    .actionOutputsDeletionFailure,
    .actionOutputsNotCreated,
    .actionFinalizationFailure,
    .actionInputLost,
    .filesystemContextUpdateFailure,
    .actionOutputCloseFailure,
    .inputDiscoveryIoException,
    .treeArtifactDirectoryCreationFailure,
    .actionOutputDirectoryCreationFailure,
    .actionFsOutputDirectoryCreationFailure,
    .actionFsOutErrDirectoryCreationFailure,
    .nonActionExecutionFailure,
    .cycle,
    .sourceInputMissing,
    .unexpectedException,
    .sourceInputIoException,
  ]
}

#endif  // swift(>=4.2)

/// Failure details about Bazel's WORKSPACE features.
public struct FailureDetails_Workspaces {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Workspaces.Code = .workspacesUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case workspacesUnknown // = 0
    case workspacesLogInitializationFailure // = 1
    case workspacesLogWriteFailure // = 2

    /// See `managed_directories` in
    /// https://bazel.build/rules/lib/globals#workspace.
    case illegalWorkspaceFileSymlinkWithManagedDirectories // = 3
    case workspaceFileReadFailureWithManagedDirectories // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .workspacesUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .workspacesUnknown
      case 1: self = .workspacesLogInitializationFailure
      case 2: self = .workspacesLogWriteFailure
      case 3: self = .illegalWorkspaceFileSymlinkWithManagedDirectories
      case 4: self = .workspaceFileReadFailureWithManagedDirectories
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .workspacesUnknown: return 0
      case .workspacesLogInitializationFailure: return 1
      case .workspacesLogWriteFailure: return 2
      case .illegalWorkspaceFileSymlinkWithManagedDirectories: return 3
      case .workspaceFileReadFailureWithManagedDirectories: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Workspaces.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Workspaces.Code] = [
    .workspacesUnknown,
    .workspacesLogInitializationFailure,
    .workspacesLogWriteFailure,
    .illegalWorkspaceFileSymlinkWithManagedDirectories,
    .workspaceFileReadFailureWithManagedDirectories,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CrashOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CrashOptions.Code = .crashOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case crashOptionsUnknown // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .crashOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .crashOptionsUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .crashOptionsUnknown: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CrashOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CrashOptions.Code] = [
    .crashOptionsUnknown,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Filesystem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Filesystem.Code = .filesystemUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case filesystemUnknown // = 0
    case embeddedBinariesEnumerationFailure // = 3
    case serverPidTxtFileReadFailure // = 4
    case serverFileWriteFailure // = 5
    case defaultDigestHashFunctionInvalidValue // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .filesystemUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .filesystemUnknown
      case 3: self = .embeddedBinariesEnumerationFailure
      case 4: self = .serverPidTxtFileReadFailure
      case 5: self = .serverFileWriteFailure
      case 6: self = .defaultDigestHashFunctionInvalidValue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .filesystemUnknown: return 0
      case .embeddedBinariesEnumerationFailure: return 3
      case .serverPidTxtFileReadFailure: return 4
      case .serverFileWriteFailure: return 5
      case .defaultDigestHashFunctionInvalidValue: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Filesystem.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Filesystem.Code] = [
    .filesystemUnknown,
    .embeddedBinariesEnumerationFailure,
    .serverPidTxtFileReadFailure,
    .serverFileWriteFailure,
    .defaultDigestHashFunctionInvalidValue,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ExecutionOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ExecutionOptions.Code = .executionOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// All numerical exit code associations correspond to pre-existing Bazel
  /// behavior. These associations are suspicious:
  /// - REQUESTED_STRATEGY_INCOMPATIBLE_WITH_SANDBOXING (instead: 2?)
  /// - DEPRECATED_LOCAL_RESOURCES_USED (instead: 2?)
  /// TODO(b/138456686): Revise these after the (intentionally non-breaking)
  ///  initial rollout of FailureDetail-based encoding.
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case executionOptionsUnknown // = 0
    case invalidStrategy // = 3
    case requestedStrategyIncompatibleWithSandboxing // = 4
    case deprecatedLocalResourcesUsed // = 5
    case invalidCyclicDynamicStrategy // = 6
    case restrictionUnmatchedToActionContext // = 7
    case remoteFallbackStrategyNotAbstractSpawn // = 8
    case strategyNotFound // = 9
    case dynamicStrategyNotSandboxed // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .executionOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .executionOptionsUnknown
      case 3: self = .invalidStrategy
      case 4: self = .requestedStrategyIncompatibleWithSandboxing
      case 5: self = .deprecatedLocalResourcesUsed
      case 6: self = .invalidCyclicDynamicStrategy
      case 7: self = .restrictionUnmatchedToActionContext
      case 8: self = .remoteFallbackStrategyNotAbstractSpawn
      case 9: self = .strategyNotFound
      case 10: self = .dynamicStrategyNotSandboxed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .executionOptionsUnknown: return 0
      case .invalidStrategy: return 3
      case .requestedStrategyIncompatibleWithSandboxing: return 4
      case .deprecatedLocalResourcesUsed: return 5
      case .invalidCyclicDynamicStrategy: return 6
      case .restrictionUnmatchedToActionContext: return 7
      case .remoteFallbackStrategyNotAbstractSpawn: return 8
      case .strategyNotFound: return 9
      case .dynamicStrategyNotSandboxed: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ExecutionOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ExecutionOptions.Code] = [
    .executionOptionsUnknown,
    .invalidStrategy,
    .requestedStrategyIncompatibleWithSandboxing,
    .deprecatedLocalResourcesUsed,
    .invalidCyclicDynamicStrategy,
    .restrictionUnmatchedToActionContext,
    .remoteFallbackStrategyNotAbstractSpawn,
    .strategyNotFound,
    .dynamicStrategyNotSandboxed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Command.Code = .commandFailureUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The name "COMMAND_UNKNOWN" might reasonably be interpreted as "command
    /// not found". The enum's default value should represent a lack of knowledge
    /// about the failure instead.
    case commandFailureUnknown // = 0
    case commandNotFound // = 1
    case anotherCommandRunning // = 2
    case previouslyShutdown // = 3
    case starlarkCpuProfileFileInitializationFailure // = 4
    case starlarkCpuProfilingInitializationFailure // = 5
    case starlarkCpuProfileFileWriteFailure // = 6
    case invocationPolicyParseFailure // = 7
    case invocationPolicyInvalid // = 8
    case optionsParseFailure // = 9
    case starlarkOptionsParseFailure // = 10
    case argumentsNotRecognized // = 11
    case notInWorkspace // = 12
    case spacesInWorkspacePath // = 13
    case inOutputDirectory // = 14
    case UNRECOGNIZED(Int)

    public init() {
      self = .commandFailureUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .commandFailureUnknown
      case 1: self = .commandNotFound
      case 2: self = .anotherCommandRunning
      case 3: self = .previouslyShutdown
      case 4: self = .starlarkCpuProfileFileInitializationFailure
      case 5: self = .starlarkCpuProfilingInitializationFailure
      case 6: self = .starlarkCpuProfileFileWriteFailure
      case 7: self = .invocationPolicyParseFailure
      case 8: self = .invocationPolicyInvalid
      case 9: self = .optionsParseFailure
      case 10: self = .starlarkOptionsParseFailure
      case 11: self = .argumentsNotRecognized
      case 12: self = .notInWorkspace
      case 13: self = .spacesInWorkspacePath
      case 14: self = .inOutputDirectory
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .commandFailureUnknown: return 0
      case .commandNotFound: return 1
      case .anotherCommandRunning: return 2
      case .previouslyShutdown: return 3
      case .starlarkCpuProfileFileInitializationFailure: return 4
      case .starlarkCpuProfilingInitializationFailure: return 5
      case .starlarkCpuProfileFileWriteFailure: return 6
      case .invocationPolicyParseFailure: return 7
      case .invocationPolicyInvalid: return 8
      case .optionsParseFailure: return 9
      case .starlarkOptionsParseFailure: return 10
      case .argumentsNotRecognized: return 11
      case .notInWorkspace: return 12
      case .spacesInWorkspacePath: return 13
      case .inOutputDirectory: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Command.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Command.Code] = [
    .commandFailureUnknown,
    .commandNotFound,
    .anotherCommandRunning,
    .previouslyShutdown,
    .starlarkCpuProfileFileInitializationFailure,
    .starlarkCpuProfilingInitializationFailure,
    .starlarkCpuProfileFileWriteFailure,
    .invocationPolicyParseFailure,
    .invocationPolicyInvalid,
    .optionsParseFailure,
    .starlarkOptionsParseFailure,
    .argumentsNotRecognized,
    .notInWorkspace,
    .spacesInWorkspacePath,
    .inOutputDirectory,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_GrpcServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_GrpcServer.Code = .grpcServerUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case grpcServerUnknown // = 0
    case grpcServerNotCompiledIn // = 1
    case serverBindFailure // = 2
    case badCookie // = 3
    case noClientDescription // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .grpcServerUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .grpcServerUnknown
      case 1: self = .grpcServerNotCompiledIn
      case 2: self = .serverBindFailure
      case 3: self = .badCookie
      case 4: self = .noClientDescription
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .grpcServerUnknown: return 0
      case .grpcServerNotCompiledIn: return 1
      case .serverBindFailure: return 2
      case .badCookie: return 3
      case .noClientDescription: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_GrpcServer.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_GrpcServer.Code] = [
    .grpcServerUnknown,
    .grpcServerNotCompiledIn,
    .serverBindFailure,
    .badCookie,
    .noClientDescription,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CanonicalizeFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CanonicalizeFlags.Code = .canonicalizeFlagsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case canonicalizeFlagsUnknown // = 0
    case forCommandInvalid // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .canonicalizeFlagsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .canonicalizeFlagsUnknown
      case 1: self = .forCommandInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .canonicalizeFlagsUnknown: return 0
      case .forCommandInvalid: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CanonicalizeFlags.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CanonicalizeFlags.Code] = [
    .canonicalizeFlagsUnknown,
    .forCommandInvalid,
  ]
}

#endif  // swift(>=4.2)

/// Failure modes described by this category pertain to the Bazel invocation
/// configuration consumed by Bazel's analysis phase. This category is not
/// intended as a grab-bag for all Bazel flag value constraint violations, which
/// instead generally belong in the category for the subsystem whose flag values
/// participate in the constraint.
public struct FailureDetails_BuildConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_BuildConfiguration.Code = .buildConfigurationUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case buildConfigurationUnknown // = 0
    case platformMappingEvaluationFailure // = 1
    case platformMappingsFileIsDirectory // = 2
    case platformMappingsFileNotFound // = 3
    case topLevelConfigurationCreationFailure // = 4
    case invalidConfiguration // = 5
    case invalidBuildOptions // = 6
    case multiCpuPrereqUnmet // = 7
    case heuristicInstrumentationFilterInvalid // = 8
    case cycle // = 9
    case conflictingConfigurations // = 10

    /// This can come from either an invalid user-specified option or a
    /// configuration transition. There's no sure-fire way to distinguish the two
    /// possibilities in Bazel, so we go with the more straightforward
    /// command-line error exit code 2.
    case invalidOutputDirectoryMnemonic // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .buildConfigurationUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .buildConfigurationUnknown
      case 1: self = .platformMappingEvaluationFailure
      case 2: self = .platformMappingsFileIsDirectory
      case 3: self = .platformMappingsFileNotFound
      case 4: self = .topLevelConfigurationCreationFailure
      case 5: self = .invalidConfiguration
      case 6: self = .invalidBuildOptions
      case 7: self = .multiCpuPrereqUnmet
      case 8: self = .heuristicInstrumentationFilterInvalid
      case 9: self = .cycle
      case 10: self = .conflictingConfigurations
      case 11: self = .invalidOutputDirectoryMnemonic
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .buildConfigurationUnknown: return 0
      case .platformMappingEvaluationFailure: return 1
      case .platformMappingsFileIsDirectory: return 2
      case .platformMappingsFileNotFound: return 3
      case .topLevelConfigurationCreationFailure: return 4
      case .invalidConfiguration: return 5
      case .invalidBuildOptions: return 6
      case .multiCpuPrereqUnmet: return 7
      case .heuristicInstrumentationFilterInvalid: return 8
      case .cycle: return 9
      case .conflictingConfigurations: return 10
      case .invalidOutputDirectoryMnemonic: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_BuildConfiguration.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_BuildConfiguration.Code] = [
    .buildConfigurationUnknown,
    .platformMappingEvaluationFailure,
    .platformMappingsFileIsDirectory,
    .platformMappingsFileNotFound,
    .topLevelConfigurationCreationFailure,
    .invalidConfiguration,
    .invalidBuildOptions,
    .multiCpuPrereqUnmet,
    .heuristicInstrumentationFilterInvalid,
    .cycle,
    .conflictingConfigurations,
    .invalidOutputDirectoryMnemonic,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_InfoCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_InfoCommand.Code = .infoCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The distinction between a failure to write a single info item and a failure
  /// to write them all seems sketchy. Why do they have different exit codes?
  /// This reflects current Bazel behavior, but deserves more thought.
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case infoCommandUnknown // = 0
    case tooManyKeys // = 1
    case keyNotRecognized // = 2
    case infoBlockWriteFailure // = 3
    case allInfoWriteFailure // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .infoCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .infoCommandUnknown
      case 1: self = .tooManyKeys
      case 2: self = .keyNotRecognized
      case 3: self = .infoBlockWriteFailure
      case 4: self = .allInfoWriteFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .infoCommandUnknown: return 0
      case .tooManyKeys: return 1
      case .keyNotRecognized: return 2
      case .infoBlockWriteFailure: return 3
      case .allInfoWriteFailure: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_InfoCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_InfoCommand.Code] = [
    .infoCommandUnknown,
    .tooManyKeys,
    .keyNotRecognized,
    .infoBlockWriteFailure,
    .allInfoWriteFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_MemoryOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_MemoryOptions.Code = .memoryOptionsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case memoryOptionsUnknown // = 0
    case experimentalOomMoreEagerlyThresholdInvalidValue // = 1
    case experimentalOomMoreEagerlyNoTenuredCollectorsFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .memoryOptionsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .memoryOptionsUnknown
      case 1: self = .experimentalOomMoreEagerlyThresholdInvalidValue
      case 2: self = .experimentalOomMoreEagerlyNoTenuredCollectorsFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .memoryOptionsUnknown: return 0
      case .experimentalOomMoreEagerlyThresholdInvalidValue: return 1
      case .experimentalOomMoreEagerlyNoTenuredCollectorsFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_MemoryOptions.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_MemoryOptions.Code] = [
    .memoryOptionsUnknown,
    .experimentalOomMoreEagerlyThresholdInvalidValue,
    .experimentalOomMoreEagerlyNoTenuredCollectorsFound,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Query {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Query.Code = .queryUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case queryUnknown // = 0
    case queryFileWithCommandLineExpression // = 1
    case queryFileReadFailure // = 2
    case commandLineExpressionMissing // = 3
    case outputFormatInvalid // = 4
    case graphlessPrereqUnmet // = 5
    case queryOutputWriteFailure // = 6
    case queryStdoutFlushFailure // = 13
    case analysisQueryPrereqUnmet // = 14
    case queryResultsFlushFailure // = 15

    /// Deprecated - folded into SYNTAX_ERROR.
    case deprecatedUnclosedQuotationExpressionError // = 16
    case variableNameInvalid // = 17
    case variableUndefined // = 18
    case buildfilesAndLoadfilesCannotUseOutputLocationError // = 19
    case buildFileError // = 20
    case cycle // = 21
    case uniqueSkykeyThresholdExceeded // = 22
    case targetNotInUniverseScope // = 23
    case invalidFullUniverseExpression // = 24
    case universeScopeLimitExceeded // = 25
    case invalidationLimitExceeded // = 26
    case outputFormatPrereqUnmet // = 27
    case argumentsMissing // = 28
    case rbuildfilesFunctionRequiresSkyquery // = 29
    case fullTargetsNotSupported // = 30

    /// Deprecated - folded into SYNTAX_ERROR.
    case deprecatedUnexpectedTokenError // = 31

    /// Deprecated - folded into SYNTAX_ERROR.
    case deprecatedIntegerLiteralMissing // = 32

    /// Deprecated - folded into SYNTAX_ERROR.
    case deprecatedInvalidStartingCharacterError // = 33

    /// Deprecated - folded into SYNTAX_ERROR.
    case deprecatedPrematureEndOfInputError // = 34

    /// Indicates the user specified invalid query syntax.
    case syntaxError // = 35
    case outputFormatterIoException // = 36
    case skyqueryTransitiveTargetError // = 37
    case skyqueryTargetException // = 38
    case invalidLabelInTestSuite // = 39

    /// Indicates any usage of flags that must not be combined.
    case illegalFlagCombination // = 40

    /// Indicates a non-detailed exception that halted a query. This is a
    /// deficiency in Blaze/Bazel and code should be changed to attach a detailed
    /// exit code to this failure mode.
    case nonDetailedError // = 41
    case UNRECOGNIZED(Int)

    public init() {
      self = .queryUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .queryUnknown
      case 1: self = .queryFileWithCommandLineExpression
      case 2: self = .queryFileReadFailure
      case 3: self = .commandLineExpressionMissing
      case 4: self = .outputFormatInvalid
      case 5: self = .graphlessPrereqUnmet
      case 6: self = .queryOutputWriteFailure
      case 13: self = .queryStdoutFlushFailure
      case 14: self = .analysisQueryPrereqUnmet
      case 15: self = .queryResultsFlushFailure
      case 16: self = .deprecatedUnclosedQuotationExpressionError
      case 17: self = .variableNameInvalid
      case 18: self = .variableUndefined
      case 19: self = .buildfilesAndLoadfilesCannotUseOutputLocationError
      case 20: self = .buildFileError
      case 21: self = .cycle
      case 22: self = .uniqueSkykeyThresholdExceeded
      case 23: self = .targetNotInUniverseScope
      case 24: self = .invalidFullUniverseExpression
      case 25: self = .universeScopeLimitExceeded
      case 26: self = .invalidationLimitExceeded
      case 27: self = .outputFormatPrereqUnmet
      case 28: self = .argumentsMissing
      case 29: self = .rbuildfilesFunctionRequiresSkyquery
      case 30: self = .fullTargetsNotSupported
      case 31: self = .deprecatedUnexpectedTokenError
      case 32: self = .deprecatedIntegerLiteralMissing
      case 33: self = .deprecatedInvalidStartingCharacterError
      case 34: self = .deprecatedPrematureEndOfInputError
      case 35: self = .syntaxError
      case 36: self = .outputFormatterIoException
      case 37: self = .skyqueryTransitiveTargetError
      case 38: self = .skyqueryTargetException
      case 39: self = .invalidLabelInTestSuite
      case 40: self = .illegalFlagCombination
      case 41: self = .nonDetailedError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .queryUnknown: return 0
      case .queryFileWithCommandLineExpression: return 1
      case .queryFileReadFailure: return 2
      case .commandLineExpressionMissing: return 3
      case .outputFormatInvalid: return 4
      case .graphlessPrereqUnmet: return 5
      case .queryOutputWriteFailure: return 6
      case .queryStdoutFlushFailure: return 13
      case .analysisQueryPrereqUnmet: return 14
      case .queryResultsFlushFailure: return 15
      case .deprecatedUnclosedQuotationExpressionError: return 16
      case .variableNameInvalid: return 17
      case .variableUndefined: return 18
      case .buildfilesAndLoadfilesCannotUseOutputLocationError: return 19
      case .buildFileError: return 20
      case .cycle: return 21
      case .uniqueSkykeyThresholdExceeded: return 22
      case .targetNotInUniverseScope: return 23
      case .invalidFullUniverseExpression: return 24
      case .universeScopeLimitExceeded: return 25
      case .invalidationLimitExceeded: return 26
      case .outputFormatPrereqUnmet: return 27
      case .argumentsMissing: return 28
      case .rbuildfilesFunctionRequiresSkyquery: return 29
      case .fullTargetsNotSupported: return 30
      case .deprecatedUnexpectedTokenError: return 31
      case .deprecatedIntegerLiteralMissing: return 32
      case .deprecatedInvalidStartingCharacterError: return 33
      case .deprecatedPrematureEndOfInputError: return 34
      case .syntaxError: return 35
      case .outputFormatterIoException: return 36
      case .skyqueryTransitiveTargetError: return 37
      case .skyqueryTargetException: return 38
      case .invalidLabelInTestSuite: return 39
      case .illegalFlagCombination: return 40
      case .nonDetailedError: return 41
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Query.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Query.Code] = [
    .queryUnknown,
    .queryFileWithCommandLineExpression,
    .queryFileReadFailure,
    .commandLineExpressionMissing,
    .outputFormatInvalid,
    .graphlessPrereqUnmet,
    .queryOutputWriteFailure,
    .queryStdoutFlushFailure,
    .analysisQueryPrereqUnmet,
    .queryResultsFlushFailure,
    .deprecatedUnclosedQuotationExpressionError,
    .variableNameInvalid,
    .variableUndefined,
    .buildfilesAndLoadfilesCannotUseOutputLocationError,
    .buildFileError,
    .cycle,
    .uniqueSkykeyThresholdExceeded,
    .targetNotInUniverseScope,
    .invalidFullUniverseExpression,
    .universeScopeLimitExceeded,
    .invalidationLimitExceeded,
    .outputFormatPrereqUnmet,
    .argumentsMissing,
    .rbuildfilesFunctionRequiresSkyquery,
    .fullTargetsNotSupported,
    .deprecatedUnexpectedTokenError,
    .deprecatedIntegerLiteralMissing,
    .deprecatedInvalidStartingCharacterError,
    .deprecatedPrematureEndOfInputError,
    .syntaxError,
    .outputFormatterIoException,
    .skyqueryTransitiveTargetError,
    .skyqueryTargetException,
    .invalidLabelInTestSuite,
    .illegalFlagCombination,
    .nonDetailedError,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_LocalExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_LocalExecution.Code = .localExecutionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case localExecutionUnknown // = 0
    case lockfreeOutputPrereqUnmet // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .localExecutionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .localExecutionUnknown
      case 1: self = .lockfreeOutputPrereqUnmet
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .localExecutionUnknown: return 0
      case .lockfreeOutputPrereqUnmet: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_LocalExecution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_LocalExecution.Code] = [
    .localExecutionUnknown,
    .lockfreeOutputPrereqUnmet,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ActionCache {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ActionCache.Code = .actionCacheUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case actionCacheUnknown // = 0
    case initializationFailure // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .actionCacheUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .actionCacheUnknown
      case 1: self = .initializationFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .actionCacheUnknown: return 0
      case .initializationFailure: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ActionCache.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ActionCache.Code] = [
    .actionCacheUnknown,
    .initializationFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_FetchCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_FetchCommand.Code = .fetchCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case fetchCommandUnknown // = 0
    case expressionMissing // = 1
    case optionsInvalid // = 2
    case queryParseError // = 3
    case queryEvaluationError // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .fetchCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fetchCommandUnknown
      case 1: self = .expressionMissing
      case 2: self = .optionsInvalid
      case 3: self = .queryParseError
      case 4: self = .queryEvaluationError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .fetchCommandUnknown: return 0
      case .expressionMissing: return 1
      case .optionsInvalid: return 2
      case .queryParseError: return 3
      case .queryEvaluationError: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_FetchCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_FetchCommand.Code] = [
    .fetchCommandUnknown,
    .expressionMissing,
    .optionsInvalid,
    .queryParseError,
    .queryEvaluationError,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_SyncCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_SyncCommand.Code = .syncCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case syncCommandUnknown // = 0
    case packageLookupError // = 1
    case workspaceEvaluationError // = 2
    case repositoryFetchErrors // = 3
    case repositoryNameInvalid // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .syncCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .syncCommandUnknown
      case 1: self = .packageLookupError
      case 2: self = .workspaceEvaluationError
      case 3: self = .repositoryFetchErrors
      case 4: self = .repositoryNameInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .syncCommandUnknown: return 0
      case .packageLookupError: return 1
      case .workspaceEvaluationError: return 2
      case .repositoryFetchErrors: return 3
      case .repositoryNameInvalid: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_SyncCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_SyncCommand.Code] = [
    .syncCommandUnknown,
    .packageLookupError,
    .workspaceEvaluationError,
    .repositoryFetchErrors,
    .repositoryNameInvalid,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Sandbox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Sandbox.Code = .sandboxFailureUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sandboxFailureUnknown // = 0
    case initializationFailure // = 1
    case executionIoException // = 2
    case dockerCommandFailure // = 3
    case noDockerImage // = 4
    case dockerImagePreparationFailure // = 5
    case bindMountAnalysisFailure // = 6
    case mountSourceDoesNotExist // = 7
    case mountSourceTargetTypeMismatch // = 8
    case mountTargetDoesNotExist // = 9
    case subprocessStartFailed // = 10
    case forbiddenInput // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .sandboxFailureUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sandboxFailureUnknown
      case 1: self = .initializationFailure
      case 2: self = .executionIoException
      case 3: self = .dockerCommandFailure
      case 4: self = .noDockerImage
      case 5: self = .dockerImagePreparationFailure
      case 6: self = .bindMountAnalysisFailure
      case 7: self = .mountSourceDoesNotExist
      case 8: self = .mountSourceTargetTypeMismatch
      case 9: self = .mountTargetDoesNotExist
      case 10: self = .subprocessStartFailed
      case 11: self = .forbiddenInput
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sandboxFailureUnknown: return 0
      case .initializationFailure: return 1
      case .executionIoException: return 2
      case .dockerCommandFailure: return 3
      case .noDockerImage: return 4
      case .dockerImagePreparationFailure: return 5
      case .bindMountAnalysisFailure: return 6
      case .mountSourceDoesNotExist: return 7
      case .mountSourceTargetTypeMismatch: return 8
      case .mountTargetDoesNotExist: return 9
      case .subprocessStartFailed: return 10
      case .forbiddenInput: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Sandbox.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Sandbox.Code] = [
    .sandboxFailureUnknown,
    .initializationFailure,
    .executionIoException,
    .dockerCommandFailure,
    .noDockerImage,
    .dockerImagePreparationFailure,
    .bindMountAnalysisFailure,
    .mountSourceDoesNotExist,
    .mountSourceTargetTypeMismatch,
    .mountTargetDoesNotExist,
    .subprocessStartFailed,
    .forbiddenInput,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_IncludeScanning {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_IncludeScanning.Code = .includeScanningUnknown

  public var packageLoadingCode: FailureDetails_PackageLoading.Code = .packageLoadingUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case includeScanningUnknown // = 0
    case initializeIncludeHintsError // = 1
    case scanningIoException // = 2
    case includeHintsFileNotInPackage // = 3
    case includeHintsReadFailure // = 4
    case illegalAbsolutePath // = 5

    /// TODO(b/166268889): this code should be deprecated in favor of more finely
    ///  resolved loading-phase codes.
    case packageLoadFailure // = 6
    case userPackageLoadFailure // = 7
    case systemPackageLoadFailure // = 8
    case undifferentiatedPackageLoadFailure // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .includeScanningUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .includeScanningUnknown
      case 1: self = .initializeIncludeHintsError
      case 2: self = .scanningIoException
      case 3: self = .includeHintsFileNotInPackage
      case 4: self = .includeHintsReadFailure
      case 5: self = .illegalAbsolutePath
      case 6: self = .packageLoadFailure
      case 7: self = .userPackageLoadFailure
      case 8: self = .systemPackageLoadFailure
      case 9: self = .undifferentiatedPackageLoadFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .includeScanningUnknown: return 0
      case .initializeIncludeHintsError: return 1
      case .scanningIoException: return 2
      case .includeHintsFileNotInPackage: return 3
      case .includeHintsReadFailure: return 4
      case .illegalAbsolutePath: return 5
      case .packageLoadFailure: return 6
      case .userPackageLoadFailure: return 7
      case .systemPackageLoadFailure: return 8
      case .undifferentiatedPackageLoadFailure: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_IncludeScanning.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_IncludeScanning.Code] = [
    .includeScanningUnknown,
    .initializeIncludeHintsError,
    .scanningIoException,
    .includeHintsFileNotInPackage,
    .includeHintsReadFailure,
    .illegalAbsolutePath,
    .packageLoadFailure,
    .userPackageLoadFailure,
    .systemPackageLoadFailure,
    .undifferentiatedPackageLoadFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_TestCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_TestCommand.Code = .testCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case testCommandUnknown // = 0
    case noTestTargets // = 1
    case testWithNoanalyze // = 2
    case testsFailed // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .testCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .testCommandUnknown
      case 1: self = .noTestTargets
      case 2: self = .testWithNoanalyze
      case 3: self = .testsFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .testCommandUnknown: return 0
      case .noTestTargets: return 1
      case .testWithNoanalyze: return 2
      case .testsFailed: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_TestCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_TestCommand.Code] = [
    .testCommandUnknown,
    .noTestTargets,
    .testWithNoanalyze,
    .testsFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ActionQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ActionQuery.Code = .actionQueryUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// All numerical exit code associations correspond to pre-existing Bazel
  /// behavior. These associations are suspicious:
  /// - COMMAND_LINE_EXPANSION_FAILURE: this is associated with 2, the numerical
  ///     exit code for "bad Bazel command line", but is generated when an
  ///     action's command line fails to expand, which sounds similar but is
  ///     completely different.
  /// - OUTPUT_FAILURE: this is associated with 6, an undocumented exit code.
  /// - INVALID_AQUERY_EXPRESSION: this is associate with 1, which is not
  ///    documented for (a)query.
  /// TODO(b/138456686): Revise these after the (intentionally non-breaking)
  ///  initial rollout of FailureDetail-based encoding.
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case actionQueryUnknown // = 0
    case commandLineExpansionFailure // = 1
    case outputFailure // = 2
    case commandLineExpressionMissing // = 3
    case expressionParseFailure // = 4
    case skyframeStateWithCommandLineExpression // = 5
    case invalidAqueryExpression // = 6
    case skyframeStatePrereqUnmet // = 7
    case aqueryOutputTooBig // = 8
    case illegalPatternSyntax // = 9
    case incorrectArguments // = 10
    case topLevelTargetsWithSkyframeStateNotSupported // = 11
    case skyframeStateAfterExecution // = 12
    case labelsFunctionNotSupported // = 13
    case templateExpansionFailure // = 14
    case UNRECOGNIZED(Int)

    public init() {
      self = .actionQueryUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .actionQueryUnknown
      case 1: self = .commandLineExpansionFailure
      case 2: self = .outputFailure
      case 3: self = .commandLineExpressionMissing
      case 4: self = .expressionParseFailure
      case 5: self = .skyframeStateWithCommandLineExpression
      case 6: self = .invalidAqueryExpression
      case 7: self = .skyframeStatePrereqUnmet
      case 8: self = .aqueryOutputTooBig
      case 9: self = .illegalPatternSyntax
      case 10: self = .incorrectArguments
      case 11: self = .topLevelTargetsWithSkyframeStateNotSupported
      case 12: self = .skyframeStateAfterExecution
      case 13: self = .labelsFunctionNotSupported
      case 14: self = .templateExpansionFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .actionQueryUnknown: return 0
      case .commandLineExpansionFailure: return 1
      case .outputFailure: return 2
      case .commandLineExpressionMissing: return 3
      case .expressionParseFailure: return 4
      case .skyframeStateWithCommandLineExpression: return 5
      case .invalidAqueryExpression: return 6
      case .skyframeStatePrereqUnmet: return 7
      case .aqueryOutputTooBig: return 8
      case .illegalPatternSyntax: return 9
      case .incorrectArguments: return 10
      case .topLevelTargetsWithSkyframeStateNotSupported: return 11
      case .skyframeStateAfterExecution: return 12
      case .labelsFunctionNotSupported: return 13
      case .templateExpansionFailure: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ActionQuery.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ActionQuery.Code] = [
    .actionQueryUnknown,
    .commandLineExpansionFailure,
    .outputFailure,
    .commandLineExpressionMissing,
    .expressionParseFailure,
    .skyframeStateWithCommandLineExpression,
    .invalidAqueryExpression,
    .skyframeStatePrereqUnmet,
    .aqueryOutputTooBig,
    .illegalPatternSyntax,
    .incorrectArguments,
    .topLevelTargetsWithSkyframeStateNotSupported,
    .skyframeStateAfterExecution,
    .labelsFunctionNotSupported,
    .templateExpansionFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_TargetPatterns {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_TargetPatterns.Code = .targetPatternsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case targetPatternsUnknown // = 0
    case targetPatternFileWithCommandLinePattern // = 1
    case targetPatternFileReadFailure // = 2
    case targetPatternParseFailure // = 3
    case packageNotFound // = 4
    case targetFormatInvalid // = 5
    case absoluteTargetPatternInvalid // = 6
    case cannotDetermineTargetFromFilename // = 7
    case labelSyntaxError // = 8
    case targetCannotBeEmptyString // = 9
    case packagePartCannotEndInSlash // = 10
    case cycle // = 11
    case cannotPreloadTarget // = 12
    case targetsMissing // = 13
    case recursiveTargetPatternsNotAllowed // = 14
    case upLevelReferencesNotAllowed // = 15
    case negativeTargetPatternNotAllowed // = 16
    case targetMustBeAFile // = 17
    case dependencyNotFound // = 18
    case packageNameInvalid // = 19
    case UNRECOGNIZED(Int)

    public init() {
      self = .targetPatternsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .targetPatternsUnknown
      case 1: self = .targetPatternFileWithCommandLinePattern
      case 2: self = .targetPatternFileReadFailure
      case 3: self = .targetPatternParseFailure
      case 4: self = .packageNotFound
      case 5: self = .targetFormatInvalid
      case 6: self = .absoluteTargetPatternInvalid
      case 7: self = .cannotDetermineTargetFromFilename
      case 8: self = .labelSyntaxError
      case 9: self = .targetCannotBeEmptyString
      case 10: self = .packagePartCannotEndInSlash
      case 11: self = .cycle
      case 12: self = .cannotPreloadTarget
      case 13: self = .targetsMissing
      case 14: self = .recursiveTargetPatternsNotAllowed
      case 15: self = .upLevelReferencesNotAllowed
      case 16: self = .negativeTargetPatternNotAllowed
      case 17: self = .targetMustBeAFile
      case 18: self = .dependencyNotFound
      case 19: self = .packageNameInvalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .targetPatternsUnknown: return 0
      case .targetPatternFileWithCommandLinePattern: return 1
      case .targetPatternFileReadFailure: return 2
      case .targetPatternParseFailure: return 3
      case .packageNotFound: return 4
      case .targetFormatInvalid: return 5
      case .absoluteTargetPatternInvalid: return 6
      case .cannotDetermineTargetFromFilename: return 7
      case .labelSyntaxError: return 8
      case .targetCannotBeEmptyString: return 9
      case .packagePartCannotEndInSlash: return 10
      case .cycle: return 11
      case .cannotPreloadTarget: return 12
      case .targetsMissing: return 13
      case .recursiveTargetPatternsNotAllowed: return 14
      case .upLevelReferencesNotAllowed: return 15
      case .negativeTargetPatternNotAllowed: return 16
      case .targetMustBeAFile: return 17
      case .dependencyNotFound: return 18
      case .packageNameInvalid: return 19
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_TargetPatterns.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_TargetPatterns.Code] = [
    .targetPatternsUnknown,
    .targetPatternFileWithCommandLinePattern,
    .targetPatternFileReadFailure,
    .targetPatternParseFailure,
    .packageNotFound,
    .targetFormatInvalid,
    .absoluteTargetPatternInvalid,
    .cannotDetermineTargetFromFilename,
    .labelSyntaxError,
    .targetCannotBeEmptyString,
    .packagePartCannotEndInSlash,
    .cycle,
    .cannotPreloadTarget,
    .targetsMissing,
    .recursiveTargetPatternsNotAllowed,
    .upLevelReferencesNotAllowed,
    .negativeTargetPatternNotAllowed,
    .targetMustBeAFile,
    .dependencyNotFound,
    .packageNameInvalid,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CleanCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CleanCommand.Code = .cleanCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case cleanCommandUnknown // = 0
    case outputServiceCleanFailure // = 1
    case actionCacheCleanFailure // = 2
    case outErrCloseFailure // = 3
    case outputBaseDeleteFailure // = 4
    case outputBaseTempMoveFailure // = 5
    case asyncOutputBaseDeleteFailure // = 6
    case execrootDeleteFailure // = 7
    case execrootTempMoveFailure // = 8
    case asyncExecrootDeleteFailure // = 9
    case argumentsNotRecognized // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .cleanCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cleanCommandUnknown
      case 1: self = .outputServiceCleanFailure
      case 2: self = .actionCacheCleanFailure
      case 3: self = .outErrCloseFailure
      case 4: self = .outputBaseDeleteFailure
      case 5: self = .outputBaseTempMoveFailure
      case 6: self = .asyncOutputBaseDeleteFailure
      case 7: self = .execrootDeleteFailure
      case 8: self = .execrootTempMoveFailure
      case 9: self = .asyncExecrootDeleteFailure
      case 10: self = .argumentsNotRecognized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .cleanCommandUnknown: return 0
      case .outputServiceCleanFailure: return 1
      case .actionCacheCleanFailure: return 2
      case .outErrCloseFailure: return 3
      case .outputBaseDeleteFailure: return 4
      case .outputBaseTempMoveFailure: return 5
      case .asyncOutputBaseDeleteFailure: return 6
      case .execrootDeleteFailure: return 7
      case .execrootTempMoveFailure: return 8
      case .asyncExecrootDeleteFailure: return 9
      case .argumentsNotRecognized: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CleanCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CleanCommand.Code] = [
    .cleanCommandUnknown,
    .outputServiceCleanFailure,
    .actionCacheCleanFailure,
    .outErrCloseFailure,
    .outputBaseDeleteFailure,
    .outputBaseTempMoveFailure,
    .asyncOutputBaseDeleteFailure,
    .execrootDeleteFailure,
    .execrootTempMoveFailure,
    .asyncExecrootDeleteFailure,
    .argumentsNotRecognized,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ConfigCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ConfigCommand.Code = .configCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case configCommandUnknown // = 0
    case tooManyConfigIds // = 1
    case configurationNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .configCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .configCommandUnknown
      case 1: self = .tooManyConfigIds
      case 2: self = .configurationNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .configCommandUnknown: return 0
      case .tooManyConfigIds: return 1
      case .configurationNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ConfigCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ConfigCommand.Code] = [
    .configCommandUnknown,
    .tooManyConfigIds,
    .configurationNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ConfigurableQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ConfigurableQuery.Code = .configurableQueryUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case configurableQueryUnknown // = 0
    case commandLineExpressionMissing // = 1
    case expressionParseFailure // = 2
    case filtersNotSupported // = 3
    case buildfilesFunctionNotSupported // = 4
    case siblingsFunctionNotSupported // = 5
    case visibleFunctionNotSupported // = 6
    case attributeMissing // = 7
    case incorrectConfigArgumentError // = 8
    case targetMissing // = 9
    case starlarkSyntaxError // = 10
    case starlarkEvalError // = 11

    /// Indicates failure to correctly define a format function
    case formatFunctionError // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .configurableQueryUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .configurableQueryUnknown
      case 1: self = .commandLineExpressionMissing
      case 2: self = .expressionParseFailure
      case 3: self = .filtersNotSupported
      case 4: self = .buildfilesFunctionNotSupported
      case 5: self = .siblingsFunctionNotSupported
      case 6: self = .visibleFunctionNotSupported
      case 7: self = .attributeMissing
      case 8: self = .incorrectConfigArgumentError
      case 9: self = .targetMissing
      case 10: self = .starlarkSyntaxError
      case 11: self = .starlarkEvalError
      case 12: self = .formatFunctionError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .configurableQueryUnknown: return 0
      case .commandLineExpressionMissing: return 1
      case .expressionParseFailure: return 2
      case .filtersNotSupported: return 3
      case .buildfilesFunctionNotSupported: return 4
      case .siblingsFunctionNotSupported: return 5
      case .visibleFunctionNotSupported: return 6
      case .attributeMissing: return 7
      case .incorrectConfigArgumentError: return 8
      case .targetMissing: return 9
      case .starlarkSyntaxError: return 10
      case .starlarkEvalError: return 11
      case .formatFunctionError: return 12
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ConfigurableQuery.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ConfigurableQuery.Code] = [
    .configurableQueryUnknown,
    .commandLineExpressionMissing,
    .expressionParseFailure,
    .filtersNotSupported,
    .buildfilesFunctionNotSupported,
    .siblingsFunctionNotSupported,
    .visibleFunctionNotSupported,
    .attributeMissing,
    .incorrectConfigArgumentError,
    .targetMissing,
    .starlarkSyntaxError,
    .starlarkEvalError,
    .formatFunctionError,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_DumpCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_DumpCommand.Code = .dumpCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case dumpCommandUnknown // = 0
    case noOutputSpecified // = 1
    case actionCacheDumpFailed // = 2
    case commandLineExpansionFailure // = 3
    case actionGraphDumpFailed // = 4
    case starlarkHeapDumpFailed // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .dumpCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dumpCommandUnknown
      case 1: self = .noOutputSpecified
      case 2: self = .actionCacheDumpFailed
      case 3: self = .commandLineExpansionFailure
      case 4: self = .actionGraphDumpFailed
      case 5: self = .starlarkHeapDumpFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dumpCommandUnknown: return 0
      case .noOutputSpecified: return 1
      case .actionCacheDumpFailed: return 2
      case .commandLineExpansionFailure: return 3
      case .actionGraphDumpFailed: return 4
      case .starlarkHeapDumpFailed: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_DumpCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_DumpCommand.Code] = [
    .dumpCommandUnknown,
    .noOutputSpecified,
    .actionCacheDumpFailed,
    .commandLineExpansionFailure,
    .actionGraphDumpFailed,
    .starlarkHeapDumpFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_HelpCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_HelpCommand.Code = .helpCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case helpCommandUnknown // = 0
    case missingArgument // = 1
    case commandNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .helpCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .helpCommandUnknown
      case 1: self = .missingArgument
      case 2: self = .commandNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .helpCommandUnknown: return 0
      case .missingArgument: return 1
      case .commandNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_HelpCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_HelpCommand.Code] = [
    .helpCommandUnknown,
    .missingArgument,
    .commandNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_MobileInstall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_MobileInstall.Code = .mobileInstallUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case mobileInstallUnknown // = 0
    case classicUnsupported // = 1
    case noTargetSpecified // = 2
    case multipleTargetsSpecified // = 3
    case targetTypeInvalid // = 4
    case nonZeroExit // = 5
    case errorRunningProgram // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .mobileInstallUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mobileInstallUnknown
      case 1: self = .classicUnsupported
      case 2: self = .noTargetSpecified
      case 3: self = .multipleTargetsSpecified
      case 4: self = .targetTypeInvalid
      case 5: self = .nonZeroExit
      case 6: self = .errorRunningProgram
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .mobileInstallUnknown: return 0
      case .classicUnsupported: return 1
      case .noTargetSpecified: return 2
      case .multipleTargetsSpecified: return 3
      case .targetTypeInvalid: return 4
      case .nonZeroExit: return 5
      case .errorRunningProgram: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_MobileInstall.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_MobileInstall.Code] = [
    .mobileInstallUnknown,
    .classicUnsupported,
    .noTargetSpecified,
    .multipleTargetsSpecified,
    .targetTypeInvalid,
    .nonZeroExit,
    .errorRunningProgram,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ProfileCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ProfileCommand.Code = .profileCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case profileCommandUnknown // = 0
    case oldBinaryFormatUnsupported // = 1
    case fileReadFailure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .profileCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .profileCommandUnknown
      case 1: self = .oldBinaryFormatUnsupported
      case 2: self = .fileReadFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .profileCommandUnknown: return 0
      case .oldBinaryFormatUnsupported: return 1
      case .fileReadFailure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ProfileCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ProfileCommand.Code] = [
    .profileCommandUnknown,
    .oldBinaryFormatUnsupported,
    .fileReadFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_RunCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_RunCommand.Code = .runCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case runCommandUnknown // = 0
    case noTargetSpecified // = 1
    case tooManyTargetsSpecified // = 2
    case targetNotExecutable // = 3
    case targetBuiltButPathNotExecutable // = 4
    case targetBuiltButPathValidationFailed // = 5
    case runUnderTargetNotBuilt // = 6
    case runPrereqUnmet // = 7
    case tooManyTestShardsOrRuns // = 8
    case testEnvironmentSetupFailure // = 9
    case commandLineExpansionFailure // = 10
    case noShellSpecified // = 11
    case scriptWriteFailure // = 12
    case runfilesDirectoriesCreationFailure // = 13
    case runfilesSymlinksCreationFailure // = 14
    case testEnvironmentSetupInterrupted // = 15
    case UNRECOGNIZED(Int)

    public init() {
      self = .runCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .runCommandUnknown
      case 1: self = .noTargetSpecified
      case 2: self = .tooManyTargetsSpecified
      case 3: self = .targetNotExecutable
      case 4: self = .targetBuiltButPathNotExecutable
      case 5: self = .targetBuiltButPathValidationFailed
      case 6: self = .runUnderTargetNotBuilt
      case 7: self = .runPrereqUnmet
      case 8: self = .tooManyTestShardsOrRuns
      case 9: self = .testEnvironmentSetupFailure
      case 10: self = .commandLineExpansionFailure
      case 11: self = .noShellSpecified
      case 12: self = .scriptWriteFailure
      case 13: self = .runfilesDirectoriesCreationFailure
      case 14: self = .runfilesSymlinksCreationFailure
      case 15: self = .testEnvironmentSetupInterrupted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .runCommandUnknown: return 0
      case .noTargetSpecified: return 1
      case .tooManyTargetsSpecified: return 2
      case .targetNotExecutable: return 3
      case .targetBuiltButPathNotExecutable: return 4
      case .targetBuiltButPathValidationFailed: return 5
      case .runUnderTargetNotBuilt: return 6
      case .runPrereqUnmet: return 7
      case .tooManyTestShardsOrRuns: return 8
      case .testEnvironmentSetupFailure: return 9
      case .commandLineExpansionFailure: return 10
      case .noShellSpecified: return 11
      case .scriptWriteFailure: return 12
      case .runfilesDirectoriesCreationFailure: return 13
      case .runfilesSymlinksCreationFailure: return 14
      case .testEnvironmentSetupInterrupted: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_RunCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_RunCommand.Code] = [
    .runCommandUnknown,
    .noTargetSpecified,
    .tooManyTargetsSpecified,
    .targetNotExecutable,
    .targetBuiltButPathNotExecutable,
    .targetBuiltButPathValidationFailed,
    .runUnderTargetNotBuilt,
    .runPrereqUnmet,
    .tooManyTestShardsOrRuns,
    .testEnvironmentSetupFailure,
    .commandLineExpansionFailure,
    .noShellSpecified,
    .scriptWriteFailure,
    .runfilesDirectoriesCreationFailure,
    .runfilesSymlinksCreationFailure,
    .testEnvironmentSetupInterrupted,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_VersionCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_VersionCommand.Code = .versionCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case versionCommandUnknown // = 0
    case notAvailable // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .versionCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .versionCommandUnknown
      case 1: self = .notAvailable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .versionCommandUnknown: return 0
      case .notAvailable: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_VersionCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_VersionCommand.Code] = [
    .versionCommandUnknown,
    .notAvailable,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_PrintActionCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_PrintActionCommand.Code = .printActionCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case printActionCommandUnknown // = 0
    case targetNotFound // = 1
    case commandLineExpansionFailure // = 2
    case targetKindUnsupported // = 3
    case actionsNotFound // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .printActionCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .printActionCommandUnknown
      case 1: self = .targetNotFound
      case 2: self = .commandLineExpansionFailure
      case 3: self = .targetKindUnsupported
      case 4: self = .actionsNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .printActionCommandUnknown: return 0
      case .targetNotFound: return 1
      case .commandLineExpansionFailure: return 2
      case .targetKindUnsupported: return 3
      case .actionsNotFound: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_PrintActionCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_PrintActionCommand.Code] = [
    .printActionCommandUnknown,
    .targetNotFound,
    .commandLineExpansionFailure,
    .targetKindUnsupported,
    .actionsNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_WorkspaceStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_WorkspaceStatus.Code = .workspaceStatusUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case workspaceStatusUnknown // = 0
    case nonZeroExit // = 1
    case abnormalTermination // = 2
    case execFailed // = 3
    case parseFailure // = 4
    case validationFailure // = 5
    case contentUpdateIoException // = 6
    case stderrIoException // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .workspaceStatusUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .workspaceStatusUnknown
      case 1: self = .nonZeroExit
      case 2: self = .abnormalTermination
      case 3: self = .execFailed
      case 4: self = .parseFailure
      case 5: self = .validationFailure
      case 6: self = .contentUpdateIoException
      case 7: self = .stderrIoException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .workspaceStatusUnknown: return 0
      case .nonZeroExit: return 1
      case .abnormalTermination: return 2
      case .execFailed: return 3
      case .parseFailure: return 4
      case .validationFailure: return 5
      case .contentUpdateIoException: return 6
      case .stderrIoException: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_WorkspaceStatus.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_WorkspaceStatus.Code] = [
    .workspaceStatusUnknown,
    .nonZeroExit,
    .abnormalTermination,
    .execFailed,
    .parseFailure,
    .validationFailure,
    .contentUpdateIoException,
    .stderrIoException,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_JavaCompile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_JavaCompile.Code = .javaCompileUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case javaCompileUnknown // = 0
    case reducedClasspathFailure // = 1
    case commandLineExpansionFailure // = 2
    case jdepsReadIoException // = 3
    case reducedClasspathFallbackCleanupFailure // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .javaCompileUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .javaCompileUnknown
      case 1: self = .reducedClasspathFailure
      case 2: self = .commandLineExpansionFailure
      case 3: self = .jdepsReadIoException
      case 4: self = .reducedClasspathFallbackCleanupFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .javaCompileUnknown: return 0
      case .reducedClasspathFailure: return 1
      case .commandLineExpansionFailure: return 2
      case .jdepsReadIoException: return 3
      case .reducedClasspathFallbackCleanupFailure: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_JavaCompile.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_JavaCompile.Code] = [
    .javaCompileUnknown,
    .reducedClasspathFailure,
    .commandLineExpansionFailure,
    .jdepsReadIoException,
    .reducedClasspathFallbackCleanupFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ActionRewinding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ActionRewinding.Code = .actionRewindingUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case actionRewindingUnknown // = 0
    case lostInputTooManyTimes // = 1
    case lostInputIsSource // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .actionRewindingUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .actionRewindingUnknown
      case 1: self = .lostInputTooManyTimes
      case 2: self = .lostInputIsSource
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .actionRewindingUnknown: return 0
      case .lostInputTooManyTimes: return 1
      case .lostInputIsSource: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ActionRewinding.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ActionRewinding.Code] = [
    .actionRewindingUnknown,
    .lostInputTooManyTimes,
    .lostInputIsSource,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CppCompile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CppCompile.Code = .cppCompileUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case cppCompileUnknown // = 0
    case findUsedHeadersIoException // = 1
    case copyOutErrFailure // = 2
    case dFileReadFailure // = 3
    case commandGenerationFailure // = 4
    case moduleExpansionTimeout // = 5
    case includePathOutsideExecRoot // = 6
    case fakeCommandGenerationFailure // = 7
    case undeclaredInclusions // = 8
    case dFileParseFailure // = 9
    case coverageNotesCreationFailure // = 10
    case moduleExpansionMissingData // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .cppCompileUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cppCompileUnknown
      case 1: self = .findUsedHeadersIoException
      case 2: self = .copyOutErrFailure
      case 3: self = .dFileReadFailure
      case 4: self = .commandGenerationFailure
      case 5: self = .moduleExpansionTimeout
      case 6: self = .includePathOutsideExecRoot
      case 7: self = .fakeCommandGenerationFailure
      case 8: self = .undeclaredInclusions
      case 9: self = .dFileParseFailure
      case 10: self = .coverageNotesCreationFailure
      case 11: self = .moduleExpansionMissingData
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .cppCompileUnknown: return 0
      case .findUsedHeadersIoException: return 1
      case .copyOutErrFailure: return 2
      case .dFileReadFailure: return 3
      case .commandGenerationFailure: return 4
      case .moduleExpansionTimeout: return 5
      case .includePathOutsideExecRoot: return 6
      case .fakeCommandGenerationFailure: return 7
      case .undeclaredInclusions: return 8
      case .dFileParseFailure: return 9
      case .coverageNotesCreationFailure: return 10
      case .moduleExpansionMissingData: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CppCompile.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CppCompile.Code] = [
    .cppCompileUnknown,
    .findUsedHeadersIoException,
    .copyOutErrFailure,
    .dFileReadFailure,
    .commandGenerationFailure,
    .moduleExpansionTimeout,
    .includePathOutsideExecRoot,
    .fakeCommandGenerationFailure,
    .undeclaredInclusions,
    .dFileParseFailure,
    .coverageNotesCreationFailure,
    .moduleExpansionMissingData,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_StarlarkAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_StarlarkAction.Code = .starlarkActionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case starlarkActionUnknown // = 0
    case unusedInputListReadFailure // = 1
    case unusedInputListFileNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .starlarkActionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .starlarkActionUnknown
      case 1: self = .unusedInputListReadFailure
      case 2: self = .unusedInputListFileNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .starlarkActionUnknown: return 0
      case .unusedInputListReadFailure: return 1
      case .unusedInputListFileNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_StarlarkAction.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_StarlarkAction.Code] = [
    .starlarkActionUnknown,
    .unusedInputListReadFailure,
    .unusedInputListFileNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_NinjaAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_NinjaAction.Code = .ninjaActionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ninjaActionUnknown // = 0
    case invalidDepfileDeclaredDependency // = 1
    case dFileParseFailure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .ninjaActionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ninjaActionUnknown
      case 1: self = .invalidDepfileDeclaredDependency
      case 2: self = .dFileParseFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ninjaActionUnknown: return 0
      case .invalidDepfileDeclaredDependency: return 1
      case .dFileParseFailure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_NinjaAction.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_NinjaAction.Code] = [
    .ninjaActionUnknown,
    .invalidDepfileDeclaredDependency,
    .dFileParseFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_DynamicExecution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_DynamicExecution.Code = .dynamicExecutionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case dynamicExecutionUnknown // = 0
    case xcodeRelatedPrereqUnmet // = 1
    case actionLogMoveFailure // = 2
    case runFailure // = 3
    case noUsableStrategyFound // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .dynamicExecutionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .dynamicExecutionUnknown
      case 1: self = .xcodeRelatedPrereqUnmet
      case 2: self = .actionLogMoveFailure
      case 3: self = .runFailure
      case 4: self = .noUsableStrategyFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .dynamicExecutionUnknown: return 0
      case .xcodeRelatedPrereqUnmet: return 1
      case .actionLogMoveFailure: return 2
      case .runFailure: return 3
      case .noUsableStrategyFound: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_DynamicExecution.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_DynamicExecution.Code] = [
    .dynamicExecutionUnknown,
    .xcodeRelatedPrereqUnmet,
    .actionLogMoveFailure,
    .runFailure,
    .noUsableStrategyFound,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_FailAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_FailAction.Code = .failActionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case failActionUnknown // = 0
    case intentionalFailure // = 1
    case incorrectPythonVersion // = 2
    case proguardSpecsMissing // = 3
    case dynamicLinkingNotSupported // = 4
    case sourceFilesMissing // = 5
    case incorrectToolchain // = 6
    case fragmentClassMissing // = 7
    case cantBuildIncompatibleTarget // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .failActionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .failActionUnknown
      case 1: self = .intentionalFailure
      case 2: self = .incorrectPythonVersion
      case 3: self = .proguardSpecsMissing
      case 4: self = .dynamicLinkingNotSupported
      case 5: self = .sourceFilesMissing
      case 6: self = .incorrectToolchain
      case 7: self = .fragmentClassMissing
      case 10: self = .cantBuildIncompatibleTarget
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .failActionUnknown: return 0
      case .intentionalFailure: return 1
      case .incorrectPythonVersion: return 2
      case .proguardSpecsMissing: return 3
      case .dynamicLinkingNotSupported: return 4
      case .sourceFilesMissing: return 5
      case .incorrectToolchain: return 6
      case .fragmentClassMissing: return 7
      case .cantBuildIncompatibleTarget: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_FailAction.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_FailAction.Code] = [
    .failActionUnknown,
    .intentionalFailure,
    .incorrectPythonVersion,
    .proguardSpecsMissing,
    .dynamicLinkingNotSupported,
    .sourceFilesMissing,
    .incorrectToolchain,
    .fragmentClassMissing,
    .cantBuildIncompatibleTarget,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_SymlinkAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_SymlinkAction.Code = .symlinkActionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case symlinkActionUnknown // = 0
    case executableInputNotFile // = 1
    case executableInputIsNot // = 2
    case executableInputCheckIoException // = 3
    case linkCreationIoException // = 4
    case linkTouchIoException // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .symlinkActionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .symlinkActionUnknown
      case 1: self = .executableInputNotFile
      case 2: self = .executableInputIsNot
      case 3: self = .executableInputCheckIoException
      case 4: self = .linkCreationIoException
      case 5: self = .linkTouchIoException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .symlinkActionUnknown: return 0
      case .executableInputNotFile: return 1
      case .executableInputIsNot: return 2
      case .executableInputCheckIoException: return 3
      case .linkCreationIoException: return 4
      case .linkTouchIoException: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_SymlinkAction.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_SymlinkAction.Code] = [
    .symlinkActionUnknown,
    .executableInputNotFile,
    .executableInputIsNot,
    .executableInputCheckIoException,
    .linkCreationIoException,
    .linkTouchIoException,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_CppLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_CppLink.Code = .cppLinkUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case cppLinkUnknown // = 0
    case commandGenerationFailure // = 1
    case fakeCommandGenerationFailure // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .cppLinkUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .cppLinkUnknown
      case 1: self = .commandGenerationFailure
      case 2: self = .fakeCommandGenerationFailure
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .cppLinkUnknown: return 0
      case .commandGenerationFailure: return 1
      case .fakeCommandGenerationFailure: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_CppLink.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_CppLink.Code] = [
    .cppLinkUnknown,
    .commandGenerationFailure,
    .fakeCommandGenerationFailure,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_LtoAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_LtoAction.Code = .ltoActionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ltoActionUnknown // = 0
    case invalidAbsolutePathInImports // = 1
    case missingBitcodeFiles // = 2
    case importsReadIoException // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .ltoActionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ltoActionUnknown
      case 1: self = .invalidAbsolutePathInImports
      case 2: self = .missingBitcodeFiles
      case 3: self = .importsReadIoException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ltoActionUnknown: return 0
      case .invalidAbsolutePathInImports: return 1
      case .missingBitcodeFiles: return 2
      case .importsReadIoException: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_LtoAction.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_LtoAction.Code] = [
    .ltoActionUnknown,
    .invalidAbsolutePathInImports,
    .missingBitcodeFiles,
    .importsReadIoException,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_TestAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_TestAction.Code = .testActionUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case testActionUnknown // = 0
    case noKeepGoingTestFailure // = 1
    case localTestPrereqUnmet // = 2
    case commandLineExpansionFailure // = 3
    case duplicateCpuTags // = 4
    case invalidCpuTag // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .testActionUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .testActionUnknown
      case 1: self = .noKeepGoingTestFailure
      case 2: self = .localTestPrereqUnmet
      case 3: self = .commandLineExpansionFailure
      case 4: self = .duplicateCpuTags
      case 5: self = .invalidCpuTag
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .testActionUnknown: return 0
      case .noKeepGoingTestFailure: return 1
      case .localTestPrereqUnmet: return 2
      case .commandLineExpansionFailure: return 3
      case .duplicateCpuTags: return 4
      case .invalidCpuTag: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_TestAction.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_TestAction.Code] = [
    .testActionUnknown,
    .noKeepGoingTestFailure,
    .localTestPrereqUnmet,
    .commandLineExpansionFailure,
    .duplicateCpuTags,
    .invalidCpuTag,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Worker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Worker.Code = .workerUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case workerUnknown // = 0
    case multiplexerInstanceRemovalFailure // = 1
    case multiplexerDoesNotExist // = 2
    case noTools // = 3
    case noFlagfile // = 4
    case virtualInputMaterializationFailure // = 5
    case borrowFailure // = 6
    case prefetchFailure // = 7
    case prepareFailure // = 8
    case requestFailure // = 9
    case parseResponseFailure // = 10
    case noResponse // = 11
    case finishFailure // = 12
    case forbiddenInput // = 13
    case UNRECOGNIZED(Int)

    public init() {
      self = .workerUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .workerUnknown
      case 1: self = .multiplexerInstanceRemovalFailure
      case 2: self = .multiplexerDoesNotExist
      case 3: self = .noTools
      case 4: self = .noFlagfile
      case 5: self = .virtualInputMaterializationFailure
      case 6: self = .borrowFailure
      case 7: self = .prefetchFailure
      case 8: self = .prepareFailure
      case 9: self = .requestFailure
      case 10: self = .parseResponseFailure
      case 11: self = .noResponse
      case 12: self = .finishFailure
      case 13: self = .forbiddenInput
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .workerUnknown: return 0
      case .multiplexerInstanceRemovalFailure: return 1
      case .multiplexerDoesNotExist: return 2
      case .noTools: return 3
      case .noFlagfile: return 4
      case .virtualInputMaterializationFailure: return 5
      case .borrowFailure: return 6
      case .prefetchFailure: return 7
      case .prepareFailure: return 8
      case .requestFailure: return 9
      case .parseResponseFailure: return 10
      case .noResponse: return 11
      case .finishFailure: return 12
      case .forbiddenInput: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Worker.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Worker.Code] = [
    .workerUnknown,
    .multiplexerInstanceRemovalFailure,
    .multiplexerDoesNotExist,
    .noTools,
    .noFlagfile,
    .virtualInputMaterializationFailure,
    .borrowFailure,
    .prefetchFailure,
    .prepareFailure,
    .requestFailure,
    .parseResponseFailure,
    .noResponse,
    .finishFailure,
    .forbiddenInput,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Analysis {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Analysis.Code = .analysisUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case analysisUnknown // = 0
    case loadFailure // = 1

    /// TODO(b/138456686): this code should be deprecated in favor of more finely
    ///   resolved loading-phase codes.
    case genericLoadingPhaseFailure // = 2
    case notAllTargetsAnalyzed // = 3
    case cycle // = 4
    case parameterizedTopLevelAspectInvalid // = 5
    case aspectLabelSyntaxError // = 6
    case aspectPrereqUnmet // = 7
    case aspectNotFound // = 8
    case actionConflict // = 9
    case artifactPrefixConflict // = 10
    case unexpectedAnalysisException // = 11
    case targetsMissingEnvironments // = 12
    case invalidEnvironment // = 13
    case environmentMissingFromGroups // = 14
    case execGroupMissing // = 15
    case invalidExecutionPlatform // = 16
    case aspectCreationFailed // = 17
    case configuredValueCreationFailed // = 18
    case incompatibleTargetRequested // = 19
    case analysisFailurePropagationFailed // = 20
    case UNRECOGNIZED(Int)

    public init() {
      self = .analysisUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .analysisUnknown
      case 1: self = .loadFailure
      case 2: self = .genericLoadingPhaseFailure
      case 3: self = .notAllTargetsAnalyzed
      case 4: self = .cycle
      case 5: self = .parameterizedTopLevelAspectInvalid
      case 6: self = .aspectLabelSyntaxError
      case 7: self = .aspectPrereqUnmet
      case 8: self = .aspectNotFound
      case 9: self = .actionConflict
      case 10: self = .artifactPrefixConflict
      case 11: self = .unexpectedAnalysisException
      case 12: self = .targetsMissingEnvironments
      case 13: self = .invalidEnvironment
      case 14: self = .environmentMissingFromGroups
      case 15: self = .execGroupMissing
      case 16: self = .invalidExecutionPlatform
      case 17: self = .aspectCreationFailed
      case 18: self = .configuredValueCreationFailed
      case 19: self = .incompatibleTargetRequested
      case 20: self = .analysisFailurePropagationFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .analysisUnknown: return 0
      case .loadFailure: return 1
      case .genericLoadingPhaseFailure: return 2
      case .notAllTargetsAnalyzed: return 3
      case .cycle: return 4
      case .parameterizedTopLevelAspectInvalid: return 5
      case .aspectLabelSyntaxError: return 6
      case .aspectPrereqUnmet: return 7
      case .aspectNotFound: return 8
      case .actionConflict: return 9
      case .artifactPrefixConflict: return 10
      case .unexpectedAnalysisException: return 11
      case .targetsMissingEnvironments: return 12
      case .invalidEnvironment: return 13
      case .environmentMissingFromGroups: return 14
      case .execGroupMissing: return 15
      case .invalidExecutionPlatform: return 16
      case .aspectCreationFailed: return 17
      case .configuredValueCreationFailed: return 18
      case .incompatibleTargetRequested: return 19
      case .analysisFailurePropagationFailed: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Analysis.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Analysis.Code] = [
    .analysisUnknown,
    .loadFailure,
    .genericLoadingPhaseFailure,
    .notAllTargetsAnalyzed,
    .cycle,
    .parameterizedTopLevelAspectInvalid,
    .aspectLabelSyntaxError,
    .aspectPrereqUnmet,
    .aspectNotFound,
    .actionConflict,
    .artifactPrefixConflict,
    .unexpectedAnalysisException,
    .targetsMissingEnvironments,
    .invalidEnvironment,
    .environmentMissingFromGroups,
    .execGroupMissing,
    .invalidExecutionPlatform,
    .aspectCreationFailed,
    .configuredValueCreationFailed,
    .incompatibleTargetRequested,
    .analysisFailurePropagationFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_PackageLoading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_PackageLoading.Code = .packageLoadingUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case packageLoadingUnknown // = 0
    case workspaceFileError // = 1
    case maxComputationStepsExceeded // = 2
    case buildFileMissing // = 3
    case repositoryMissing // = 4
    case persistentInconsistentFilesystemError // = 5
    case transientInconsistentFilesystemError // = 6
    case invalidName // = 7
    case evalGlobsSymlinkError // = 9
    case importStarlarkFileError // = 10
    case packageMissing // = 11
    case targetMissing // = 12
    case noSuchThing // = 13
    case globIoException // = 14
    case duplicateLabel // = 15
    case invalidPackageSpecification // = 16
    case syntaxError // = 17
    case environmentInDifferentPackage // = 18
    case defaultEnvironmentUndeclared // = 19
    case environmentInMultipleGroups // = 20
    case environmentDoesNotExist // = 21
    case environmentInvalid // = 22
    case environmentNotInGroup // = 23
    case packageNameInvalid // = 24
    case starlarkEvalError // = 25
    case licenseParseFailure // = 26
    case distributionsParseFailure // = 27
    case labelCrossesPackageBoundary // = 28

    /// Failure while evaluating or applying @_builtins injection. Since the
    /// builtins .bzl files are always packaged with Blaze in production, a
    /// failure here generally indicates a bug in Blaze.
    case builtinsInjectionFailure // = 29
    case symlinkCycleOrInfiniteExpansion // = 30
    case otherIoException // = 31
    case UNRECOGNIZED(Int)

    public init() {
      self = .packageLoadingUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .packageLoadingUnknown
      case 1: self = .workspaceFileError
      case 2: self = .maxComputationStepsExceeded
      case 3: self = .buildFileMissing
      case 4: self = .repositoryMissing
      case 5: self = .persistentInconsistentFilesystemError
      case 6: self = .transientInconsistentFilesystemError
      case 7: self = .invalidName
      case 9: self = .evalGlobsSymlinkError
      case 10: self = .importStarlarkFileError
      case 11: self = .packageMissing
      case 12: self = .targetMissing
      case 13: self = .noSuchThing
      case 14: self = .globIoException
      case 15: self = .duplicateLabel
      case 16: self = .invalidPackageSpecification
      case 17: self = .syntaxError
      case 18: self = .environmentInDifferentPackage
      case 19: self = .defaultEnvironmentUndeclared
      case 20: self = .environmentInMultipleGroups
      case 21: self = .environmentDoesNotExist
      case 22: self = .environmentInvalid
      case 23: self = .environmentNotInGroup
      case 24: self = .packageNameInvalid
      case 25: self = .starlarkEvalError
      case 26: self = .licenseParseFailure
      case 27: self = .distributionsParseFailure
      case 28: self = .labelCrossesPackageBoundary
      case 29: self = .builtinsInjectionFailure
      case 30: self = .symlinkCycleOrInfiniteExpansion
      case 31: self = .otherIoException
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .packageLoadingUnknown: return 0
      case .workspaceFileError: return 1
      case .maxComputationStepsExceeded: return 2
      case .buildFileMissing: return 3
      case .repositoryMissing: return 4
      case .persistentInconsistentFilesystemError: return 5
      case .transientInconsistentFilesystemError: return 6
      case .invalidName: return 7
      case .evalGlobsSymlinkError: return 9
      case .importStarlarkFileError: return 10
      case .packageMissing: return 11
      case .targetMissing: return 12
      case .noSuchThing: return 13
      case .globIoException: return 14
      case .duplicateLabel: return 15
      case .invalidPackageSpecification: return 16
      case .syntaxError: return 17
      case .environmentInDifferentPackage: return 18
      case .defaultEnvironmentUndeclared: return 19
      case .environmentInMultipleGroups: return 20
      case .environmentDoesNotExist: return 21
      case .environmentInvalid: return 22
      case .environmentNotInGroup: return 23
      case .packageNameInvalid: return 24
      case .starlarkEvalError: return 25
      case .licenseParseFailure: return 26
      case .distributionsParseFailure: return 27
      case .labelCrossesPackageBoundary: return 28
      case .builtinsInjectionFailure: return 29
      case .symlinkCycleOrInfiniteExpansion: return 30
      case .otherIoException: return 31
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_PackageLoading.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_PackageLoading.Code] = [
    .packageLoadingUnknown,
    .workspaceFileError,
    .maxComputationStepsExceeded,
    .buildFileMissing,
    .repositoryMissing,
    .persistentInconsistentFilesystemError,
    .transientInconsistentFilesystemError,
    .invalidName,
    .evalGlobsSymlinkError,
    .importStarlarkFileError,
    .packageMissing,
    .targetMissing,
    .noSuchThing,
    .globIoException,
    .duplicateLabel,
    .invalidPackageSpecification,
    .syntaxError,
    .environmentInDifferentPackage,
    .defaultEnvironmentUndeclared,
    .environmentInMultipleGroups,
    .environmentDoesNotExist,
    .environmentInvalid,
    .environmentNotInGroup,
    .packageNameInvalid,
    .starlarkEvalError,
    .licenseParseFailure,
    .distributionsParseFailure,
    .labelCrossesPackageBoundary,
    .builtinsInjectionFailure,
    .symlinkCycleOrInfiniteExpansion,
    .otherIoException,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_Toolchain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_Toolchain.Code = .toolchainUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case toolchainUnknown // = 0
    case missingProvider // = 1
    case invalidConstraintValue // = 2
    case invalidPlatformValue // = 3
    case invalidToolchain // = 4
    case noMatchingExecutionPlatform // = 5
    case noMatchingToolchain // = 6
    case invalidToolchainType // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .toolchainUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .toolchainUnknown
      case 1: self = .missingProvider
      case 2: self = .invalidConstraintValue
      case 3: self = .invalidPlatformValue
      case 4: self = .invalidToolchain
      case 5: self = .noMatchingExecutionPlatform
      case 6: self = .noMatchingToolchain
      case 7: self = .invalidToolchainType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .toolchainUnknown: return 0
      case .missingProvider: return 1
      case .invalidConstraintValue: return 2
      case .invalidPlatformValue: return 3
      case .invalidToolchain: return 4
      case .noMatchingExecutionPlatform: return 5
      case .noMatchingToolchain: return 6
      case .invalidToolchainType: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_Toolchain.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_Toolchain.Code] = [
    .toolchainUnknown,
    .missingProvider,
    .invalidConstraintValue,
    .invalidPlatformValue,
    .invalidToolchain,
    .noMatchingExecutionPlatform,
    .noMatchingToolchain,
    .invalidToolchainType,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_StarlarkLoading {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_StarlarkLoading.Code = .starlarkLoadingUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case starlarkLoadingUnknown // = 0
    case cycle // = 1
    case compileError // = 2
    case parseError // = 3
    case evalError // = 4
    case containingPackageNotFound // = 5
    case packageNotFound // = 6
    case ioError // = 7
    case labelCrossesPackageBoundary // = 8
    case builtinsError // = 9
    case visibilityError // = 10
    case UNRECOGNIZED(Int)

    public init() {
      self = .starlarkLoadingUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .starlarkLoadingUnknown
      case 1: self = .cycle
      case 2: self = .compileError
      case 3: self = .parseError
      case 4: self = .evalError
      case 5: self = .containingPackageNotFound
      case 6: self = .packageNotFound
      case 7: self = .ioError
      case 8: self = .labelCrossesPackageBoundary
      case 9: self = .builtinsError
      case 10: self = .visibilityError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .starlarkLoadingUnknown: return 0
      case .cycle: return 1
      case .compileError: return 2
      case .parseError: return 3
      case .evalError: return 4
      case .containingPackageNotFound: return 5
      case .packageNotFound: return 6
      case .ioError: return 7
      case .labelCrossesPackageBoundary: return 8
      case .builtinsError: return 9
      case .visibilityError: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_StarlarkLoading.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_StarlarkLoading.Code] = [
    .starlarkLoadingUnknown,
    .cycle,
    .compileError,
    .parseError,
    .evalError,
    .containingPackageNotFound,
    .packageNotFound,
    .ioError,
    .labelCrossesPackageBoundary,
    .builtinsError,
    .visibilityError,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ExternalDeps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ExternalDeps.Code = .externalDepsUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case externalDepsUnknown // = 0
    case moduleNotFound // = 1
    case badModule // = 2
    case versionResolutionError // = 3
    case invalidRegistryURL // = 4
    case errorAccessingRegistry // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .externalDepsUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .externalDepsUnknown
      case 1: self = .moduleNotFound
      case 2: self = .badModule
      case 3: self = .versionResolutionError
      case 4: self = .invalidRegistryURL
      case 5: self = .errorAccessingRegistry
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .externalDepsUnknown: return 0
      case .moduleNotFound: return 1
      case .badModule: return 2
      case .versionResolutionError: return 3
      case .invalidRegistryURL: return 4
      case .errorAccessingRegistry: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ExternalDeps.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ExternalDeps.Code] = [
    .externalDepsUnknown,
    .moduleNotFound,
    .badModule,
    .versionResolutionError,
    .invalidRegistryURL,
    .errorAccessingRegistry,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_DiffAwareness {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_DiffAwareness.Code = .diffAwarenessUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case diffAwarenessUnknown // = 0
    case diffStatFailed // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .diffAwarenessUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .diffAwarenessUnknown
      case 1: self = .diffStatFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .diffAwarenessUnknown: return 0
      case .diffStatFailed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_DiffAwareness.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_DiffAwareness.Code] = [
    .diffAwarenessUnknown,
    .diffStatFailed,
  ]
}

#endif  // swift(>=4.2)

public struct FailureDetails_ModqueryCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: FailureDetails_ModqueryCommand.Code = .modqueryCommandUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case modqueryCommandUnknown // = 0
    case missingArguments // = 1
    case tooManyArguments // = 2
    case invalidArguments // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .modqueryCommandUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .modqueryCommandUnknown
      case 1: self = .missingArguments
      case 2: self = .tooManyArguments
      case 3: self = .invalidArguments
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .modqueryCommandUnknown: return 0
      case .missingArguments: return 1
      case .tooManyArguments: return 2
      case .invalidArguments: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension FailureDetails_ModqueryCommand.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [FailureDetails_ModqueryCommand.Code] = [
    .modqueryCommandUnknown,
    .missingArguments,
    .tooManyArguments,
    .invalidArguments,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension FailureDetails_FailureDetailMetadata: @unchecked Sendable {}
extension FailureDetails_FailureDetail: @unchecked Sendable {}
extension FailureDetails_FailureDetail.OneOf_Category: @unchecked Sendable {}
extension FailureDetails_Interrupted: @unchecked Sendable {}
extension FailureDetails_Interrupted.Code: @unchecked Sendable {}
extension FailureDetails_Spawn: @unchecked Sendable {}
extension FailureDetails_Spawn.Code: @unchecked Sendable {}
extension FailureDetails_ExternalRepository: @unchecked Sendable {}
extension FailureDetails_ExternalRepository.Code: @unchecked Sendable {}
extension FailureDetails_BuildProgress: @unchecked Sendable {}
extension FailureDetails_BuildProgress.Code: @unchecked Sendable {}
extension FailureDetails_RemoteOptions: @unchecked Sendable {}
extension FailureDetails_RemoteOptions.Code: @unchecked Sendable {}
extension FailureDetails_ClientEnvironment: @unchecked Sendable {}
extension FailureDetails_ClientEnvironment.Code: @unchecked Sendable {}
extension FailureDetails_Crash: @unchecked Sendable {}
extension FailureDetails_Crash.Code: @unchecked Sendable {}
extension FailureDetails_Throwable: @unchecked Sendable {}
extension FailureDetails_SymlinkForest: @unchecked Sendable {}
extension FailureDetails_SymlinkForest.Code: @unchecked Sendable {}
extension FailureDetails_BuildReport: @unchecked Sendable {}
extension FailureDetails_BuildReport.Code: @unchecked Sendable {}
extension FailureDetails_PackageOptions: @unchecked Sendable {}
extension FailureDetails_PackageOptions.Code: @unchecked Sendable {}
extension FailureDetails_RemoteExecution: @unchecked Sendable {}
extension FailureDetails_RemoteExecution.Code: @unchecked Sendable {}
extension FailureDetails_Execution: @unchecked Sendable {}
extension FailureDetails_Execution.Code: @unchecked Sendable {}
extension FailureDetails_Workspaces: @unchecked Sendable {}
extension FailureDetails_Workspaces.Code: @unchecked Sendable {}
extension FailureDetails_CrashOptions: @unchecked Sendable {}
extension FailureDetails_CrashOptions.Code: @unchecked Sendable {}
extension FailureDetails_Filesystem: @unchecked Sendable {}
extension FailureDetails_Filesystem.Code: @unchecked Sendable {}
extension FailureDetails_ExecutionOptions: @unchecked Sendable {}
extension FailureDetails_ExecutionOptions.Code: @unchecked Sendable {}
extension FailureDetails_Command: @unchecked Sendable {}
extension FailureDetails_Command.Code: @unchecked Sendable {}
extension FailureDetails_GrpcServer: @unchecked Sendable {}
extension FailureDetails_GrpcServer.Code: @unchecked Sendable {}
extension FailureDetails_CanonicalizeFlags: @unchecked Sendable {}
extension FailureDetails_CanonicalizeFlags.Code: @unchecked Sendable {}
extension FailureDetails_BuildConfiguration: @unchecked Sendable {}
extension FailureDetails_BuildConfiguration.Code: @unchecked Sendable {}
extension FailureDetails_InfoCommand: @unchecked Sendable {}
extension FailureDetails_InfoCommand.Code: @unchecked Sendable {}
extension FailureDetails_MemoryOptions: @unchecked Sendable {}
extension FailureDetails_MemoryOptions.Code: @unchecked Sendable {}
extension FailureDetails_Query: @unchecked Sendable {}
extension FailureDetails_Query.Code: @unchecked Sendable {}
extension FailureDetails_LocalExecution: @unchecked Sendable {}
extension FailureDetails_LocalExecution.Code: @unchecked Sendable {}
extension FailureDetails_ActionCache: @unchecked Sendable {}
extension FailureDetails_ActionCache.Code: @unchecked Sendable {}
extension FailureDetails_FetchCommand: @unchecked Sendable {}
extension FailureDetails_FetchCommand.Code: @unchecked Sendable {}
extension FailureDetails_SyncCommand: @unchecked Sendable {}
extension FailureDetails_SyncCommand.Code: @unchecked Sendable {}
extension FailureDetails_Sandbox: @unchecked Sendable {}
extension FailureDetails_Sandbox.Code: @unchecked Sendable {}
extension FailureDetails_IncludeScanning: @unchecked Sendable {}
extension FailureDetails_IncludeScanning.Code: @unchecked Sendable {}
extension FailureDetails_TestCommand: @unchecked Sendable {}
extension FailureDetails_TestCommand.Code: @unchecked Sendable {}
extension FailureDetails_ActionQuery: @unchecked Sendable {}
extension FailureDetails_ActionQuery.Code: @unchecked Sendable {}
extension FailureDetails_TargetPatterns: @unchecked Sendable {}
extension FailureDetails_TargetPatterns.Code: @unchecked Sendable {}
extension FailureDetails_CleanCommand: @unchecked Sendable {}
extension FailureDetails_CleanCommand.Code: @unchecked Sendable {}
extension FailureDetails_ConfigCommand: @unchecked Sendable {}
extension FailureDetails_ConfigCommand.Code: @unchecked Sendable {}
extension FailureDetails_ConfigurableQuery: @unchecked Sendable {}
extension FailureDetails_ConfigurableQuery.Code: @unchecked Sendable {}
extension FailureDetails_DumpCommand: @unchecked Sendable {}
extension FailureDetails_DumpCommand.Code: @unchecked Sendable {}
extension FailureDetails_HelpCommand: @unchecked Sendable {}
extension FailureDetails_HelpCommand.Code: @unchecked Sendable {}
extension FailureDetails_MobileInstall: @unchecked Sendable {}
extension FailureDetails_MobileInstall.Code: @unchecked Sendable {}
extension FailureDetails_ProfileCommand: @unchecked Sendable {}
extension FailureDetails_ProfileCommand.Code: @unchecked Sendable {}
extension FailureDetails_RunCommand: @unchecked Sendable {}
extension FailureDetails_RunCommand.Code: @unchecked Sendable {}
extension FailureDetails_VersionCommand: @unchecked Sendable {}
extension FailureDetails_VersionCommand.Code: @unchecked Sendable {}
extension FailureDetails_PrintActionCommand: @unchecked Sendable {}
extension FailureDetails_PrintActionCommand.Code: @unchecked Sendable {}
extension FailureDetails_WorkspaceStatus: @unchecked Sendable {}
extension FailureDetails_WorkspaceStatus.Code: @unchecked Sendable {}
extension FailureDetails_JavaCompile: @unchecked Sendable {}
extension FailureDetails_JavaCompile.Code: @unchecked Sendable {}
extension FailureDetails_ActionRewinding: @unchecked Sendable {}
extension FailureDetails_ActionRewinding.Code: @unchecked Sendable {}
extension FailureDetails_CppCompile: @unchecked Sendable {}
extension FailureDetails_CppCompile.Code: @unchecked Sendable {}
extension FailureDetails_StarlarkAction: @unchecked Sendable {}
extension FailureDetails_StarlarkAction.Code: @unchecked Sendable {}
extension FailureDetails_NinjaAction: @unchecked Sendable {}
extension FailureDetails_NinjaAction.Code: @unchecked Sendable {}
extension FailureDetails_DynamicExecution: @unchecked Sendable {}
extension FailureDetails_DynamicExecution.Code: @unchecked Sendable {}
extension FailureDetails_FailAction: @unchecked Sendable {}
extension FailureDetails_FailAction.Code: @unchecked Sendable {}
extension FailureDetails_SymlinkAction: @unchecked Sendable {}
extension FailureDetails_SymlinkAction.Code: @unchecked Sendable {}
extension FailureDetails_CppLink: @unchecked Sendable {}
extension FailureDetails_CppLink.Code: @unchecked Sendable {}
extension FailureDetails_LtoAction: @unchecked Sendable {}
extension FailureDetails_LtoAction.Code: @unchecked Sendable {}
extension FailureDetails_TestAction: @unchecked Sendable {}
extension FailureDetails_TestAction.Code: @unchecked Sendable {}
extension FailureDetails_Worker: @unchecked Sendable {}
extension FailureDetails_Worker.Code: @unchecked Sendable {}
extension FailureDetails_Analysis: @unchecked Sendable {}
extension FailureDetails_Analysis.Code: @unchecked Sendable {}
extension FailureDetails_PackageLoading: @unchecked Sendable {}
extension FailureDetails_PackageLoading.Code: @unchecked Sendable {}
extension FailureDetails_Toolchain: @unchecked Sendable {}
extension FailureDetails_Toolchain.Code: @unchecked Sendable {}
extension FailureDetails_StarlarkLoading: @unchecked Sendable {}
extension FailureDetails_StarlarkLoading.Code: @unchecked Sendable {}
extension FailureDetails_ExternalDeps: @unchecked Sendable {}
extension FailureDetails_ExternalDeps.Code: @unchecked Sendable {}
extension FailureDetails_DiffAwareness: @unchecked Sendable {}
extension FailureDetails_DiffAwareness.Code: @unchecked Sendable {}
extension FailureDetails_ModqueryCommand: @unchecked Sendable {}
extension FailureDetails_ModqueryCommand.Code: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Extension support defined in failure_details.proto.

// MARK: - Extension Properties

// Swift Extensions on the exteneded Messages to add easy access to the declared
// extension fields. The names are based on the extension field name from the proto
// declaration. To avoid naming collisions, the names are prefixed with the name of
// the scope where the extend directive occurs.

extension SwiftProtobuf.Google_Protobuf_EnumValueOptions {

  public var FailureDetails_metadata: FailureDetails_FailureDetailMetadata {
    get {return getExtensionValue(ext: FailureDetails_Extensions_metadata) ?? FailureDetails_FailureDetailMetadata()}
    set {setExtensionValue(ext: FailureDetails_Extensions_metadata, value: newValue)}
  }
  /// Returns true if extension `FailureDetails_Extensions_metadata`
  /// has been explicitly set.
  public var hasFailureDetails_metadata: Bool {
    return hasExtensionValue(ext: FailureDetails_Extensions_metadata)
  }
  /// Clears the value of extension `FailureDetails_Extensions_metadata`.
  /// Subsequent reads from it will return its default value.
  public mutating func clearFailureDetails_metadata() {
    clearExtensionValue(ext: FailureDetails_Extensions_metadata)
  }

}

// MARK: - File's ExtensionMap: FailureDetails_FailureDetails_Extensions

/// A `SwiftProtobuf.SimpleExtensionMap` that includes all of the extensions defined by
/// this .proto file. It can be used any place an `SwiftProtobuf.ExtensionMap` is needed
/// in parsing, or it can be combined with other `SwiftProtobuf.SimpleExtensionMap`s to create
/// a larger `SwiftProtobuf.SimpleExtensionMap`.
public let FailureDetails_FailureDetails_Extensions: SwiftProtobuf.SimpleExtensionMap = [
  FailureDetails_Extensions_metadata
]

// Extension Objects - The only reason these might be needed is when manually
// constructing a `SimpleExtensionMap`, otherwise, use the above _Extension Properties_
// accessors for the extension fields on the messages directly.

public let FailureDetails_Extensions_metadata = SwiftProtobuf.MessageExtension<SwiftProtobuf.OptionalMessageExtensionField<FailureDetails_FailureDetailMetadata>, SwiftProtobuf.Google_Protobuf_EnumValueOptions>(
  _protobuf_fieldNumber: 1078,
  fieldName: "failure_details.metadata"
)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "failure_details"

extension FailureDetails_FailureDetailMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailureDetailMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.exitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exitCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.exitCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_FailureDetailMetadata, rhs: FailureDetails_FailureDetailMetadata) -> Bool {
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_FailureDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailureDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    101: .same(proto: "interrupted"),
    103: .standard(proto: "external_repository"),
    104: .standard(proto: "build_progress"),
    106: .standard(proto: "remote_options"),
    107: .standard(proto: "client_environment"),
    108: .same(proto: "crash"),
    110: .standard(proto: "symlink_forest"),
    114: .standard(proto: "package_options"),
    115: .standard(proto: "remote_execution"),
    116: .same(proto: "execution"),
    117: .same(proto: "workspaces"),
    118: .standard(proto: "crash_options"),
    119: .same(proto: "filesystem"),
    121: .standard(proto: "execution_options"),
    122: .same(proto: "command"),
    123: .same(proto: "spawn"),
    124: .standard(proto: "grpc_server"),
    125: .standard(proto: "canonicalize_flags"),
    126: .standard(proto: "build_configuration"),
    127: .standard(proto: "info_command"),
    129: .standard(proto: "memory_options"),
    130: .same(proto: "query"),
    132: .standard(proto: "local_execution"),
    134: .standard(proto: "action_cache"),
    135: .standard(proto: "fetch_command"),
    136: .standard(proto: "sync_command"),
    137: .same(proto: "sandbox"),
    139: .standard(proto: "include_scanning"),
    140: .standard(proto: "test_command"),
    141: .standard(proto: "action_query"),
    142: .standard(proto: "target_patterns"),
    144: .standard(proto: "clean_command"),
    145: .standard(proto: "config_command"),
    146: .standard(proto: "configurable_query"),
    147: .standard(proto: "dump_command"),
    148: .standard(proto: "help_command"),
    150: .standard(proto: "mobile_install"),
    151: .standard(proto: "profile_command"),
    152: .standard(proto: "run_command"),
    153: .standard(proto: "version_command"),
    154: .standard(proto: "print_action_command"),
    158: .standard(proto: "workspace_status"),
    159: .standard(proto: "java_compile"),
    160: .standard(proto: "action_rewinding"),
    161: .standard(proto: "cpp_compile"),
    162: .standard(proto: "starlark_action"),
    163: .standard(proto: "ninja_action"),
    164: .standard(proto: "dynamic_execution"),
    166: .standard(proto: "fail_action"),
    167: .standard(proto: "symlink_action"),
    168: .standard(proto: "cpp_link"),
    169: .standard(proto: "lto_action"),
    172: .standard(proto: "test_action"),
    173: .same(proto: "worker"),
    174: .same(proto: "analysis"),
    175: .standard(proto: "package_loading"),
    177: .same(proto: "toolchain"),
    179: .standard(proto: "starlark_loading"),
    181: .standard(proto: "external_deps"),
    182: .standard(proto: "diff_awareness"),
    183: .standard(proto: "modquery_command"),
    184: .standard(proto: "build_report"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 101: try {
        var v: FailureDetails_Interrupted?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .interrupted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .interrupted(v)
        }
      }()
      case 103: try {
        var v: FailureDetails_ExternalRepository?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .externalRepository(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .externalRepository(v)
        }
      }()
      case 104: try {
        var v: FailureDetails_BuildProgress?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .buildProgress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .buildProgress(v)
        }
      }()
      case 106: try {
        var v: FailureDetails_RemoteOptions?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .remoteOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .remoteOptions(v)
        }
      }()
      case 107: try {
        var v: FailureDetails_ClientEnvironment?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .clientEnvironment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .clientEnvironment(v)
        }
      }()
      case 108: try {
        var v: FailureDetails_Crash?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .crash(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .crash(v)
        }
      }()
      case 110: try {
        var v: FailureDetails_SymlinkForest?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .symlinkForest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .symlinkForest(v)
        }
      }()
      case 114: try {
        var v: FailureDetails_PackageOptions?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .packageOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .packageOptions(v)
        }
      }()
      case 115: try {
        var v: FailureDetails_RemoteExecution?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .remoteExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .remoteExecution(v)
        }
      }()
      case 116: try {
        var v: FailureDetails_Execution?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .execution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .execution(v)
        }
      }()
      case 117: try {
        var v: FailureDetails_Workspaces?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .workspaces(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .workspaces(v)
        }
      }()
      case 118: try {
        var v: FailureDetails_CrashOptions?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .crashOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .crashOptions(v)
        }
      }()
      case 119: try {
        var v: FailureDetails_Filesystem?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .filesystem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .filesystem(v)
        }
      }()
      case 121: try {
        var v: FailureDetails_ExecutionOptions?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .executionOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .executionOptions(v)
        }
      }()
      case 122: try {
        var v: FailureDetails_Command?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .command(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .command(v)
        }
      }()
      case 123: try {
        var v: FailureDetails_Spawn?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .spawn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .spawn(v)
        }
      }()
      case 124: try {
        var v: FailureDetails_GrpcServer?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .grpcServer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .grpcServer(v)
        }
      }()
      case 125: try {
        var v: FailureDetails_CanonicalizeFlags?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .canonicalizeFlags(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .canonicalizeFlags(v)
        }
      }()
      case 126: try {
        var v: FailureDetails_BuildConfiguration?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .buildConfiguration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .buildConfiguration(v)
        }
      }()
      case 127: try {
        var v: FailureDetails_InfoCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .infoCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .infoCommand(v)
        }
      }()
      case 129: try {
        var v: FailureDetails_MemoryOptions?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .memoryOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .memoryOptions(v)
        }
      }()
      case 130: try {
        var v: FailureDetails_Query?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .query(v)
        }
      }()
      case 132: try {
        var v: FailureDetails_LocalExecution?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .localExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .localExecution(v)
        }
      }()
      case 134: try {
        var v: FailureDetails_ActionCache?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .actionCache(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .actionCache(v)
        }
      }()
      case 135: try {
        var v: FailureDetails_FetchCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .fetchCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .fetchCommand(v)
        }
      }()
      case 136: try {
        var v: FailureDetails_SyncCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .syncCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .syncCommand(v)
        }
      }()
      case 137: try {
        var v: FailureDetails_Sandbox?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .sandbox(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .sandbox(v)
        }
      }()
      case 139: try {
        var v: FailureDetails_IncludeScanning?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .includeScanning(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .includeScanning(v)
        }
      }()
      case 140: try {
        var v: FailureDetails_TestCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .testCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .testCommand(v)
        }
      }()
      case 141: try {
        var v: FailureDetails_ActionQuery?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .actionQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .actionQuery(v)
        }
      }()
      case 142: try {
        var v: FailureDetails_TargetPatterns?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .targetPatterns(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .targetPatterns(v)
        }
      }()
      case 144: try {
        var v: FailureDetails_CleanCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .cleanCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .cleanCommand(v)
        }
      }()
      case 145: try {
        var v: FailureDetails_ConfigCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .configCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .configCommand(v)
        }
      }()
      case 146: try {
        var v: FailureDetails_ConfigurableQuery?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .configurableQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .configurableQuery(v)
        }
      }()
      case 147: try {
        var v: FailureDetails_DumpCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .dumpCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .dumpCommand(v)
        }
      }()
      case 148: try {
        var v: FailureDetails_HelpCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .helpCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .helpCommand(v)
        }
      }()
      case 150: try {
        var v: FailureDetails_MobileInstall?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .mobileInstall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .mobileInstall(v)
        }
      }()
      case 151: try {
        var v: FailureDetails_ProfileCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .profileCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .profileCommand(v)
        }
      }()
      case 152: try {
        var v: FailureDetails_RunCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .runCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .runCommand(v)
        }
      }()
      case 153: try {
        var v: FailureDetails_VersionCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .versionCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .versionCommand(v)
        }
      }()
      case 154: try {
        var v: FailureDetails_PrintActionCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .printActionCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .printActionCommand(v)
        }
      }()
      case 158: try {
        var v: FailureDetails_WorkspaceStatus?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .workspaceStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .workspaceStatus(v)
        }
      }()
      case 159: try {
        var v: FailureDetails_JavaCompile?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .javaCompile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .javaCompile(v)
        }
      }()
      case 160: try {
        var v: FailureDetails_ActionRewinding?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .actionRewinding(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .actionRewinding(v)
        }
      }()
      case 161: try {
        var v: FailureDetails_CppCompile?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .cppCompile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .cppCompile(v)
        }
      }()
      case 162: try {
        var v: FailureDetails_StarlarkAction?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .starlarkAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .starlarkAction(v)
        }
      }()
      case 163: try {
        var v: FailureDetails_NinjaAction?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .ninjaAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .ninjaAction(v)
        }
      }()
      case 164: try {
        var v: FailureDetails_DynamicExecution?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .dynamicExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .dynamicExecution(v)
        }
      }()
      case 166: try {
        var v: FailureDetails_FailAction?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .failAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .failAction(v)
        }
      }()
      case 167: try {
        var v: FailureDetails_SymlinkAction?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .symlinkAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .symlinkAction(v)
        }
      }()
      case 168: try {
        var v: FailureDetails_CppLink?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .cppLink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .cppLink(v)
        }
      }()
      case 169: try {
        var v: FailureDetails_LtoAction?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .ltoAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .ltoAction(v)
        }
      }()
      case 172: try {
        var v: FailureDetails_TestAction?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .testAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .testAction(v)
        }
      }()
      case 173: try {
        var v: FailureDetails_Worker?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .worker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .worker(v)
        }
      }()
      case 174: try {
        var v: FailureDetails_Analysis?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .analysis(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .analysis(v)
        }
      }()
      case 175: try {
        var v: FailureDetails_PackageLoading?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .packageLoading(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .packageLoading(v)
        }
      }()
      case 177: try {
        var v: FailureDetails_Toolchain?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .toolchain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .toolchain(v)
        }
      }()
      case 179: try {
        var v: FailureDetails_StarlarkLoading?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .starlarkLoading(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .starlarkLoading(v)
        }
      }()
      case 181: try {
        var v: FailureDetails_ExternalDeps?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .externalDeps(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .externalDeps(v)
        }
      }()
      case 182: try {
        var v: FailureDetails_DiffAwareness?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .diffAwareness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .diffAwareness(v)
        }
      }()
      case 183: try {
        var v: FailureDetails_ModqueryCommand?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .modqueryCommand(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .modqueryCommand(v)
        }
      }()
      case 184: try {
        var v: FailureDetails_BuildReport?
        var hadOneofValue = false
        if let current = self.category {
          hadOneofValue = true
          if case .buildReport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.category = .buildReport(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    switch self.category {
    case .interrupted?: try {
      guard case .interrupted(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .externalRepository?: try {
      guard case .externalRepository(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
    }()
    case .buildProgress?: try {
      guard case .buildProgress(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
    }()
    case .remoteOptions?: try {
      guard case .remoteOptions(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
    }()
    case .clientEnvironment?: try {
      guard case .clientEnvironment(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 107)
    }()
    case .crash?: try {
      guard case .crash(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    }()
    case .symlinkForest?: try {
      guard case .symlinkForest(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
    }()
    case .packageOptions?: try {
      guard case .packageOptions(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 114)
    }()
    case .remoteExecution?: try {
      guard case .remoteExecution(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 115)
    }()
    case .execution?: try {
      guard case .execution(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 116)
    }()
    case .workspaces?: try {
      guard case .workspaces(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 117)
    }()
    case .crashOptions?: try {
      guard case .crashOptions(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 118)
    }()
    case .filesystem?: try {
      guard case .filesystem(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 119)
    }()
    case .executionOptions?: try {
      guard case .executionOptions(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
    }()
    case .command?: try {
      guard case .command(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
    }()
    case .spawn?: try {
      guard case .spawn(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 123)
    }()
    case .grpcServer?: try {
      guard case .grpcServer(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 124)
    }()
    case .canonicalizeFlags?: try {
      guard case .canonicalizeFlags(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 125)
    }()
    case .buildConfiguration?: try {
      guard case .buildConfiguration(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 126)
    }()
    case .infoCommand?: try {
      guard case .infoCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 127)
    }()
    case .memoryOptions?: try {
      guard case .memoryOptions(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 129)
    }()
    case .query?: try {
      guard case .query(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 130)
    }()
    case .localExecution?: try {
      guard case .localExecution(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 132)
    }()
    case .actionCache?: try {
      guard case .actionCache(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 134)
    }()
    case .fetchCommand?: try {
      guard case .fetchCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 135)
    }()
    case .syncCommand?: try {
      guard case .syncCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 136)
    }()
    case .sandbox?: try {
      guard case .sandbox(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 137)
    }()
    case .includeScanning?: try {
      guard case .includeScanning(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 139)
    }()
    case .testCommand?: try {
      guard case .testCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 140)
    }()
    case .actionQuery?: try {
      guard case .actionQuery(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 141)
    }()
    case .targetPatterns?: try {
      guard case .targetPatterns(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 142)
    }()
    case .cleanCommand?: try {
      guard case .cleanCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 144)
    }()
    case .configCommand?: try {
      guard case .configCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 145)
    }()
    case .configurableQuery?: try {
      guard case .configurableQuery(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 146)
    }()
    case .dumpCommand?: try {
      guard case .dumpCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 147)
    }()
    case .helpCommand?: try {
      guard case .helpCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 148)
    }()
    case .mobileInstall?: try {
      guard case .mobileInstall(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 150)
    }()
    case .profileCommand?: try {
      guard case .profileCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 151)
    }()
    case .runCommand?: try {
      guard case .runCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 152)
    }()
    case .versionCommand?: try {
      guard case .versionCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 153)
    }()
    case .printActionCommand?: try {
      guard case .printActionCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 154)
    }()
    case .workspaceStatus?: try {
      guard case .workspaceStatus(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 158)
    }()
    case .javaCompile?: try {
      guard case .javaCompile(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 159)
    }()
    case .actionRewinding?: try {
      guard case .actionRewinding(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 160)
    }()
    case .cppCompile?: try {
      guard case .cppCompile(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 161)
    }()
    case .starlarkAction?: try {
      guard case .starlarkAction(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 162)
    }()
    case .ninjaAction?: try {
      guard case .ninjaAction(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 163)
    }()
    case .dynamicExecution?: try {
      guard case .dynamicExecution(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 164)
    }()
    case .failAction?: try {
      guard case .failAction(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 166)
    }()
    case .symlinkAction?: try {
      guard case .symlinkAction(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 167)
    }()
    case .cppLink?: try {
      guard case .cppLink(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 168)
    }()
    case .ltoAction?: try {
      guard case .ltoAction(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 169)
    }()
    case .testAction?: try {
      guard case .testAction(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 172)
    }()
    case .worker?: try {
      guard case .worker(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 173)
    }()
    case .analysis?: try {
      guard case .analysis(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 174)
    }()
    case .packageLoading?: try {
      guard case .packageLoading(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 175)
    }()
    case .toolchain?: try {
      guard case .toolchain(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 177)
    }()
    case .starlarkLoading?: try {
      guard case .starlarkLoading(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 179)
    }()
    case .externalDeps?: try {
      guard case .externalDeps(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 181)
    }()
    case .diffAwareness?: try {
      guard case .diffAwareness(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 182)
    }()
    case .modqueryCommand?: try {
      guard case .modqueryCommand(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 183)
    }()
    case .buildReport?: try {
      guard case .buildReport(let v)? = self.category else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 184)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_FailureDetail, rhs: FailureDetails_FailureDetail) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Interrupted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Interrupted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .interruptedUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Interrupted, rhs: FailureDetails_Interrupted) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Interrupted.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERRUPTED_UNKNOWN"),
    4: .same(proto: "DEPRECATED_BUILD"),
    5: .same(proto: "DEPRECATED_BUILD_COMPLETION"),
    6: .same(proto: "DEPRECATED_PACKAGE_LOADING_SYNC"),
    7: .same(proto: "DEPRECATED_EXECUTOR_COMPLETION"),
    8: .same(proto: "DEPRECATED_COMMAND_DISPATCH"),
    9: .same(proto: "DEPRECATED_INFO_ITEM"),
    10: .same(proto: "DEPRECATED_AFTER_QUERY"),
    17: .same(proto: "DEPRECATED_FETCH_COMMAND"),
    18: .same(proto: "DEPRECATED_SYNC_COMMAND"),
    20: .same(proto: "DEPRECATED_CLEAN_COMMAND"),
    21: .same(proto: "DEPRECATED_MOBILE_INSTALL_COMMAND"),
    22: .same(proto: "DEPRECATED_QUERY"),
    23: .same(proto: "DEPRECATED_RUN_COMMAND"),
    27: .same(proto: "DEPRECATED_OPTIONS_PARSING"),
    28: .same(proto: "INTERRUPTED"),
  ]
}

extension FailureDetails_Spawn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Spawn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "catastrophic"),
    3: .standard(proto: "spawn_exit_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.catastrophic) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.spawnExitCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .spawnUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if self.catastrophic != false {
      try visitor.visitSingularBoolField(value: self.catastrophic, fieldNumber: 2)
    }
    if self.spawnExitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.spawnExitCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Spawn, rhs: FailureDetails_Spawn) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.catastrophic != rhs.catastrophic {return false}
    if lhs.spawnExitCode != rhs.spawnExitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Spawn.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAWN_UNKNOWN"),
    1: .same(proto: "NON_ZERO_EXIT"),
    2: .same(proto: "TIMEOUT"),
    3: .same(proto: "OUT_OF_MEMORY"),
    4: .same(proto: "EXECUTION_FAILED"),
    5: .same(proto: "EXECUTION_DENIED"),
    6: .same(proto: "REMOTE_CACHE_FAILED"),
    7: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    8: .same(proto: "EXEC_IO_EXCEPTION"),
    9: .same(proto: "INVALID_TIMEOUT"),
    10: .same(proto: "INVALID_REMOTE_EXECUTION_PROPERTIES"),
    11: .same(proto: "NO_USABLE_STRATEGY_FOUND"),
    12: .same(proto: "UNSPECIFIED_EXECUTION_FAILURE"),
    13: .same(proto: "FORBIDDEN_INPUT"),
  ]
}

extension FailureDetails_ExternalRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .externalRepositoryUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ExternalRepository, rhs: FailureDetails_ExternalRepository) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ExternalRepository.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNAL_REPOSITORY_UNKNOWN"),
    1: .same(proto: "OVERRIDE_DISALLOWED_MANAGED_DIRECTORIES"),
    2: .same(proto: "BAD_DOWNLOADER_CONFIG"),
    3: .same(proto: "REPOSITORY_MAPPING_RESOLUTION_FAILED"),
  ]
}

extension FailureDetails_BuildProgress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildProgress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .buildProgressUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_BuildProgress, rhs: FailureDetails_BuildProgress) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_BuildProgress.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILD_PROGRESS_UNKNOWN"),
    3: .same(proto: "OUTPUT_INITIALIZATION"),
    4: .same(proto: "BES_RUNS_PER_TEST_LIMIT_UNSUPPORTED"),
    5: .same(proto: "BES_LOCAL_WRITE_ERROR"),
    6: .same(proto: "BES_INITIALIZATION_ERROR"),
    7: .same(proto: "BES_UPLOAD_TIMEOUT_ERROR"),
    8: .same(proto: "BES_FILE_WRITE_TIMEOUT"),
    9: .same(proto: "BES_FILE_WRITE_IO_ERROR"),
    10: .same(proto: "BES_FILE_WRITE_INTERRUPTED"),
    11: .same(proto: "BES_FILE_WRITE_CANCELED"),
    12: .same(proto: "BES_FILE_WRITE_UNKNOWN_ERROR"),
    13: .same(proto: "BES_UPLOAD_LOCAL_FILE_ERROR"),
    14: .same(proto: "BES_STREAM_NOT_RETRYING_FAILURE"),
    15: .same(proto: "BES_STREAM_COMPLETED_WITH_UNACK_EVENTS_ERROR"),
    16: .same(proto: "BES_STREAM_COMPLETED_WITH_UNSENT_EVENTS_ERROR"),
    17: .same(proto: "BES_UPLOAD_RETRY_LIMIT_EXCEEDED_FAILURE"),
    19: .same(proto: "BES_STREAM_COMPLETED_WITH_REMOTE_ERROR"),
  ]
}

extension FailureDetails_RemoteOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .remoteOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_RemoteOptions, rhs: FailureDetails_RemoteOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_RemoteOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REMOTE_OPTIONS_UNKNOWN"),
    1: .same(proto: "REMOTE_DEFAULT_EXEC_PROPERTIES_LOGIC_ERROR"),
    2: .same(proto: "CREDENTIALS_READ_FAILURE"),
    3: .same(proto: "CREDENTIALS_WRITE_FAILURE"),
    4: .same(proto: "DOWNLOADER_WITHOUT_GRPC_CACHE"),
    5: .same(proto: "EXECUTION_WITH_INVALID_CACHE"),
  ]
}

extension FailureDetails_ClientEnvironment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientEnvironment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .clientEnvironmentUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ClientEnvironment, rhs: FailureDetails_ClientEnvironment) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ClientEnvironment.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLIENT_ENVIRONMENT_UNKNOWN"),
    1: .same(proto: "CLIENT_CWD_MALFORMED"),
  ]
}

extension FailureDetails_Crash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Crash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "causes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.causes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .crashUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.causes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.causes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Crash, rhs: FailureDetails_Crash) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.causes != rhs.causes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Crash.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRASH_UNKNOWN"),
    1: .same(proto: "CRASH_OOM"),
  ]
}

extension FailureDetails_Throwable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Throwable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "throwable_class"),
    2: .same(proto: "message"),
    3: .standard(proto: "stack_trace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.throwableClass) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.stackTrace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.throwableClass.isEmpty {
      try visitor.visitSingularStringField(value: self.throwableClass, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stackTrace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Throwable, rhs: FailureDetails_Throwable) -> Bool {
    if lhs.throwableClass != rhs.throwableClass {return false}
    if lhs.message != rhs.message {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_SymlinkForest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymlinkForest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .symlinkForestUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_SymlinkForest, rhs: FailureDetails_SymlinkForest) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_SymlinkForest.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYMLINK_FOREST_UNKNOWN"),
    1: .same(proto: "TOPLEVEL_OUTDIR_PACKAGE_PATH_CONFLICT"),
    2: .same(proto: "TOPLEVEL_OUTDIR_USED_AS_SOURCE"),
    3: .same(proto: "CREATION_FAILED"),
  ]
}

extension FailureDetails_BuildReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildReport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .buildReportUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_BuildReport, rhs: FailureDetails_BuildReport) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_BuildReport.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILD_REPORT_UNKNOWN"),
    1: .same(proto: "BUILD_REPORT_UPLOADER_NEEDS_PACKAGE_PATHS"),
    2: .same(proto: "BUILD_REPORT_WRITE_FAILED"),
  ]
}

extension FailureDetails_PackageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .packageOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_PackageOptions, rhs: FailureDetails_PackageOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_PackageOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PACKAGE_OPTIONS_UNKNOWN"),
    1: .same(proto: "PACKAGE_PATH_INVALID"),
  ]
}

extension FailureDetails_RemoteExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteExecution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .remoteExecutionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_RemoteExecution, rhs: FailureDetails_RemoteExecution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_RemoteExecution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REMOTE_EXECUTION_UNKNOWN"),
    1: .same(proto: "CAPABILITIES_QUERY_FAILURE"),
    2: .same(proto: "CREDENTIALS_INIT_FAILURE"),
    3: .same(proto: "CACHE_INIT_FAILURE"),
    4: .same(proto: "RPC_LOG_FAILURE"),
    5: .same(proto: "EXEC_CHANNEL_INIT_FAILURE"),
    6: .same(proto: "CACHE_CHANNEL_INIT_FAILURE"),
    7: .same(proto: "DOWNLOADER_CHANNEL_INIT_FAILURE"),
    8: .same(proto: "LOG_DIR_CLEANUP_FAILURE"),
    9: .same(proto: "CLIENT_SERVER_INCOMPATIBLE"),
    10: .same(proto: "DOWNLOADED_INPUTS_DELETION_FAILURE"),
    11: .same(proto: "REMOTE_DOWNLOAD_OUTPUTS_MINIMAL_WITHOUT_INMEMORY_DOTD"),
    12: .same(proto: "REMOTE_DOWNLOAD_OUTPUTS_MINIMAL_WITHOUT_INMEMORY_JDEPS"),
    13: .same(proto: "INCOMPLETE_OUTPUT_DOWNLOAD_CLEANUP_FAILURE"),
    14: .same(proto: "REMOTE_DEFAULT_PLATFORM_PROPERTIES_PARSE_FAILURE"),
    15: .same(proto: "ILLEGAL_OUTPUT"),
    16: .same(proto: "INVALID_EXEC_AND_PLATFORM_PROPERTIES"),
  ]
}

extension FailureDetails_Execution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Execution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .executionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Execution, rhs: FailureDetails_Execution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Execution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXECUTION_UNKNOWN"),
    1: .same(proto: "EXECUTION_LOG_INITIALIZATION_FAILURE"),
    2: .same(proto: "EXECUTION_LOG_WRITE_FAILURE"),
    3: .same(proto: "EXECROOT_CREATION_FAILURE"),
    4: .same(proto: "TEMP_ACTION_OUTPUT_DIRECTORY_DELETION_FAILURE"),
    5: .same(proto: "TEMP_ACTION_OUTPUT_DIRECTORY_CREATION_FAILURE"),
    6: .same(proto: "PERSISTENT_ACTION_OUTPUT_DIRECTORY_CREATION_FAILURE"),
    7: .same(proto: "LOCAL_OUTPUT_DIRECTORY_SYMLINK_FAILURE"),
    9: .same(proto: "LOCAL_TEMPLATE_EXPANSION_FAILURE"),
    10: .same(proto: "INPUT_DIRECTORY_CHECK_IO_EXCEPTION"),
    11: .same(proto: "EXTRA_ACTION_OUTPUT_CREATION_FAILURE"),
    12: .same(proto: "TEST_RUNNER_IO_EXCEPTION"),
    13: .same(proto: "FILE_WRITE_IO_EXCEPTION"),
    14: .same(proto: "TEST_OUT_ERR_IO_EXCEPTION"),
    15: .same(proto: "SYMLINK_TREE_MANIFEST_COPY_IO_EXCEPTION"),
    16: .same(proto: "SYMLINK_TREE_MANIFEST_LINK_IO_EXCEPTION"),
    17: .same(proto: "SYMLINK_TREE_CREATION_IO_EXCEPTION"),
    18: .same(proto: "SYMLINK_TREE_CREATION_COMMAND_EXCEPTION"),
    19: .same(proto: "ACTION_INPUT_READ_IO_EXCEPTION"),
    20: .same(proto: "ACTION_NOT_UP_TO_DATE"),
    21: .same(proto: "PSEUDO_ACTION_EXECUTION_PROHIBITED"),
    22: .same(proto: "DISCOVERED_INPUT_DOES_NOT_EXIST"),
    23: .same(proto: "ACTION_OUTPUTS_DELETION_FAILURE"),
    24: .same(proto: "ACTION_OUTPUTS_NOT_CREATED"),
    25: .same(proto: "ACTION_FINALIZATION_FAILURE"),
    26: .same(proto: "ACTION_INPUT_LOST"),
    27: .same(proto: "FILESYSTEM_CONTEXT_UPDATE_FAILURE"),
    28: .same(proto: "ACTION_OUTPUT_CLOSE_FAILURE"),
    29: .same(proto: "INPUT_DISCOVERY_IO_EXCEPTION"),
    30: .same(proto: "TREE_ARTIFACT_DIRECTORY_CREATION_FAILURE"),
    31: .same(proto: "ACTION_OUTPUT_DIRECTORY_CREATION_FAILURE"),
    32: .same(proto: "ACTION_FS_OUTPUT_DIRECTORY_CREATION_FAILURE"),
    33: .same(proto: "ACTION_FS_OUT_ERR_DIRECTORY_CREATION_FAILURE"),
    34: .same(proto: "NON_ACTION_EXECUTION_FAILURE"),
    35: .same(proto: "CYCLE"),
    36: .same(proto: "SOURCE_INPUT_MISSING"),
    37: .same(proto: "UNEXPECTED_EXCEPTION"),
    39: .same(proto: "SOURCE_INPUT_IO_EXCEPTION"),
  ]
}

extension FailureDetails_Workspaces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Workspaces"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .workspacesUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Workspaces, rhs: FailureDetails_Workspaces) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Workspaces.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKSPACES_UNKNOWN"),
    1: .same(proto: "WORKSPACES_LOG_INITIALIZATION_FAILURE"),
    2: .same(proto: "WORKSPACES_LOG_WRITE_FAILURE"),
    3: .same(proto: "ILLEGAL_WORKSPACE_FILE_SYMLINK_WITH_MANAGED_DIRECTORIES"),
    4: .same(proto: "WORKSPACE_FILE_READ_FAILURE_WITH_MANAGED_DIRECTORIES"),
  ]
}

extension FailureDetails_CrashOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CrashOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .crashOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CrashOptions, rhs: FailureDetails_CrashOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CrashOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRASH_OPTIONS_UNKNOWN"),
  ]
}

extension FailureDetails_Filesystem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filesystem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .filesystemUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Filesystem, rhs: FailureDetails_Filesystem) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Filesystem.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILESYSTEM_UNKNOWN"),
    3: .same(proto: "EMBEDDED_BINARIES_ENUMERATION_FAILURE"),
    4: .same(proto: "SERVER_PID_TXT_FILE_READ_FAILURE"),
    5: .same(proto: "SERVER_FILE_WRITE_FAILURE"),
    6: .same(proto: "DEFAULT_DIGEST_HASH_FUNCTION_INVALID_VALUE"),
  ]
}

extension FailureDetails_ExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutionOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .executionOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ExecutionOptions, rhs: FailureDetails_ExecutionOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ExecutionOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXECUTION_OPTIONS_UNKNOWN"),
    3: .same(proto: "INVALID_STRATEGY"),
    4: .same(proto: "REQUESTED_STRATEGY_INCOMPATIBLE_WITH_SANDBOXING"),
    5: .same(proto: "DEPRECATED_LOCAL_RESOURCES_USED"),
    6: .same(proto: "INVALID_CYCLIC_DYNAMIC_STRATEGY"),
    7: .same(proto: "RESTRICTION_UNMATCHED_TO_ACTION_CONTEXT"),
    8: .same(proto: "REMOTE_FALLBACK_STRATEGY_NOT_ABSTRACT_SPAWN"),
    9: .same(proto: "STRATEGY_NOT_FOUND"),
    10: .same(proto: "DYNAMIC_STRATEGY_NOT_SANDBOXED"),
  ]
}

extension FailureDetails_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Command"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .commandFailureUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Command, rhs: FailureDetails_Command) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Command.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_FAILURE_UNKNOWN"),
    1: .same(proto: "COMMAND_NOT_FOUND"),
    2: .same(proto: "ANOTHER_COMMAND_RUNNING"),
    3: .same(proto: "PREVIOUSLY_SHUTDOWN"),
    4: .same(proto: "STARLARK_CPU_PROFILE_FILE_INITIALIZATION_FAILURE"),
    5: .same(proto: "STARLARK_CPU_PROFILING_INITIALIZATION_FAILURE"),
    6: .same(proto: "STARLARK_CPU_PROFILE_FILE_WRITE_FAILURE"),
    7: .same(proto: "INVOCATION_POLICY_PARSE_FAILURE"),
    8: .same(proto: "INVOCATION_POLICY_INVALID"),
    9: .same(proto: "OPTIONS_PARSE_FAILURE"),
    10: .same(proto: "STARLARK_OPTIONS_PARSE_FAILURE"),
    11: .same(proto: "ARGUMENTS_NOT_RECOGNIZED"),
    12: .same(proto: "NOT_IN_WORKSPACE"),
    13: .same(proto: "SPACES_IN_WORKSPACE_PATH"),
    14: .same(proto: "IN_OUTPUT_DIRECTORY"),
  ]
}

extension FailureDetails_GrpcServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrpcServer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .grpcServerUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_GrpcServer, rhs: FailureDetails_GrpcServer) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_GrpcServer.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRPC_SERVER_UNKNOWN"),
    1: .same(proto: "GRPC_SERVER_NOT_COMPILED_IN"),
    2: .same(proto: "SERVER_BIND_FAILURE"),
    3: .same(proto: "BAD_COOKIE"),
    4: .same(proto: "NO_CLIENT_DESCRIPTION"),
  ]
}

extension FailureDetails_CanonicalizeFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanonicalizeFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .canonicalizeFlagsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CanonicalizeFlags, rhs: FailureDetails_CanonicalizeFlags) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CanonicalizeFlags.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CANONICALIZE_FLAGS_UNKNOWN"),
    1: .same(proto: "FOR_COMMAND_INVALID"),
  ]
}

extension FailureDetails_BuildConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .buildConfigurationUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_BuildConfiguration, rhs: FailureDetails_BuildConfiguration) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_BuildConfiguration.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BUILD_CONFIGURATION_UNKNOWN"),
    1: .same(proto: "PLATFORM_MAPPING_EVALUATION_FAILURE"),
    2: .same(proto: "PLATFORM_MAPPINGS_FILE_IS_DIRECTORY"),
    3: .same(proto: "PLATFORM_MAPPINGS_FILE_NOT_FOUND"),
    4: .same(proto: "TOP_LEVEL_CONFIGURATION_CREATION_FAILURE"),
    5: .same(proto: "INVALID_CONFIGURATION"),
    6: .same(proto: "INVALID_BUILD_OPTIONS"),
    7: .same(proto: "MULTI_CPU_PREREQ_UNMET"),
    8: .same(proto: "HEURISTIC_INSTRUMENTATION_FILTER_INVALID"),
    9: .same(proto: "CYCLE"),
    10: .same(proto: "CONFLICTING_CONFIGURATIONS"),
    11: .same(proto: "INVALID_OUTPUT_DIRECTORY_MNEMONIC"),
  ]
}

extension FailureDetails_InfoCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InfoCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .infoCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_InfoCommand, rhs: FailureDetails_InfoCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_InfoCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO_COMMAND_UNKNOWN"),
    1: .same(proto: "TOO_MANY_KEYS"),
    2: .same(proto: "KEY_NOT_RECOGNIZED"),
    3: .same(proto: "INFO_BLOCK_WRITE_FAILURE"),
    4: .same(proto: "ALL_INFO_WRITE_FAILURE"),
  ]
}

extension FailureDetails_MemoryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemoryOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .memoryOptionsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_MemoryOptions, rhs: FailureDetails_MemoryOptions) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_MemoryOptions.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMORY_OPTIONS_UNKNOWN"),
    1: .same(proto: "EXPERIMENTAL_OOM_MORE_EAGERLY_THRESHOLD_INVALID_VALUE"),
    2: .same(proto: "EXPERIMENTAL_OOM_MORE_EAGERLY_NO_TENURED_COLLECTORS_FOUND"),
  ]
}

extension FailureDetails_Query: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Query"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .queryUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Query, rhs: FailureDetails_Query) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Query.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "QUERY_UNKNOWN"),
    1: .same(proto: "QUERY_FILE_WITH_COMMAND_LINE_EXPRESSION"),
    2: .same(proto: "QUERY_FILE_READ_FAILURE"),
    3: .same(proto: "COMMAND_LINE_EXPRESSION_MISSING"),
    4: .same(proto: "OUTPUT_FORMAT_INVALID"),
    5: .same(proto: "GRAPHLESS_PREREQ_UNMET"),
    6: .same(proto: "QUERY_OUTPUT_WRITE_FAILURE"),
    13: .same(proto: "QUERY_STDOUT_FLUSH_FAILURE"),
    14: .same(proto: "ANALYSIS_QUERY_PREREQ_UNMET"),
    15: .same(proto: "QUERY_RESULTS_FLUSH_FAILURE"),
    16: .same(proto: "DEPRECATED_UNCLOSED_QUOTATION_EXPRESSION_ERROR"),
    17: .same(proto: "VARIABLE_NAME_INVALID"),
    18: .same(proto: "VARIABLE_UNDEFINED"),
    19: .same(proto: "BUILDFILES_AND_LOADFILES_CANNOT_USE_OUTPUT_LOCATION_ERROR"),
    20: .same(proto: "BUILD_FILE_ERROR"),
    21: .same(proto: "CYCLE"),
    22: .same(proto: "UNIQUE_SKYKEY_THRESHOLD_EXCEEDED"),
    23: .same(proto: "TARGET_NOT_IN_UNIVERSE_SCOPE"),
    24: .same(proto: "INVALID_FULL_UNIVERSE_EXPRESSION"),
    25: .same(proto: "UNIVERSE_SCOPE_LIMIT_EXCEEDED"),
    26: .same(proto: "INVALIDATION_LIMIT_EXCEEDED"),
    27: .same(proto: "OUTPUT_FORMAT_PREREQ_UNMET"),
    28: .same(proto: "ARGUMENTS_MISSING"),
    29: .same(proto: "RBUILDFILES_FUNCTION_REQUIRES_SKYQUERY"),
    30: .same(proto: "FULL_TARGETS_NOT_SUPPORTED"),
    31: .same(proto: "DEPRECATED_UNEXPECTED_TOKEN_ERROR"),
    32: .same(proto: "DEPRECATED_INTEGER_LITERAL_MISSING"),
    33: .same(proto: "DEPRECATED_INVALID_STARTING_CHARACTER_ERROR"),
    34: .same(proto: "DEPRECATED_PREMATURE_END_OF_INPUT_ERROR"),
    35: .same(proto: "SYNTAX_ERROR"),
    36: .same(proto: "OUTPUT_FORMATTER_IO_EXCEPTION"),
    37: .same(proto: "SKYQUERY_TRANSITIVE_TARGET_ERROR"),
    38: .same(proto: "SKYQUERY_TARGET_EXCEPTION"),
    39: .same(proto: "INVALID_LABEL_IN_TEST_SUITE"),
    40: .same(proto: "ILLEGAL_FLAG_COMBINATION"),
    41: .same(proto: "NON_DETAILED_ERROR"),
  ]
}

extension FailureDetails_LocalExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalExecution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .localExecutionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_LocalExecution, rhs: FailureDetails_LocalExecution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_LocalExecution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOCAL_EXECUTION_UNKNOWN"),
    1: .same(proto: "LOCKFREE_OUTPUT_PREREQ_UNMET"),
  ]
}

extension FailureDetails_ActionCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionCache"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .actionCacheUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ActionCache, rhs: FailureDetails_ActionCache) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ActionCache.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_CACHE_UNKNOWN"),
    1: .same(proto: "INITIALIZATION_FAILURE"),
  ]
}

extension FailureDetails_FetchCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .fetchCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_FetchCommand, rhs: FailureDetails_FetchCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_FetchCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FETCH_COMMAND_UNKNOWN"),
    1: .same(proto: "EXPRESSION_MISSING"),
    2: .same(proto: "OPTIONS_INVALID"),
    3: .same(proto: "QUERY_PARSE_ERROR"),
    4: .same(proto: "QUERY_EVALUATION_ERROR"),
  ]
}

extension FailureDetails_SyncCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SyncCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .syncCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_SyncCommand, rhs: FailureDetails_SyncCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_SyncCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC_COMMAND_UNKNOWN"),
    1: .same(proto: "PACKAGE_LOOKUP_ERROR"),
    2: .same(proto: "WORKSPACE_EVALUATION_ERROR"),
    3: .same(proto: "REPOSITORY_FETCH_ERRORS"),
    4: .same(proto: "REPOSITORY_NAME_INVALID"),
  ]
}

extension FailureDetails_Sandbox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Sandbox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .sandboxFailureUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Sandbox, rhs: FailureDetails_Sandbox) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Sandbox.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SANDBOX_FAILURE_UNKNOWN"),
    1: .same(proto: "INITIALIZATION_FAILURE"),
    2: .same(proto: "EXECUTION_IO_EXCEPTION"),
    3: .same(proto: "DOCKER_COMMAND_FAILURE"),
    4: .same(proto: "NO_DOCKER_IMAGE"),
    5: .same(proto: "DOCKER_IMAGE_PREPARATION_FAILURE"),
    6: .same(proto: "BIND_MOUNT_ANALYSIS_FAILURE"),
    7: .same(proto: "MOUNT_SOURCE_DOES_NOT_EXIST"),
    8: .same(proto: "MOUNT_SOURCE_TARGET_TYPE_MISMATCH"),
    9: .same(proto: "MOUNT_TARGET_DOES_NOT_EXIST"),
    10: .same(proto: "SUBPROCESS_START_FAILED"),
    11: .same(proto: "FORBIDDEN_INPUT"),
  ]
}

extension FailureDetails_IncludeScanning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncludeScanning"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "package_loading_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.packageLoadingCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .includeScanningUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if self.packageLoadingCode != .packageLoadingUnknown {
      try visitor.visitSingularEnumField(value: self.packageLoadingCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_IncludeScanning, rhs: FailureDetails_IncludeScanning) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.packageLoadingCode != rhs.packageLoadingCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_IncludeScanning.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INCLUDE_SCANNING_UNKNOWN"),
    1: .same(proto: "INITIALIZE_INCLUDE_HINTS_ERROR"),
    2: .same(proto: "SCANNING_IO_EXCEPTION"),
    3: .same(proto: "INCLUDE_HINTS_FILE_NOT_IN_PACKAGE"),
    4: .same(proto: "INCLUDE_HINTS_READ_FAILURE"),
    5: .same(proto: "ILLEGAL_ABSOLUTE_PATH"),
    6: .same(proto: "PACKAGE_LOAD_FAILURE"),
    7: .same(proto: "USER_PACKAGE_LOAD_FAILURE"),
    8: .same(proto: "SYSTEM_PACKAGE_LOAD_FAILURE"),
    9: .same(proto: "UNDIFFERENTIATED_PACKAGE_LOAD_FAILURE"),
  ]
}

extension FailureDetails_TestCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .testCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_TestCommand, rhs: FailureDetails_TestCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_TestCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_COMMAND_UNKNOWN"),
    1: .same(proto: "NO_TEST_TARGETS"),
    2: .same(proto: "TEST_WITH_NOANALYZE"),
    3: .same(proto: "TESTS_FAILED"),
  ]
}

extension FailureDetails_ActionQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .actionQueryUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ActionQuery, rhs: FailureDetails_ActionQuery) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ActionQuery.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_QUERY_UNKNOWN"),
    1: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    2: .same(proto: "OUTPUT_FAILURE"),
    3: .same(proto: "COMMAND_LINE_EXPRESSION_MISSING"),
    4: .same(proto: "EXPRESSION_PARSE_FAILURE"),
    5: .same(proto: "SKYFRAME_STATE_WITH_COMMAND_LINE_EXPRESSION"),
    6: .same(proto: "INVALID_AQUERY_EXPRESSION"),
    7: .same(proto: "SKYFRAME_STATE_PREREQ_UNMET"),
    8: .same(proto: "AQUERY_OUTPUT_TOO_BIG"),
    9: .same(proto: "ILLEGAL_PATTERN_SYNTAX"),
    10: .same(proto: "INCORRECT_ARGUMENTS"),
    11: .same(proto: "TOP_LEVEL_TARGETS_WITH_SKYFRAME_STATE_NOT_SUPPORTED"),
    12: .same(proto: "SKYFRAME_STATE_AFTER_EXECUTION"),
    13: .same(proto: "LABELS_FUNCTION_NOT_SUPPORTED"),
    14: .same(proto: "TEMPLATE_EXPANSION_FAILURE"),
  ]
}

extension FailureDetails_TargetPatterns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetPatterns"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .targetPatternsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_TargetPatterns, rhs: FailureDetails_TargetPatterns) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_TargetPatterns.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TARGET_PATTERNS_UNKNOWN"),
    1: .same(proto: "TARGET_PATTERN_FILE_WITH_COMMAND_LINE_PATTERN"),
    2: .same(proto: "TARGET_PATTERN_FILE_READ_FAILURE"),
    3: .same(proto: "TARGET_PATTERN_PARSE_FAILURE"),
    4: .same(proto: "PACKAGE_NOT_FOUND"),
    5: .same(proto: "TARGET_FORMAT_INVALID"),
    6: .same(proto: "ABSOLUTE_TARGET_PATTERN_INVALID"),
    7: .same(proto: "CANNOT_DETERMINE_TARGET_FROM_FILENAME"),
    8: .same(proto: "LABEL_SYNTAX_ERROR"),
    9: .same(proto: "TARGET_CANNOT_BE_EMPTY_STRING"),
    10: .same(proto: "PACKAGE_PART_CANNOT_END_IN_SLASH"),
    11: .same(proto: "CYCLE"),
    12: .same(proto: "CANNOT_PRELOAD_TARGET"),
    13: .same(proto: "TARGETS_MISSING"),
    14: .same(proto: "RECURSIVE_TARGET_PATTERNS_NOT_ALLOWED"),
    15: .same(proto: "UP_LEVEL_REFERENCES_NOT_ALLOWED"),
    16: .same(proto: "NEGATIVE_TARGET_PATTERN_NOT_ALLOWED"),
    17: .same(proto: "TARGET_MUST_BE_A_FILE"),
    18: .same(proto: "DEPENDENCY_NOT_FOUND"),
    19: .same(proto: "PACKAGE_NAME_INVALID"),
  ]
}

extension FailureDetails_CleanCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CleanCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .cleanCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CleanCommand, rhs: FailureDetails_CleanCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CleanCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLEAN_COMMAND_UNKNOWN"),
    1: .same(proto: "OUTPUT_SERVICE_CLEAN_FAILURE"),
    2: .same(proto: "ACTION_CACHE_CLEAN_FAILURE"),
    3: .same(proto: "OUT_ERR_CLOSE_FAILURE"),
    4: .same(proto: "OUTPUT_BASE_DELETE_FAILURE"),
    5: .same(proto: "OUTPUT_BASE_TEMP_MOVE_FAILURE"),
    6: .same(proto: "ASYNC_OUTPUT_BASE_DELETE_FAILURE"),
    7: .same(proto: "EXECROOT_DELETE_FAILURE"),
    8: .same(proto: "EXECROOT_TEMP_MOVE_FAILURE"),
    9: .same(proto: "ASYNC_EXECROOT_DELETE_FAILURE"),
    10: .same(proto: "ARGUMENTS_NOT_RECOGNIZED"),
  ]
}

extension FailureDetails_ConfigCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .configCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ConfigCommand, rhs: FailureDetails_ConfigCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ConfigCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONFIG_COMMAND_UNKNOWN"),
    1: .same(proto: "TOO_MANY_CONFIG_IDS"),
    2: .same(proto: "CONFIGURATION_NOT_FOUND"),
  ]
}

extension FailureDetails_ConfigurableQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigurableQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .configurableQueryUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ConfigurableQuery, rhs: FailureDetails_ConfigurableQuery) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ConfigurableQuery.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONFIGURABLE_QUERY_UNKNOWN"),
    1: .same(proto: "COMMAND_LINE_EXPRESSION_MISSING"),
    2: .same(proto: "EXPRESSION_PARSE_FAILURE"),
    3: .same(proto: "FILTERS_NOT_SUPPORTED"),
    4: .same(proto: "BUILDFILES_FUNCTION_NOT_SUPPORTED"),
    5: .same(proto: "SIBLINGS_FUNCTION_NOT_SUPPORTED"),
    6: .same(proto: "VISIBLE_FUNCTION_NOT_SUPPORTED"),
    7: .same(proto: "ATTRIBUTE_MISSING"),
    8: .same(proto: "INCORRECT_CONFIG_ARGUMENT_ERROR"),
    9: .same(proto: "TARGET_MISSING"),
    10: .same(proto: "STARLARK_SYNTAX_ERROR"),
    11: .same(proto: "STARLARK_EVAL_ERROR"),
    12: .same(proto: "FORMAT_FUNCTION_ERROR"),
  ]
}

extension FailureDetails_DumpCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DumpCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .dumpCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_DumpCommand, rhs: FailureDetails_DumpCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_DumpCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DUMP_COMMAND_UNKNOWN"),
    1: .same(proto: "NO_OUTPUT_SPECIFIED"),
    2: .same(proto: "ACTION_CACHE_DUMP_FAILED"),
    3: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    4: .same(proto: "ACTION_GRAPH_DUMP_FAILED"),
    5: .same(proto: "STARLARK_HEAP_DUMP_FAILED"),
  ]
}

extension FailureDetails_HelpCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HelpCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .helpCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_HelpCommand, rhs: FailureDetails_HelpCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_HelpCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HELP_COMMAND_UNKNOWN"),
    1: .same(proto: "MISSING_ARGUMENT"),
    2: .same(proto: "COMMAND_NOT_FOUND"),
  ]
}

extension FailureDetails_MobileInstall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MobileInstall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .mobileInstallUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_MobileInstall, rhs: FailureDetails_MobileInstall) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_MobileInstall.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOBILE_INSTALL_UNKNOWN"),
    1: .same(proto: "CLASSIC_UNSUPPORTED"),
    2: .same(proto: "NO_TARGET_SPECIFIED"),
    3: .same(proto: "MULTIPLE_TARGETS_SPECIFIED"),
    4: .same(proto: "TARGET_TYPE_INVALID"),
    5: .same(proto: "NON_ZERO_EXIT"),
    6: .same(proto: "ERROR_RUNNING_PROGRAM"),
  ]
}

extension FailureDetails_ProfileCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .profileCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ProfileCommand, rhs: FailureDetails_ProfileCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ProfileCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROFILE_COMMAND_UNKNOWN"),
    1: .same(proto: "OLD_BINARY_FORMAT_UNSUPPORTED"),
    2: .same(proto: "FILE_READ_FAILURE"),
  ]
}

extension FailureDetails_RunCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .runCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_RunCommand, rhs: FailureDetails_RunCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_RunCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RUN_COMMAND_UNKNOWN"),
    1: .same(proto: "NO_TARGET_SPECIFIED"),
    2: .same(proto: "TOO_MANY_TARGETS_SPECIFIED"),
    3: .same(proto: "TARGET_NOT_EXECUTABLE"),
    4: .same(proto: "TARGET_BUILT_BUT_PATH_NOT_EXECUTABLE"),
    5: .same(proto: "TARGET_BUILT_BUT_PATH_VALIDATION_FAILED"),
    6: .same(proto: "RUN_UNDER_TARGET_NOT_BUILT"),
    7: .same(proto: "RUN_PREREQ_UNMET"),
    8: .same(proto: "TOO_MANY_TEST_SHARDS_OR_RUNS"),
    9: .same(proto: "TEST_ENVIRONMENT_SETUP_FAILURE"),
    10: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    11: .same(proto: "NO_SHELL_SPECIFIED"),
    12: .same(proto: "SCRIPT_WRITE_FAILURE"),
    13: .same(proto: "RUNFILES_DIRECTORIES_CREATION_FAILURE"),
    14: .same(proto: "RUNFILES_SYMLINKS_CREATION_FAILURE"),
    15: .same(proto: "TEST_ENVIRONMENT_SETUP_INTERRUPTED"),
  ]
}

extension FailureDetails_VersionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .versionCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_VersionCommand, rhs: FailureDetails_VersionCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_VersionCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_COMMAND_UNKNOWN"),
    1: .same(proto: "NOT_AVAILABLE"),
  ]
}

extension FailureDetails_PrintActionCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrintActionCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .printActionCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_PrintActionCommand, rhs: FailureDetails_PrintActionCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_PrintActionCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRINT_ACTION_COMMAND_UNKNOWN"),
    1: .same(proto: "TARGET_NOT_FOUND"),
    2: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    3: .same(proto: "TARGET_KIND_UNSUPPORTED"),
    4: .same(proto: "ACTIONS_NOT_FOUND"),
  ]
}

extension FailureDetails_WorkspaceStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .workspaceStatusUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_WorkspaceStatus, rhs: FailureDetails_WorkspaceStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_WorkspaceStatus.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKSPACE_STATUS_UNKNOWN"),
    1: .same(proto: "NON_ZERO_EXIT"),
    2: .same(proto: "ABNORMAL_TERMINATION"),
    3: .same(proto: "EXEC_FAILED"),
    4: .same(proto: "PARSE_FAILURE"),
    5: .same(proto: "VALIDATION_FAILURE"),
    6: .same(proto: "CONTENT_UPDATE_IO_EXCEPTION"),
    7: .same(proto: "STDERR_IO_EXCEPTION"),
  ]
}

extension FailureDetails_JavaCompile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JavaCompile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .javaCompileUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_JavaCompile, rhs: FailureDetails_JavaCompile) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_JavaCompile.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JAVA_COMPILE_UNKNOWN"),
    1: .same(proto: "REDUCED_CLASSPATH_FAILURE"),
    2: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    3: .same(proto: "JDEPS_READ_IO_EXCEPTION"),
    4: .same(proto: "REDUCED_CLASSPATH_FALLBACK_CLEANUP_FAILURE"),
  ]
}

extension FailureDetails_ActionRewinding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionRewinding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .actionRewindingUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ActionRewinding, rhs: FailureDetails_ActionRewinding) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ActionRewinding.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTION_REWINDING_UNKNOWN"),
    1: .same(proto: "LOST_INPUT_TOO_MANY_TIMES"),
    2: .same(proto: "LOST_INPUT_IS_SOURCE"),
  ]
}

extension FailureDetails_CppCompile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CppCompile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .cppCompileUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CppCompile, rhs: FailureDetails_CppCompile) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CppCompile.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CPP_COMPILE_UNKNOWN"),
    1: .same(proto: "FIND_USED_HEADERS_IO_EXCEPTION"),
    2: .same(proto: "COPY_OUT_ERR_FAILURE"),
    3: .same(proto: "D_FILE_READ_FAILURE"),
    4: .same(proto: "COMMAND_GENERATION_FAILURE"),
    5: .same(proto: "MODULE_EXPANSION_TIMEOUT"),
    6: .same(proto: "INCLUDE_PATH_OUTSIDE_EXEC_ROOT"),
    7: .same(proto: "FAKE_COMMAND_GENERATION_FAILURE"),
    8: .same(proto: "UNDECLARED_INCLUSIONS"),
    9: .same(proto: "D_FILE_PARSE_FAILURE"),
    10: .same(proto: "COVERAGE_NOTES_CREATION_FAILURE"),
    11: .same(proto: "MODULE_EXPANSION_MISSING_DATA"),
  ]
}

extension FailureDetails_StarlarkAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StarlarkAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .starlarkActionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_StarlarkAction, rhs: FailureDetails_StarlarkAction) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_StarlarkAction.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STARLARK_ACTION_UNKNOWN"),
    1: .same(proto: "UNUSED_INPUT_LIST_READ_FAILURE"),
    2: .same(proto: "UNUSED_INPUT_LIST_FILE_NOT_FOUND"),
  ]
}

extension FailureDetails_NinjaAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NinjaAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ninjaActionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_NinjaAction, rhs: FailureDetails_NinjaAction) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_NinjaAction.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NINJA_ACTION_UNKNOWN"),
    1: .same(proto: "INVALID_DEPFILE_DECLARED_DEPENDENCY"),
    2: .same(proto: "D_FILE_PARSE_FAILURE"),
  ]
}

extension FailureDetails_DynamicExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicExecution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .dynamicExecutionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_DynamicExecution, rhs: FailureDetails_DynamicExecution) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_DynamicExecution.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DYNAMIC_EXECUTION_UNKNOWN"),
    1: .same(proto: "XCODE_RELATED_PREREQ_UNMET"),
    2: .same(proto: "ACTION_LOG_MOVE_FAILURE"),
    3: .same(proto: "RUN_FAILURE"),
    4: .same(proto: "NO_USABLE_STRATEGY_FOUND"),
  ]
}

extension FailureDetails_FailAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .failActionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_FailAction, rhs: FailureDetails_FailAction) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_FailAction.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FAIL_ACTION_UNKNOWN"),
    1: .same(proto: "INTENTIONAL_FAILURE"),
    2: .same(proto: "INCORRECT_PYTHON_VERSION"),
    3: .same(proto: "PROGUARD_SPECS_MISSING"),
    4: .same(proto: "DYNAMIC_LINKING_NOT_SUPPORTED"),
    5: .same(proto: "SOURCE_FILES_MISSING"),
    6: .same(proto: "INCORRECT_TOOLCHAIN"),
    7: .same(proto: "FRAGMENT_CLASS_MISSING"),
    10: .same(proto: "CANT_BUILD_INCOMPATIBLE_TARGET"),
  ]
}

extension FailureDetails_SymlinkAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SymlinkAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .symlinkActionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_SymlinkAction, rhs: FailureDetails_SymlinkAction) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_SymlinkAction.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYMLINK_ACTION_UNKNOWN"),
    1: .same(proto: "EXECUTABLE_INPUT_NOT_FILE"),
    2: .same(proto: "EXECUTABLE_INPUT_IS_NOT"),
    3: .same(proto: "EXECUTABLE_INPUT_CHECK_IO_EXCEPTION"),
    4: .same(proto: "LINK_CREATION_IO_EXCEPTION"),
    5: .same(proto: "LINK_TOUCH_IO_EXCEPTION"),
  ]
}

extension FailureDetails_CppLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CppLink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .cppLinkUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_CppLink, rhs: FailureDetails_CppLink) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_CppLink.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CPP_LINK_UNKNOWN"),
    1: .same(proto: "COMMAND_GENERATION_FAILURE"),
    2: .same(proto: "FAKE_COMMAND_GENERATION_FAILURE"),
  ]
}

extension FailureDetails_LtoAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LtoAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ltoActionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_LtoAction, rhs: FailureDetails_LtoAction) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_LtoAction.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LTO_ACTION_UNKNOWN"),
    1: .same(proto: "INVALID_ABSOLUTE_PATH_IN_IMPORTS"),
    2: .same(proto: "MISSING_BITCODE_FILES"),
    3: .same(proto: "IMPORTS_READ_IO_EXCEPTION"),
  ]
}

extension FailureDetails_TestAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .testActionUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_TestAction, rhs: FailureDetails_TestAction) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_TestAction.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_ACTION_UNKNOWN"),
    1: .same(proto: "NO_KEEP_GOING_TEST_FAILURE"),
    2: .same(proto: "LOCAL_TEST_PREREQ_UNMET"),
    3: .same(proto: "COMMAND_LINE_EXPANSION_FAILURE"),
    4: .same(proto: "DUPLICATE_CPU_TAGS"),
    5: .same(proto: "INVALID_CPU_TAG"),
  ]
}

extension FailureDetails_Worker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Worker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .workerUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Worker, rhs: FailureDetails_Worker) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Worker.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "WORKER_UNKNOWN"),
    1: .same(proto: "MULTIPLEXER_INSTANCE_REMOVAL_FAILURE"),
    2: .same(proto: "MULTIPLEXER_DOES_NOT_EXIST"),
    3: .same(proto: "NO_TOOLS"),
    4: .same(proto: "NO_FLAGFILE"),
    5: .same(proto: "VIRTUAL_INPUT_MATERIALIZATION_FAILURE"),
    6: .same(proto: "BORROW_FAILURE"),
    7: .same(proto: "PREFETCH_FAILURE"),
    8: .same(proto: "PREPARE_FAILURE"),
    9: .same(proto: "REQUEST_FAILURE"),
    10: .same(proto: "PARSE_RESPONSE_FAILURE"),
    11: .same(proto: "NO_RESPONSE"),
    12: .same(proto: "FINISH_FAILURE"),
    13: .same(proto: "FORBIDDEN_INPUT"),
  ]
}

extension FailureDetails_Analysis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Analysis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .analysisUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Analysis, rhs: FailureDetails_Analysis) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Analysis.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANALYSIS_UNKNOWN"),
    1: .same(proto: "LOAD_FAILURE"),
    2: .same(proto: "GENERIC_LOADING_PHASE_FAILURE"),
    3: .same(proto: "NOT_ALL_TARGETS_ANALYZED"),
    4: .same(proto: "CYCLE"),
    5: .same(proto: "PARAMETERIZED_TOP_LEVEL_ASPECT_INVALID"),
    6: .same(proto: "ASPECT_LABEL_SYNTAX_ERROR"),
    7: .same(proto: "ASPECT_PREREQ_UNMET"),
    8: .same(proto: "ASPECT_NOT_FOUND"),
    9: .same(proto: "ACTION_CONFLICT"),
    10: .same(proto: "ARTIFACT_PREFIX_CONFLICT"),
    11: .same(proto: "UNEXPECTED_ANALYSIS_EXCEPTION"),
    12: .same(proto: "TARGETS_MISSING_ENVIRONMENTS"),
    13: .same(proto: "INVALID_ENVIRONMENT"),
    14: .same(proto: "ENVIRONMENT_MISSING_FROM_GROUPS"),
    15: .same(proto: "EXEC_GROUP_MISSING"),
    16: .same(proto: "INVALID_EXECUTION_PLATFORM"),
    17: .same(proto: "ASPECT_CREATION_FAILED"),
    18: .same(proto: "CONFIGURED_VALUE_CREATION_FAILED"),
    19: .same(proto: "INCOMPATIBLE_TARGET_REQUESTED"),
    20: .same(proto: "ANALYSIS_FAILURE_PROPAGATION_FAILED"),
  ]
}

extension FailureDetails_PackageLoading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageLoading"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .packageLoadingUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_PackageLoading, rhs: FailureDetails_PackageLoading) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_PackageLoading.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PACKAGE_LOADING_UNKNOWN"),
    1: .same(proto: "WORKSPACE_FILE_ERROR"),
    2: .same(proto: "MAX_COMPUTATION_STEPS_EXCEEDED"),
    3: .same(proto: "BUILD_FILE_MISSING"),
    4: .same(proto: "REPOSITORY_MISSING"),
    5: .same(proto: "PERSISTENT_INCONSISTENT_FILESYSTEM_ERROR"),
    6: .same(proto: "TRANSIENT_INCONSISTENT_FILESYSTEM_ERROR"),
    7: .same(proto: "INVALID_NAME"),
    9: .same(proto: "EVAL_GLOBS_SYMLINK_ERROR"),
    10: .same(proto: "IMPORT_STARLARK_FILE_ERROR"),
    11: .same(proto: "PACKAGE_MISSING"),
    12: .same(proto: "TARGET_MISSING"),
    13: .same(proto: "NO_SUCH_THING"),
    14: .same(proto: "GLOB_IO_EXCEPTION"),
    15: .same(proto: "DUPLICATE_LABEL"),
    16: .same(proto: "INVALID_PACKAGE_SPECIFICATION"),
    17: .same(proto: "SYNTAX_ERROR"),
    18: .same(proto: "ENVIRONMENT_IN_DIFFERENT_PACKAGE"),
    19: .same(proto: "DEFAULT_ENVIRONMENT_UNDECLARED"),
    20: .same(proto: "ENVIRONMENT_IN_MULTIPLE_GROUPS"),
    21: .same(proto: "ENVIRONMENT_DOES_NOT_EXIST"),
    22: .same(proto: "ENVIRONMENT_INVALID"),
    23: .same(proto: "ENVIRONMENT_NOT_IN_GROUP"),
    24: .same(proto: "PACKAGE_NAME_INVALID"),
    25: .same(proto: "STARLARK_EVAL_ERROR"),
    26: .same(proto: "LICENSE_PARSE_FAILURE"),
    27: .same(proto: "DISTRIBUTIONS_PARSE_FAILURE"),
    28: .same(proto: "LABEL_CROSSES_PACKAGE_BOUNDARY"),
    29: .same(proto: "BUILTINS_INJECTION_FAILURE"),
    30: .same(proto: "SYMLINK_CYCLE_OR_INFINITE_EXPANSION"),
    31: .same(proto: "OTHER_IO_EXCEPTION"),
  ]
}

extension FailureDetails_Toolchain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Toolchain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .toolchainUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_Toolchain, rhs: FailureDetails_Toolchain) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_Toolchain.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOOLCHAIN_UNKNOWN"),
    1: .same(proto: "MISSING_PROVIDER"),
    2: .same(proto: "INVALID_CONSTRAINT_VALUE"),
    3: .same(proto: "INVALID_PLATFORM_VALUE"),
    4: .same(proto: "INVALID_TOOLCHAIN"),
    5: .same(proto: "NO_MATCHING_EXECUTION_PLATFORM"),
    6: .same(proto: "NO_MATCHING_TOOLCHAIN"),
    7: .same(proto: "INVALID_TOOLCHAIN_TYPE"),
  ]
}

extension FailureDetails_StarlarkLoading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StarlarkLoading"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .starlarkLoadingUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_StarlarkLoading, rhs: FailureDetails_StarlarkLoading) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_StarlarkLoading.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STARLARK_LOADING_UNKNOWN"),
    1: .same(proto: "CYCLE"),
    2: .same(proto: "COMPILE_ERROR"),
    3: .same(proto: "PARSE_ERROR"),
    4: .same(proto: "EVAL_ERROR"),
    5: .same(proto: "CONTAINING_PACKAGE_NOT_FOUND"),
    6: .same(proto: "PACKAGE_NOT_FOUND"),
    7: .same(proto: "IO_ERROR"),
    8: .same(proto: "LABEL_CROSSES_PACKAGE_BOUNDARY"),
    9: .same(proto: "BUILTINS_ERROR"),
    10: .same(proto: "VISIBILITY_ERROR"),
  ]
}

extension FailureDetails_ExternalDeps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalDeps"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .externalDepsUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ExternalDeps, rhs: FailureDetails_ExternalDeps) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ExternalDeps.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXTERNAL_DEPS_UNKNOWN"),
    1: .same(proto: "MODULE_NOT_FOUND"),
    2: .same(proto: "BAD_MODULE"),
    3: .same(proto: "VERSION_RESOLUTION_ERROR"),
    4: .same(proto: "INVALID_REGISTRY_URL"),
    5: .same(proto: "ERROR_ACCESSING_REGISTRY"),
  ]
}

extension FailureDetails_DiffAwareness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiffAwareness"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .diffAwarenessUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_DiffAwareness, rhs: FailureDetails_DiffAwareness) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_DiffAwareness.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIFF_AWARENESS_UNKNOWN"),
    1: .same(proto: "DIFF_STAT_FAILED"),
  ]
}

extension FailureDetails_ModqueryCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModqueryCommand"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .modqueryCommandUnknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FailureDetails_ModqueryCommand, rhs: FailureDetails_ModqueryCommand) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FailureDetails_ModqueryCommand.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODQUERY_COMMAND_UNKNOWN"),
    1: .same(proto: "MISSING_ARGUMENTS"),
    2: .same(proto: "TOO_MANY_ARGUMENTS"),
    3: .same(proto: "INVALID_ARGUMENTS"),
  ]
}
