// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/main/protobuf/build.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2014 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This file contains the protocol buffer representation of a build
// file or 'blaze query --output=proto' call.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct BlazeQuery_License {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var licenseType: [String] = []

  public var exception: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct BlazeQuery_StringDictEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

public struct BlazeQuery_LabelDictUnaryEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

public struct BlazeQuery_LabelListDictEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
}

public struct BlazeQuery_LabelKeyedStringDictEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: String {
    get {return _value ?? String()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
  fileprivate var _value: String? = nil
}

public struct BlazeQuery_StringListDictEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var key: String {
    get {return _key ?? String()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var value: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: String? = nil
}

/// Represents an entry attribute of a Fileset rule in a build file.
public struct BlazeQuery_FilesetEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label pointing to the source target where files are copied from.
  public var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  /// The relative path within the fileset rule where files will be mapped.
  public var destinationDirectory: String {
    get {return _destinationDirectory ?? String()}
    set {_destinationDirectory = newValue}
  }
  /// Returns true if `destinationDirectory` has been explicitly set.
  public var hasDestinationDirectory: Bool {return self._destinationDirectory != nil}
  /// Clears the value of `destinationDirectory`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationDirectory() {self._destinationDirectory = nil}

  /// Whether the files= attribute was specified. This is necessary because
  /// no files= attribute and files=[] mean different things.
  public var filesPresent: Bool {
    get {return _filesPresent ?? false}
    set {_filesPresent = newValue}
  }
  /// Returns true if `filesPresent` has been explicitly set.
  public var hasFilesPresent: Bool {return self._filesPresent != nil}
  /// Clears the value of `filesPresent`. Subsequent reads from it will return its default value.
  public mutating func clearFilesPresent() {self._filesPresent = nil}

  /// A list of file labels to include from the source directory.
  public var file: [String] = []

  /// If this is a fileset entry representing files within the rule
  /// package, this lists relative paths to files that should be excluded from
  /// the set.  This cannot contain values if 'file' also has values.
  public var exclude: [String] = []

  /// This field is optional because there will be some time when the new
  /// PB is used by tools depending on blaze query, but the new blaze version
  /// is not yet released.
  /// TODO(bazel-team): Make this field required once a version of Blaze is
  /// released that outputs this field.
  public var symlinkBehavior: BlazeQuery_FilesetEntry.SymlinkBehavior {
    get {return _symlinkBehavior ?? .copy}
    set {_symlinkBehavior = newValue}
  }
  /// Returns true if `symlinkBehavior` has been explicitly set.
  public var hasSymlinkBehavior: Bool {return self._symlinkBehavior != nil}
  /// Clears the value of `symlinkBehavior`. Subsequent reads from it will return its default value.
  public mutating func clearSymlinkBehavior() {self._symlinkBehavior = nil}

  /// The prefix to strip from the path of the files in this FilesetEntry. Note
  /// that no value and the empty string as the value mean different things here.
  public var stripPrefix: String {
    get {return _stripPrefix ?? String()}
    set {_stripPrefix = newValue}
  }
  /// Returns true if `stripPrefix` has been explicitly set.
  public var hasStripPrefix: Bool {return self._stripPrefix != nil}
  /// Clears the value of `stripPrefix`. Subsequent reads from it will return its default value.
  public mutating func clearStripPrefix() {self._stripPrefix = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates what to do when a source file is actually a symlink.
  public enum SymlinkBehavior: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case copy // = 1
    case dereference // = 2

    public init() {
      self = .copy
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .copy
      case 2: self = .dereference
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .copy: return 1
      case .dereference: return 2
      }
    }

  }

  public init() {}

  fileprivate var _source: String? = nil
  fileprivate var _destinationDirectory: String? = nil
  fileprivate var _filesPresent: Bool? = nil
  fileprivate var _symlinkBehavior: BlazeQuery_FilesetEntry.SymlinkBehavior? = nil
  fileprivate var _stripPrefix: String? = nil
}

#if swift(>=4.2)

extension BlazeQuery_FilesetEntry.SymlinkBehavior: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A rule attribute. Each attribute must have a type and one of the various
/// value fields populated - for the most part.
///
/// Attributes of BOOLEAN and TRISTATE type may set all of the int, bool, and
/// string values for backwards compatibility with clients that expect them to
/// be set.
///
/// Attributes of INTEGER, STRING, LABEL, LICENSE, BOOLEAN, and TRISTATE type
/// may set *none* of the values. This can happen if the Attribute message is
/// prepared for a client that doesn't support SELECTOR_LIST, but the rule has
/// a selector list value for the attribute. (Selector lists for attributes of
/// other types--the collection types--are handled differently when prepared
/// for such a client. The possible collection values are gathered together
/// and flattened.)
///
/// By checking the type, the appropriate value can be extracted - see the
/// comments on each type for the associated value.  The order of lists comes
/// from the blaze parsing. If an attribute is of a list type, the associated
/// list should never be empty.
public struct BlazeQuery_Attribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the attribute
  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  /// Whether the attribute was explicitly specified
  public var explicitlySpecified: Bool {
    get {return _storage._explicitlySpecified ?? false}
    set {_uniqueStorage()._explicitlySpecified = newValue}
  }
  /// Returns true if `explicitlySpecified` has been explicitly set.
  public var hasExplicitlySpecified: Bool {return _storage._explicitlySpecified != nil}
  /// Clears the value of `explicitlySpecified`. Subsequent reads from it will return its default value.
  public mutating func clearExplicitlySpecified() {_uniqueStorage()._explicitlySpecified = nil}

  /// If this attribute has a string value or a string list value, then this
  /// may be set to indicate that the value may be treated as a label that
  /// isn't a dependency of this attribute's rule.
  public var nodep: Bool {
    get {return _storage._nodep ?? false}
    set {_uniqueStorage()._nodep = newValue}
  }
  /// Returns true if `nodep` has been explicitly set.
  public var hasNodep: Bool {return _storage._nodep != nil}
  /// Clears the value of `nodep`. Subsequent reads from it will return its default value.
  public mutating func clearNodep() {_uniqueStorage()._nodep = nil}

  /// The type of attribute.  This message is used for all of the different
  /// attribute types so the discriminator helps for figuring out what is
  /// stored in the message.
  public var type: BlazeQuery_Attribute.Discriminator {
    get {return _storage._type ?? .integer}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// If this attribute has an integer value this will be populated.
  /// Boolean and TriState also use this field as [0,1] and [-1,0,1]
  /// for [false, true] and [auto, no, yes] respectively.
  public var intValue: Int32 {
    get {return _storage._intValue ?? 0}
    set {_uniqueStorage()._intValue = newValue}
  }
  /// Returns true if `intValue` has been explicitly set.
  public var hasIntValue: Bool {return _storage._intValue != nil}
  /// Clears the value of `intValue`. Subsequent reads from it will return its default value.
  public mutating func clearIntValue() {_uniqueStorage()._intValue = nil}

  /// If the attribute has a string value this will be populated.  Label and
  /// path attributes use this field as the value even though the type may
  /// be LABEL or something else other than STRING.
  public var stringValue: String {
    get {return _storage._stringValue ?? String()}
    set {_uniqueStorage()._stringValue = newValue}
  }
  /// Returns true if `stringValue` has been explicitly set.
  public var hasStringValue: Bool {return _storage._stringValue != nil}
  /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
  public mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

  /// If the attribute has a boolean value this will be populated.
  public var booleanValue: Bool {
    get {return _storage._booleanValue ?? false}
    set {_uniqueStorage()._booleanValue = newValue}
  }
  /// Returns true if `booleanValue` has been explicitly set.
  public var hasBooleanValue: Bool {return _storage._booleanValue != nil}
  /// Clears the value of `booleanValue`. Subsequent reads from it will return its default value.
  public mutating func clearBooleanValue() {_uniqueStorage()._booleanValue = nil}

  /// If the attribute is a Tristate value, this will be populated.
  public var tristateValue: BlazeQuery_Attribute.Tristate {
    get {return _storage._tristateValue ?? .no}
    set {_uniqueStorage()._tristateValue = newValue}
  }
  /// Returns true if `tristateValue` has been explicitly set.
  public var hasTristateValue: Bool {return _storage._tristateValue != nil}
  /// Clears the value of `tristateValue`. Subsequent reads from it will return its default value.
  public mutating func clearTristateValue() {_uniqueStorage()._tristateValue = nil}

  /// The value of the attribute has a list of string values (label and path
  /// note from STRING applies here as well).
  public var stringListValue: [String] {
    get {return _storage._stringListValue}
    set {_uniqueStorage()._stringListValue = newValue}
  }

  /// If this is a license attribute, the license information is stored here.
  public var license: BlazeQuery_License {
    get {return _storage._license ?? BlazeQuery_License()}
    set {_uniqueStorage()._license = newValue}
  }
  /// Returns true if `license` has been explicitly set.
  public var hasLicense: Bool {return _storage._license != nil}
  /// Clears the value of `license`. Subsequent reads from it will return its default value.
  public mutating func clearLicense() {_uniqueStorage()._license = nil}

  /// If this is a string dict, each entry will be stored here.
  public var stringDictValue: [BlazeQuery_StringDictEntry] {
    get {return _storage._stringDictValue}
    set {_uniqueStorage()._stringDictValue = newValue}
  }

  /// If the attribute is part of a Fileset, the fileset entries are stored in
  /// this field.
  public var filesetListValue: [BlazeQuery_FilesetEntry] {
    get {return _storage._filesetListValue}
    set {_uniqueStorage()._filesetListValue = newValue}
  }

  /// If this is a label list dict, each entry will be stored here.
  public var labelListDictValue: [BlazeQuery_LabelListDictEntry] {
    get {return _storage._labelListDictValue}
    set {_uniqueStorage()._labelListDictValue = newValue}
  }

  /// If this is a string list dict, each entry will be stored here.
  public var stringListDictValue: [BlazeQuery_StringListDictEntry] {
    get {return _storage._stringListDictValue}
    set {_uniqueStorage()._stringListDictValue = newValue}
  }

  /// The value of the attribute has a list of int32 values
  public var intListValue: [Int32] {
    get {return _storage._intListValue}
    set {_uniqueStorage()._intListValue = newValue}
  }

  /// If this is a label dict unary, each entry will be stored here.
  public var labelDictUnaryValue: [BlazeQuery_LabelDictUnaryEntry] {
    get {return _storage._labelDictUnaryValue}
    set {_uniqueStorage()._labelDictUnaryValue = newValue}
  }

  /// If this is a label-keyed string dict, each entry will be stored here.
  public var labelKeyedStringDictValue: [BlazeQuery_LabelKeyedStringDictEntry] {
    get {return _storage._labelKeyedStringDictValue}
    set {_uniqueStorage()._labelKeyedStringDictValue = newValue}
  }

  /// If this attribute's value is an expression containing one or more select
  /// expressions, then its type is SELECTOR_LIST and a SelectorList will be
  /// stored here.
  public var selectorList: BlazeQuery_Attribute.SelectorList {
    get {return _storage._selectorList ?? BlazeQuery_Attribute.SelectorList()}
    set {_uniqueStorage()._selectorList = newValue}
  }
  /// Returns true if `selectorList` has been explicitly set.
  public var hasSelectorList: Bool {return _storage._selectorList != nil}
  /// Clears the value of `selectorList`. Subsequent reads from it will return its default value.
  public mutating func clearSelectorList() {_uniqueStorage()._selectorList = nil}

  public var deprecatedStringDictUnaryValue: [Data] {
    get {return _storage._deprecatedStringDictUnaryValue}
    set {_uniqueStorage()._deprecatedStringDictUnaryValue = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the type of attribute.
  public enum Discriminator: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// int_value
    case integer // = 1

    /// string_value
    case string // = 2

    /// string_value
    case label // = 3

    /// string_value
    case output // = 4

    /// string_list_value
    case stringList // = 5

    /// string_list_value
    case labelList // = 6

    /// string_list_value
    case outputList // = 7

    /// string_list_value - order is unimportant
    case distributionSet // = 8

    /// license
    case license // = 9

    /// string_dict_value
    case stringDict // = 10

    /// fileset_list_value
    case filesetEntryList // = 11

    /// label_list_dict_value
    case labelListDict // = 12

    /// string_list_dict_value
    case stringListDict // = 13

    /// int, bool and string value
    case boolean // = 14

    /// tristate, int and string value
    case tristate // = 15

    /// int_list_value
    case integerList // = 16

    /// unknown type, use only for build extensions
    case unknown // = 18

    /// label_dict_unary_value
    case labelDictUnary // = 19

    /// selector_list
    case selectorList // = 20

    /// label_keyed_string_dict
    case labelKeyedStringDict // = 21
    case deprecatedStringDictUnary // = 17

    public init() {
      self = .integer
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .integer
      case 2: self = .string
      case 3: self = .label
      case 4: self = .output
      case 5: self = .stringList
      case 6: self = .labelList
      case 7: self = .outputList
      case 8: self = .distributionSet
      case 9: self = .license
      case 10: self = .stringDict
      case 11: self = .filesetEntryList
      case 12: self = .labelListDict
      case 13: self = .stringListDict
      case 14: self = .boolean
      case 15: self = .tristate
      case 16: self = .integerList
      case 17: self = .deprecatedStringDictUnary
      case 18: self = .unknown
      case 19: self = .labelDictUnary
      case 20: self = .selectorList
      case 21: self = .labelKeyedStringDict
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .integer: return 1
      case .string: return 2
      case .label: return 3
      case .output: return 4
      case .stringList: return 5
      case .labelList: return 6
      case .outputList: return 7
      case .distributionSet: return 8
      case .license: return 9
      case .stringDict: return 10
      case .filesetEntryList: return 11
      case .labelListDict: return 12
      case .stringListDict: return 13
      case .boolean: return 14
      case .tristate: return 15
      case .integerList: return 16
      case .deprecatedStringDictUnary: return 17
      case .unknown: return 18
      case .labelDictUnary: return 19
      case .selectorList: return 20
      case .labelKeyedStringDict: return 21
      }
    }

  }

  /// Values for the TriState field type.
  public enum Tristate: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case no // = 0
    case yes // = 1
    case auto // = 2

    public init() {
      self = .no
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .no
      case 1: self = .yes
      case 2: self = .auto
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .no: return 0
      case .yes: return 1
      case .auto: return 2
      }
    }

  }

  public struct SelectorEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key of the selector entry. At this time, this is the label of a
    /// config_setting rule, or the pseudo-label "//conditions:default".
    public var label: String {
      get {return _storage._label ?? String()}
      set {_uniqueStorage()._label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    public var hasLabel: Bool {return _storage._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    public mutating func clearLabel() {_uniqueStorage()._label = nil}

    /// True if the entry's value is the default value for the type as a
    /// result of the condition value being specified as None (ie:
    /// {"//condition": None}).
    public var isDefaultValue: Bool {
      get {return _storage._isDefaultValue ?? false}
      set {_uniqueStorage()._isDefaultValue = newValue}
    }
    /// Returns true if `isDefaultValue` has been explicitly set.
    public var hasIsDefaultValue: Bool {return _storage._isDefaultValue != nil}
    /// Clears the value of `isDefaultValue`. Subsequent reads from it will return its default value.
    public mutating func clearIsDefaultValue() {_uniqueStorage()._isDefaultValue = nil}

    /// Exactly one of the following fields (except for glob_criteria) must be
    /// populated - note that the BOOLEAN and TRISTATE caveat in Attribute's
    /// comment does not apply here. The type field in the SelectorList
    /// containing this entry indicates which of these fields is populated,
    /// in accordance with the comments on Discriminator enum values above.
    /// (To be explicit: BOOLEAN populates the boolean_value field and TRISTATE
    /// populates the tristate_value field.)
    public var intValue: Int32 {
      get {return _storage._intValue ?? 0}
      set {_uniqueStorage()._intValue = newValue}
    }
    /// Returns true if `intValue` has been explicitly set.
    public var hasIntValue: Bool {return _storage._intValue != nil}
    /// Clears the value of `intValue`. Subsequent reads from it will return its default value.
    public mutating func clearIntValue() {_uniqueStorage()._intValue = nil}

    public var stringValue: String {
      get {return _storage._stringValue ?? String()}
      set {_uniqueStorage()._stringValue = newValue}
    }
    /// Returns true if `stringValue` has been explicitly set.
    public var hasStringValue: Bool {return _storage._stringValue != nil}
    /// Clears the value of `stringValue`. Subsequent reads from it will return its default value.
    public mutating func clearStringValue() {_uniqueStorage()._stringValue = nil}

    public var booleanValue: Bool {
      get {return _storage._booleanValue ?? false}
      set {_uniqueStorage()._booleanValue = newValue}
    }
    /// Returns true if `booleanValue` has been explicitly set.
    public var hasBooleanValue: Bool {return _storage._booleanValue != nil}
    /// Clears the value of `booleanValue`. Subsequent reads from it will return its default value.
    public mutating func clearBooleanValue() {_uniqueStorage()._booleanValue = nil}

    public var tristateValue: BlazeQuery_Attribute.Tristate {
      get {return _storage._tristateValue ?? .no}
      set {_uniqueStorage()._tristateValue = newValue}
    }
    /// Returns true if `tristateValue` has been explicitly set.
    public var hasTristateValue: Bool {return _storage._tristateValue != nil}
    /// Clears the value of `tristateValue`. Subsequent reads from it will return its default value.
    public mutating func clearTristateValue() {_uniqueStorage()._tristateValue = nil}

    public var stringListValue: [String] {
      get {return _storage._stringListValue}
      set {_uniqueStorage()._stringListValue = newValue}
    }

    public var license: BlazeQuery_License {
      get {return _storage._license ?? BlazeQuery_License()}
      set {_uniqueStorage()._license = newValue}
    }
    /// Returns true if `license` has been explicitly set.
    public var hasLicense: Bool {return _storage._license != nil}
    /// Clears the value of `license`. Subsequent reads from it will return its default value.
    public mutating func clearLicense() {_uniqueStorage()._license = nil}

    public var stringDictValue: [BlazeQuery_StringDictEntry] {
      get {return _storage._stringDictValue}
      set {_uniqueStorage()._stringDictValue = newValue}
    }

    public var filesetListValue: [BlazeQuery_FilesetEntry] {
      get {return _storage._filesetListValue}
      set {_uniqueStorage()._filesetListValue = newValue}
    }

    public var labelListDictValue: [BlazeQuery_LabelListDictEntry] {
      get {return _storage._labelListDictValue}
      set {_uniqueStorage()._labelListDictValue = newValue}
    }

    public var stringListDictValue: [BlazeQuery_StringListDictEntry] {
      get {return _storage._stringListDictValue}
      set {_uniqueStorage()._stringListDictValue = newValue}
    }

    public var intListValue: [Int32] {
      get {return _storage._intListValue}
      set {_uniqueStorage()._intListValue = newValue}
    }

    public var labelDictUnaryValue: [BlazeQuery_LabelDictUnaryEntry] {
      get {return _storage._labelDictUnaryValue}
      set {_uniqueStorage()._labelDictUnaryValue = newValue}
    }

    public var labelKeyedStringDictValue: [BlazeQuery_LabelKeyedStringDictEntry] {
      get {return _storage._labelKeyedStringDictValue}
      set {_uniqueStorage()._labelKeyedStringDictValue = newValue}
    }

    public var deprecatedStringDictUnaryValue: [Data] {
      get {return _storage._deprecatedStringDictUnaryValue}
      set {_uniqueStorage()._deprecatedStringDictUnaryValue = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct Selector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of (label, value) pairs in the map that defines the selector.
    /// At this time, this cannot be empty, i.e. a selector has at least one
    /// entry.
    public var entries: [BlazeQuery_Attribute.SelectorEntry] = []

    /// Whether or not this has any default values.
    public var hasDefaultValue_p: Bool {
      get {return _hasDefaultValue_p ?? false}
      set {_hasDefaultValue_p = newValue}
    }
    /// Returns true if `hasDefaultValue_p` has been explicitly set.
    public var hasHasDefaultValue_p: Bool {return self._hasDefaultValue_p != nil}
    /// Clears the value of `hasDefaultValue_p`. Subsequent reads from it will return its default value.
    public mutating func clearHasDefaultValue_p() {self._hasDefaultValue_p = nil}

    /// The error message when no condition matches.
    public var noMatchError: String {
      get {return _noMatchError ?? String()}
      set {_noMatchError = newValue}
    }
    /// Returns true if `noMatchError` has been explicitly set.
    public var hasNoMatchError: Bool {return self._noMatchError != nil}
    /// Clears the value of `noMatchError`. Subsequent reads from it will return its default value.
    public mutating func clearNoMatchError() {self._noMatchError = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _hasDefaultValue_p: Bool? = nil
    fileprivate var _noMatchError: String? = nil
  }

  public struct SelectorList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type that this selector list evaluates to, and the type that each
    /// selector in the list evaluates to. At this time, this cannot be
    /// SELECTOR_LIST, i.e. selector lists do not nest.
    public var type: BlazeQuery_Attribute.Discriminator {
      get {return _type ?? .integer}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {self._type = nil}

    /// The list of selector elements in this selector list. At this time, this
    /// cannot be empty, i.e. a selector list is never empty.
    public var elements: [BlazeQuery_Attribute.Selector] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _type: BlazeQuery_Attribute.Discriminator? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension BlazeQuery_Attribute.Discriminator: CaseIterable {
  // Support synthesized by the compiler.
}

extension BlazeQuery_Attribute.Tristate: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// A rule instance (e.g., cc_library foo, java_binary bar).
public struct BlazeQuery_Rule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the rule (formatted as an absolute label, e.g. //foo/bar:baz).
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The rule class (e.g., java_library)
  public var ruleClass: String {
    get {return _ruleClass ?? String()}
    set {_ruleClass = newValue}
  }
  /// Returns true if `ruleClass` has been explicitly set.
  public var hasRuleClass: Bool {return self._ruleClass != nil}
  /// Clears the value of `ruleClass`. Subsequent reads from it will return its default value.
  public mutating func clearRuleClass() {self._ruleClass = nil}

  /// The BUILD file and line number of the location (formatted as
  /// <absolute_path>:<line_number>:<column_number>) in the rule's package's
  /// BUILD file where the rule instance was instantiated. The line number will
  /// be that of a rule invocation or macro call (that in turn invoked a
  /// rule). See
  /// https://bazel.build/rules/macros#macro-creation
  public var location: String {
    get {return _location ?? String()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  /// All of the attributes that describe the rule.
  public var attribute: [BlazeQuery_Attribute] = []

  /// All of the inputs to the rule (formatted as absolute labels). These are
  /// predecessors in the dependency graph.
  public var ruleInput: [String] = []

  public var configuredRuleInput: [BlazeQuery_ConfiguredRuleInput] = []

  /// All of the outputs of the rule (formatted as absolute labels). These are
  /// successors in the dependency graph.
  public var ruleOutput: [String] = []

  /// The set of all "features" inherited from the rule's package declaration.
  public var defaultSetting: [String] = []

  /// The rule's class's public by default value.
  public var deprecatedPublicByDefault: Bool {
    get {return _deprecatedPublicByDefault ?? false}
    set {_deprecatedPublicByDefault = newValue}
  }
  /// Returns true if `deprecatedPublicByDefault` has been explicitly set.
  public var hasDeprecatedPublicByDefault: Bool {return self._deprecatedPublicByDefault != nil}
  /// Clears the value of `deprecatedPublicByDefault`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecatedPublicByDefault() {self._deprecatedPublicByDefault = nil}

  public var deprecatedIsSkylark: Bool {
    get {return _deprecatedIsSkylark ?? false}
    set {_deprecatedIsSkylark = newValue}
  }
  /// Returns true if `deprecatedIsSkylark` has been explicitly set.
  public var hasDeprecatedIsSkylark: Bool {return self._deprecatedIsSkylark != nil}
  /// Clears the value of `deprecatedIsSkylark`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecatedIsSkylark() {self._deprecatedIsSkylark = nil}

  /// Hash encapsulating the behavior of this Starlark rule. Any change to this
  /// rule's definition that could change its behavior will be reflected here.
  public var skylarkEnvironmentHashCode: String {
    get {return _skylarkEnvironmentHashCode ?? String()}
    set {_skylarkEnvironmentHashCode = newValue}
  }
  /// Returns true if `skylarkEnvironmentHashCode` has been explicitly set.
  public var hasSkylarkEnvironmentHashCode: Bool {return self._skylarkEnvironmentHashCode != nil}
  /// Clears the value of `skylarkEnvironmentHashCode`. Subsequent reads from it will return its default value.
  public mutating func clearSkylarkEnvironmentHashCode() {self._skylarkEnvironmentHashCode = nil}

  /// The Starlark call stack at the moment the rule was instantiated.
  /// Each entry has the form "file:line:col: function".
  /// The outermost stack frame ("<toplevel>", the BUILD file) appears first;
  /// the frame for the rule function itself is omitted.
  /// The file name may be relative to package's source root directory.
  ///
  /// Requires --proto:instantiation_stack=true.
  public var instantiationStack: [String] = []

  /// The Starlark call stack for the definition of the rule class of this
  /// particular rule instance. If empty, either populating the field was not
  /// enabled on the command line with the --proto:definition_stack flag or the
  /// rule is a native one.
  public var definitionStack: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _ruleClass: String? = nil
  fileprivate var _location: String? = nil
  fileprivate var _deprecatedPublicByDefault: Bool? = nil
  fileprivate var _deprecatedIsSkylark: Bool? = nil
  fileprivate var _skylarkEnvironmentHashCode: String? = nil
}

public struct BlazeQuery_ConfiguredRuleInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  public var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  public mutating func clearLabel() {self._label = nil}

  public var configurationChecksum: String {
    get {return _configurationChecksum ?? String()}
    set {_configurationChecksum = newValue}
  }
  /// Returns true if `configurationChecksum` has been explicitly set.
  public var hasConfigurationChecksum: Bool {return self._configurationChecksum != nil}
  /// Clears the value of `configurationChecksum`. Subsequent reads from it will return its default value.
  public mutating func clearConfigurationChecksum() {self._configurationChecksum = nil}

  public var configurationID: UInt32 {
    get {return _configurationID ?? 0}
    set {_configurationID = newValue}
  }
  /// Returns true if `configurationID` has been explicitly set.
  public var hasConfigurationID: Bool {return self._configurationID != nil}
  /// Clears the value of `configurationID`. Subsequent reads from it will return its default value.
  public mutating func clearConfigurationID() {self._configurationID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _label: String? = nil
  fileprivate var _configurationChecksum: String? = nil
  fileprivate var _configurationID: UInt32? = nil
}

/// Summary of all transitive dependencies of 'rule,' where each dependent
/// rule is included only once in the 'dependency' field.  Gives complete
/// information to analyze the single build target labeled rule.name,
/// including optional location of target in BUILD file.
public struct BlazeQuery_RuleSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rule: BlazeQuery_Rule {
    get {return _rule ?? BlazeQuery_Rule()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  public var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  public mutating func clearRule() {self._rule = nil}

  public var dependency: [BlazeQuery_Rule] = []

  public var location: String {
    get {return _location ?? String()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rule: BlazeQuery_Rule? = nil
  fileprivate var _location: String? = nil
}

/// A package group. Aside from the name, it contains the list of packages
/// present in the group (as specified in the BUILD file).
public struct BlazeQuery_PackageGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the package group
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The list of packages as specified in the BUILD file. Currently this is
  /// only a list of packages, but some time in the future, there might be
  /// some type of wildcard mechanism.
  public var containedPackage: [String] = []

  /// The list of sub package groups included in this one.
  public var includedPackageGroup: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
}

/// An environment group.
public struct BlazeQuery_EnvironmentGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the environment group.
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The environments that belong to this group (as labels).
  public var environment: [String] = []

  /// The member environments that rules implicitly support if not otherwise
  /// specified.
  public var `default`: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
}

/// A file that is an input into the build system.
/// Next-Id: 10
public struct BlazeQuery_SourceFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the source file (a label).
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The location of the source file.  This is a path with a line number and a
  /// column number not a label in the build system.
  public var location: String {
    get {return _location ?? String()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  /// Labels of .bzl (Starlark) files that are transitively loaded in this BUILD
  /// file. This is present only when the SourceFile represents a BUILD file that
  /// loaded .bzl files.
  /// TODO(bazel-team): Rename this field.
  public var subinclude: [String] = []

  /// Labels of package groups that are mentioned in the visibility declaration
  /// for this source file.
  public var packageGroup: [String] = []

  /// Labels mentioned in the visibility declaration (including :__pkg__ and
  /// //visibility: ones)
  public var visibilityLabel: [String] = []

  /// The package-level features enabled for this package. Only present if the
  /// SourceFile represents a BUILD file.
  public var feature: [String] = []

  /// License attribute for the file.
  public var license: BlazeQuery_License {
    get {return _license ?? BlazeQuery_License()}
    set {_license = newValue}
  }
  /// Returns true if `license` has been explicitly set.
  public var hasLicense: Bool {return self._license != nil}
  /// Clears the value of `license`. Subsequent reads from it will return its default value.
  public mutating func clearLicense() {self._license = nil}

  /// True if the package contains an error. Only present if the SourceFile
  /// represents a BUILD file.
  public var packageContainsErrors: Bool {
    get {return _packageContainsErrors ?? false}
    set {_packageContainsErrors = newValue}
  }
  /// Returns true if `packageContainsErrors` has been explicitly set.
  public var hasPackageContainsErrors: Bool {return self._packageContainsErrors != nil}
  /// Clears the value of `packageContainsErrors`. Subsequent reads from it will return its default value.
  public mutating func clearPackageContainsErrors() {self._packageContainsErrors = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _location: String? = nil
  fileprivate var _license: BlazeQuery_License? = nil
  fileprivate var _packageContainsErrors: Bool? = nil
}

/// A file that is the output of a build rule.
public struct BlazeQuery_GeneratedFile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the generated file (a label).
  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// The label of the target that generates the file.
  public var generatingRule: String {
    get {return _generatingRule ?? String()}
    set {_generatingRule = newValue}
  }
  /// Returns true if `generatingRule` has been explicitly set.
  public var hasGeneratingRule: Bool {return self._generatingRule != nil}
  /// Clears the value of `generatingRule`. Subsequent reads from it will return its default value.
  public mutating func clearGeneratingRule() {self._generatingRule = nil}

  /// The path, line number, and column number of the output file (not a label).
  public var location: String {
    get {return _location ?? String()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _generatingRule: String? = nil
  fileprivate var _location: String? = nil
}

/// A target from a blaze query execution.  Similar to the Attribute message,
/// the Discriminator is used to determine which field contains information.
/// For any given type, only one of these can be populated in a single Target.
public struct BlazeQuery_Target {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of target contained in the message.
  public var type: BlazeQuery_Target.Discriminator {
    get {return _storage._type ?? .rule}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  /// If this target represents a rule, the rule is stored here.
  public var rule: BlazeQuery_Rule {
    get {return _storage._rule ?? BlazeQuery_Rule()}
    set {_uniqueStorage()._rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  public var hasRule: Bool {return _storage._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  public mutating func clearRule() {_uniqueStorage()._rule = nil}

  /// A file that is not generated by the build system (version controlled
  /// or created by the test harness).
  public var sourceFile: BlazeQuery_SourceFile {
    get {return _storage._sourceFile ?? BlazeQuery_SourceFile()}
    set {_uniqueStorage()._sourceFile = newValue}
  }
  /// Returns true if `sourceFile` has been explicitly set.
  public var hasSourceFile: Bool {return _storage._sourceFile != nil}
  /// Clears the value of `sourceFile`. Subsequent reads from it will return its default value.
  public mutating func clearSourceFile() {_uniqueStorage()._sourceFile = nil}

  /// A generated file that is the output of a rule.
  public var generatedFile: BlazeQuery_GeneratedFile {
    get {return _storage._generatedFile ?? BlazeQuery_GeneratedFile()}
    set {_uniqueStorage()._generatedFile = newValue}
  }
  /// Returns true if `generatedFile` has been explicitly set.
  public var hasGeneratedFile: Bool {return _storage._generatedFile != nil}
  /// Clears the value of `generatedFile`. Subsequent reads from it will return its default value.
  public mutating func clearGeneratedFile() {_uniqueStorage()._generatedFile = nil}

  /// A package group.
  public var packageGroup: BlazeQuery_PackageGroup {
    get {return _storage._packageGroup ?? BlazeQuery_PackageGroup()}
    set {_uniqueStorage()._packageGroup = newValue}
  }
  /// Returns true if `packageGroup` has been explicitly set.
  public var hasPackageGroup: Bool {return _storage._packageGroup != nil}
  /// Clears the value of `packageGroup`. Subsequent reads from it will return its default value.
  public mutating func clearPackageGroup() {_uniqueStorage()._packageGroup = nil}

  /// An environment group.
  public var environmentGroup: BlazeQuery_EnvironmentGroup {
    get {return _storage._environmentGroup ?? BlazeQuery_EnvironmentGroup()}
    set {_uniqueStorage()._environmentGroup = newValue}
  }
  /// Returns true if `environmentGroup` has been explicitly set.
  public var hasEnvironmentGroup: Bool {return _storage._environmentGroup != nil}
  /// Clears the value of `environmentGroup`. Subsequent reads from it will return its default value.
  public mutating func clearEnvironmentGroup() {_uniqueStorage()._environmentGroup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Discriminator: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case rule // = 1
    case sourceFile // = 2
    case generatedFile // = 3
    case packageGroup // = 4
    case environmentGroup // = 5

    public init() {
      self = .rule
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .rule
      case 2: self = .sourceFile
      case 3: self = .generatedFile
      case 4: self = .packageGroup
      case 5: self = .environmentGroup
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .rule: return 1
      case .sourceFile: return 2
      case .generatedFile: return 3
      case .packageGroup: return 4
      case .environmentGroup: return 5
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension BlazeQuery_Target.Discriminator: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Container for all of the blaze query results.
public struct BlazeQuery_QueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All of the targets returned by the blaze query.
  public var target: [BlazeQuery_Target] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Information about allowed rule classes for a specific attribute of a rule.
public struct BlazeQuery_AllowedRuleClassInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var policy: BlazeQuery_AllowedRuleClassInfo.AllowedRuleClasses {
    get {return _policy ?? .any}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {self._policy = nil}

  /// Rule class names of rules allowed in this attribute, e.g "cc_library",
  /// "py_binary". Only present if the allowed_rule_classes field is set to
  /// SPECIFIED.
  public var allowedRuleClass: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AllowedRuleClasses: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Any rule is allowed to be in this attribute
    case any // = 1

    /// Only the explicitly listed rules are allowed
    case specified // = 2

    public init() {
      self = .any
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .any
      case 2: self = .specified
      default: return nil
      }
    }

    public var rawValue: Int {
      switch self {
      case .any: return 1
      case .specified: return 2
      }
    }

  }

  public init() {}

  fileprivate var _policy: BlazeQuery_AllowedRuleClassInfo.AllowedRuleClasses? = nil
}

#if swift(>=4.2)

extension BlazeQuery_AllowedRuleClassInfo.AllowedRuleClasses: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// This message represents a single attribute of a single rule.
/// See https://bazel.build/rules/lib/attr.
public struct BlazeQuery_AttributeDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g. "name", "srcs"
  public var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  public var type: BlazeQuery_Attribute.Discriminator {
    get {return _storage._type ?? .integer}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {_uniqueStorage()._type = nil}

  public var mandatory: Bool {
    get {return _storage._mandatory ?? false}
    set {_uniqueStorage()._mandatory = newValue}
  }
  /// Returns true if `mandatory` has been explicitly set.
  public var hasMandatory: Bool {return _storage._mandatory != nil}
  /// Clears the value of `mandatory`. Subsequent reads from it will return its default value.
  public mutating func clearMandatory() {_uniqueStorage()._mandatory = nil}

  /// type=label*
  public var allowedRuleClasses: BlazeQuery_AllowedRuleClassInfo {
    get {return _storage._allowedRuleClasses ?? BlazeQuery_AllowedRuleClassInfo()}
    set {_uniqueStorage()._allowedRuleClasses = newValue}
  }
  /// Returns true if `allowedRuleClasses` has been explicitly set.
  public var hasAllowedRuleClasses: Bool {return _storage._allowedRuleClasses != nil}
  /// Clears the value of `allowedRuleClasses`. Subsequent reads from it will return its default value.
  public mutating func clearAllowedRuleClasses() {_uniqueStorage()._allowedRuleClasses = nil}

  public var documentation: String {
    get {return _storage._documentation ?? String()}
    set {_uniqueStorage()._documentation = newValue}
  }
  /// Returns true if `documentation` has been explicitly set.
  public var hasDocumentation: Bool {return _storage._documentation != nil}
  /// Clears the value of `documentation`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentation() {_uniqueStorage()._documentation = nil}

  /// type=*_list|*_dict
  public var allowEmpty: Bool {
    get {return _storage._allowEmpty ?? false}
    set {_uniqueStorage()._allowEmpty = newValue}
  }
  /// Returns true if `allowEmpty` has been explicitly set.
  public var hasAllowEmpty: Bool {return _storage._allowEmpty != nil}
  /// Clears the value of `allowEmpty`. Subsequent reads from it will return its default value.
  public mutating func clearAllowEmpty() {_uniqueStorage()._allowEmpty = nil}

  /// type=label
  public var allowSingleFile: Bool {
    get {return _storage._allowSingleFile ?? false}
    set {_uniqueStorage()._allowSingleFile = newValue}
  }
  /// Returns true if `allowSingleFile` has been explicitly set.
  public var hasAllowSingleFile: Bool {return _storage._allowSingleFile != nil}
  /// Clears the value of `allowSingleFile`. Subsequent reads from it will return its default value.
  public mutating func clearAllowSingleFile() {_uniqueStorage()._allowSingleFile = nil}

  /// simple (not computed/late-bound) values only
  public var `default`: BlazeQuery_AttributeValue {
    get {return _storage._default ?? BlazeQuery_AttributeValue()}
    set {_uniqueStorage()._default = newValue}
  }
  /// Returns true if ``default`` has been explicitly set.
  public var hasDefault: Bool {return _storage._default != nil}
  /// Clears the value of ``default``. Subsequent reads from it will return its default value.
  public mutating func clearDefault() {_uniqueStorage()._default = nil}

  /// type=label
  public var executable: Bool {
    get {return _storage._executable ?? false}
    set {_uniqueStorage()._executable = newValue}
  }
  /// Returns true if `executable` has been explicitly set.
  public var hasExecutable: Bool {return _storage._executable != nil}
  /// Clears the value of `executable`. Subsequent reads from it will return its default value.
  public mutating func clearExecutable() {_uniqueStorage()._executable = nil}

  public var configurable: Bool {
    get {return _storage._configurable ?? false}
    set {_uniqueStorage()._configurable = newValue}
  }
  /// Returns true if `configurable` has been explicitly set.
  public var hasConfigurable: Bool {return _storage._configurable != nil}
  /// Clears the value of `configurable`. Subsequent reads from it will return its default value.
  public mutating func clearConfigurable() {_uniqueStorage()._configurable = nil}

  /// label-valued edge does not establish a dependency
  public var nodep: Bool {
    get {return _storage._nodep ?? false}
    set {_uniqueStorage()._nodep = newValue}
  }
  /// Returns true if `nodep` has been explicitly set.
  public var hasNodep: Bool {return _storage._nodep != nil}
  /// Clears the value of `nodep`. Subsequent reads from it will return its default value.
  public mutating func clearNodep() {_uniqueStorage()._nodep = nil}

  /// edge entails a transition to "host" configuration
  public var cfgIsHost: Bool {
    get {return _storage._cfgIsHost ?? false}
    set {_uniqueStorage()._cfgIsHost = newValue}
  }
  /// Returns true if `cfgIsHost` has been explicitly set.
  public var hasCfgIsHost: Bool {return _storage._cfgIsHost != nil}
  /// Clears the value of `cfgIsHost`. Subsequent reads from it will return its default value.
  public mutating func clearCfgIsHost() {_uniqueStorage()._cfgIsHost = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An AttributeValue represents the value of an attribute.
/// A single field, determined by the attribute type, is populated.
///
/// It is used only for AttributeDefinition.default. Attribute and
/// SelectorEntry do their own thing for unfortunate historical reasons.
public struct BlazeQuery_AttributeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// type=int|tristate
  public var int: Int32 {
    get {return _int ?? 0}
    set {_int = newValue}
  }
  /// Returns true if `int` has been explicitly set.
  public var hasInt: Bool {return self._int != nil}
  /// Clears the value of `int`. Subsequent reads from it will return its default value.
  public mutating func clearInt() {self._int = nil}

  /// type=string|label|output
  public var string: String {
    get {return _string ?? String()}
    set {_string = newValue}
  }
  /// Returns true if `string` has been explicitly set.
  public var hasString: Bool {return self._string != nil}
  /// Clears the value of `string`. Subsequent reads from it will return its default value.
  public mutating func clearString() {self._string = nil}

  /// type=bool
  public var bool: Bool {
    get {return _bool ?? false}
    set {_bool = newValue}
  }
  /// Returns true if `bool` has been explicitly set.
  public var hasBool: Bool {return self._bool != nil}
  /// Clears the value of `bool`. Subsequent reads from it will return its default value.
  public mutating func clearBool() {self._bool = nil}

  /// type=*_list|distrib
  public var list: [BlazeQuery_AttributeValue] = []

  /// type=*_dict
  public var dict: [BlazeQuery_AttributeValue.DictEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DictEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String {
      get {return _key ?? String()}
      set {_key = newValue}
    }
    /// Returns true if `key` has been explicitly set.
    public var hasKey: Bool {return self._key != nil}
    /// Clears the value of `key`. Subsequent reads from it will return its default value.
    public mutating func clearKey() {self._key = nil}

    public var value: BlazeQuery_AttributeValue {
      get {return _value ?? BlazeQuery_AttributeValue()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _key: String? = nil
    fileprivate var _value: BlazeQuery_AttributeValue? = nil
  }

  public init() {}

  fileprivate var _int: Int32? = nil
  fileprivate var _string: String? = nil
  fileprivate var _bool: Bool? = nil
}

public struct BlazeQuery_RuleDefinition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// Only contains documented attributes
  public var attribute: [BlazeQuery_AttributeDefinition] = []

  public var documentation: String {
    get {return _documentation ?? String()}
    set {_documentation = newValue}
  }
  /// Returns true if `documentation` has been explicitly set.
  public var hasDocumentation: Bool {return self._documentation != nil}
  /// Clears the value of `documentation`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentation() {self._documentation = nil}

  /// Only for build extensions: label to file that defines the extension
  public var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  public var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  public mutating func clearLabel() {self._label = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _documentation: String? = nil
  fileprivate var _label: String? = nil
}

public struct BlazeQuery_BuildLanguage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only contains documented rule definitions
  public var rule: [BlazeQuery_RuleDefinition] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BlazeQuery_License: @unchecked Sendable {}
extension BlazeQuery_StringDictEntry: @unchecked Sendable {}
extension BlazeQuery_LabelDictUnaryEntry: @unchecked Sendable {}
extension BlazeQuery_LabelListDictEntry: @unchecked Sendable {}
extension BlazeQuery_LabelKeyedStringDictEntry: @unchecked Sendable {}
extension BlazeQuery_StringListDictEntry: @unchecked Sendable {}
extension BlazeQuery_FilesetEntry: @unchecked Sendable {}
extension BlazeQuery_FilesetEntry.SymlinkBehavior: @unchecked Sendable {}
extension BlazeQuery_Attribute: @unchecked Sendable {}
extension BlazeQuery_Attribute.Discriminator: @unchecked Sendable {}
extension BlazeQuery_Attribute.Tristate: @unchecked Sendable {}
extension BlazeQuery_Attribute.SelectorEntry: @unchecked Sendable {}
extension BlazeQuery_Attribute.Selector: @unchecked Sendable {}
extension BlazeQuery_Attribute.SelectorList: @unchecked Sendable {}
extension BlazeQuery_Rule: @unchecked Sendable {}
extension BlazeQuery_ConfiguredRuleInput: @unchecked Sendable {}
extension BlazeQuery_RuleSummary: @unchecked Sendable {}
extension BlazeQuery_PackageGroup: @unchecked Sendable {}
extension BlazeQuery_EnvironmentGroup: @unchecked Sendable {}
extension BlazeQuery_SourceFile: @unchecked Sendable {}
extension BlazeQuery_GeneratedFile: @unchecked Sendable {}
extension BlazeQuery_Target: @unchecked Sendable {}
extension BlazeQuery_Target.Discriminator: @unchecked Sendable {}
extension BlazeQuery_QueryResult: @unchecked Sendable {}
extension BlazeQuery_AllowedRuleClassInfo: @unchecked Sendable {}
extension BlazeQuery_AllowedRuleClassInfo.AllowedRuleClasses: @unchecked Sendable {}
extension BlazeQuery_AttributeDefinition: @unchecked Sendable {}
extension BlazeQuery_AttributeValue: @unchecked Sendable {}
extension BlazeQuery_AttributeValue.DictEntry: @unchecked Sendable {}
extension BlazeQuery_RuleDefinition: @unchecked Sendable {}
extension BlazeQuery_BuildLanguage: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "blaze_query"

extension BlazeQuery_License: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".License"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_type"),
    2: .same(proto: "exception"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.licenseType) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.exception) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.licenseType.isEmpty {
      try visitor.visitRepeatedStringField(value: self.licenseType, fieldNumber: 1)
    }
    if !self.exception.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exception, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_License, rhs: BlazeQuery_License) -> Bool {
    if lhs.licenseType != rhs.licenseType {return false}
    if lhs.exception != rhs.exception {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_StringDictEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringDictEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_StringDictEntry, rhs: BlazeQuery_StringDictEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_LabelDictUnaryEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelDictUnaryEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_LabelDictUnaryEntry, rhs: BlazeQuery_LabelDictUnaryEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_LabelListDictEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelListDictEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_LabelListDictEntry, rhs: BlazeQuery_LabelListDictEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_LabelKeyedStringDictEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelKeyedStringDictEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_LabelKeyedStringDictEntry, rhs: BlazeQuery_LabelKeyedStringDictEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_StringListDictEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringListDictEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.value.isEmpty {
      try visitor.visitRepeatedStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_StringListDictEntry, rhs: BlazeQuery_StringListDictEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_FilesetEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilesetEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "destination_directory"),
    7: .standard(proto: "files_present"),
    3: .same(proto: "file"),
    4: .same(proto: "exclude"),
    5: .standard(proto: "symlink_behavior"),
    6: .standard(proto: "strip_prefix"),
  ]

  public var isInitialized: Bool {
    if self._source == nil {return false}
    if self._destinationDirectory == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._destinationDirectory) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.file) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.exclude) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._symlinkBehavior) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._stripPrefix) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._filesPresent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._destinationDirectory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.file.isEmpty {
      try visitor.visitRepeatedStringField(value: self.file, fieldNumber: 3)
    }
    if !self.exclude.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclude, fieldNumber: 4)
    }
    try { if let v = self._symlinkBehavior {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._stripPrefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._filesPresent {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_FilesetEntry, rhs: BlazeQuery_FilesetEntry) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._destinationDirectory != rhs._destinationDirectory {return false}
    if lhs._filesPresent != rhs._filesPresent {return false}
    if lhs.file != rhs.file {return false}
    if lhs.exclude != rhs.exclude {return false}
    if lhs._symlinkBehavior != rhs._symlinkBehavior {return false}
    if lhs._stripPrefix != rhs._stripPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_FilesetEntry.SymlinkBehavior: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "COPY"),
    2: .same(proto: "DEREFERENCE"),
  ]
}

extension BlazeQuery_Attribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attribute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    13: .standard(proto: "explicitly_specified"),
    20: .same(proto: "nodep"),
    2: .same(proto: "type"),
    3: .standard(proto: "int_value"),
    5: .standard(proto: "string_value"),
    14: .standard(proto: "boolean_value"),
    15: .standard(proto: "tristate_value"),
    6: .standard(proto: "string_list_value"),
    7: .same(proto: "license"),
    8: .standard(proto: "string_dict_value"),
    9: .standard(proto: "fileset_list_value"),
    10: .standard(proto: "label_list_dict_value"),
    11: .standard(proto: "string_list_dict_value"),
    17: .standard(proto: "int_list_value"),
    19: .standard(proto: "label_dict_unary_value"),
    22: .standard(proto: "label_keyed_string_dict_value"),
    21: .standard(proto: "selector_list"),
    18: .standard(proto: "DEPRECATED_string_dict_unary_value"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _explicitlySpecified: Bool? = nil
    var _nodep: Bool? = nil
    var _type: BlazeQuery_Attribute.Discriminator? = nil
    var _intValue: Int32? = nil
    var _stringValue: String? = nil
    var _booleanValue: Bool? = nil
    var _tristateValue: BlazeQuery_Attribute.Tristate? = nil
    var _stringListValue: [String] = []
    var _license: BlazeQuery_License? = nil
    var _stringDictValue: [BlazeQuery_StringDictEntry] = []
    var _filesetListValue: [BlazeQuery_FilesetEntry] = []
    var _labelListDictValue: [BlazeQuery_LabelListDictEntry] = []
    var _stringListDictValue: [BlazeQuery_StringListDictEntry] = []
    var _intListValue: [Int32] = []
    var _labelDictUnaryValue: [BlazeQuery_LabelDictUnaryEntry] = []
    var _labelKeyedStringDictValue: [BlazeQuery_LabelKeyedStringDictEntry] = []
    var _selectorList: BlazeQuery_Attribute.SelectorList? = nil
    var _deprecatedStringDictUnaryValue: [Data] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _explicitlySpecified = source._explicitlySpecified
      _nodep = source._nodep
      _type = source._type
      _intValue = source._intValue
      _stringValue = source._stringValue
      _booleanValue = source._booleanValue
      _tristateValue = source._tristateValue
      _stringListValue = source._stringListValue
      _license = source._license
      _stringDictValue = source._stringDictValue
      _filesetListValue = source._filesetListValue
      _labelListDictValue = source._labelListDictValue
      _stringListDictValue = source._stringListDictValue
      _intListValue = source._intListValue
      _labelDictUnaryValue = source._labelDictUnaryValue
      _labelKeyedStringDictValue = source._labelKeyedStringDictValue
      _selectorList = source._selectorList
      _deprecatedStringDictUnaryValue = source._deprecatedStringDictUnaryValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if _storage._type == nil {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stringDictValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._filesetListValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._labelListDictValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stringListDictValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._labelDictUnaryValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._labelKeyedStringDictValue) {return false}
      if let v = _storage._selectorList, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._intValue) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._stringListValue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._license) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._stringDictValue) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._filesetListValue) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._labelListDictValue) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._stringListDictValue) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._explicitlySpecified) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._booleanValue) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._tristateValue) }()
        case 17: try { try decoder.decodeRepeatedInt32Field(value: &_storage._intListValue) }()
        case 18: try { try decoder.decodeRepeatedBytesField(value: &_storage._deprecatedStringDictUnaryValue) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._labelDictUnaryValue) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._nodep) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._selectorList) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._labelKeyedStringDictValue) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._intValue {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      if !_storage._stringListValue.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._stringListValue, fieldNumber: 6)
      }
      try { if let v = _storage._license {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._stringDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stringDictValue, fieldNumber: 8)
      }
      if !_storage._filesetListValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._filesetListValue, fieldNumber: 9)
      }
      if !_storage._labelListDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._labelListDictValue, fieldNumber: 10)
      }
      if !_storage._stringListDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stringListDictValue, fieldNumber: 11)
      }
      try { if let v = _storage._explicitlySpecified {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._booleanValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._tristateValue {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 15)
      } }()
      if !_storage._intListValue.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._intListValue, fieldNumber: 17)
      }
      if !_storage._deprecatedStringDictUnaryValue.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._deprecatedStringDictUnaryValue, fieldNumber: 18)
      }
      if !_storage._labelDictUnaryValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._labelDictUnaryValue, fieldNumber: 19)
      }
      try { if let v = _storage._nodep {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._selectorList {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._labelKeyedStringDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._labelKeyedStringDictValue, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_Attribute, rhs: BlazeQuery_Attribute) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._explicitlySpecified != rhs_storage._explicitlySpecified {return false}
        if _storage._nodep != rhs_storage._nodep {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._intValue != rhs_storage._intValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._booleanValue != rhs_storage._booleanValue {return false}
        if _storage._tristateValue != rhs_storage._tristateValue {return false}
        if _storage._stringListValue != rhs_storage._stringListValue {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._stringDictValue != rhs_storage._stringDictValue {return false}
        if _storage._filesetListValue != rhs_storage._filesetListValue {return false}
        if _storage._labelListDictValue != rhs_storage._labelListDictValue {return false}
        if _storage._stringListDictValue != rhs_storage._stringListDictValue {return false}
        if _storage._intListValue != rhs_storage._intListValue {return false}
        if _storage._labelDictUnaryValue != rhs_storage._labelDictUnaryValue {return false}
        if _storage._labelKeyedStringDictValue != rhs_storage._labelKeyedStringDictValue {return false}
        if _storage._selectorList != rhs_storage._selectorList {return false}
        if _storage._deprecatedStringDictUnaryValue != rhs_storage._deprecatedStringDictUnaryValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_Attribute.Discriminator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "INTEGER"),
    2: .same(proto: "STRING"),
    3: .same(proto: "LABEL"),
    4: .same(proto: "OUTPUT"),
    5: .same(proto: "STRING_LIST"),
    6: .same(proto: "LABEL_LIST"),
    7: .same(proto: "OUTPUT_LIST"),
    8: .same(proto: "DISTRIBUTION_SET"),
    9: .same(proto: "LICENSE"),
    10: .same(proto: "STRING_DICT"),
    11: .same(proto: "FILESET_ENTRY_LIST"),
    12: .same(proto: "LABEL_LIST_DICT"),
    13: .same(proto: "STRING_LIST_DICT"),
    14: .same(proto: "BOOLEAN"),
    15: .same(proto: "TRISTATE"),
    16: .same(proto: "INTEGER_LIST"),
    17: .same(proto: "DEPRECATED_STRING_DICT_UNARY"),
    18: .same(proto: "UNKNOWN"),
    19: .same(proto: "LABEL_DICT_UNARY"),
    20: .same(proto: "SELECTOR_LIST"),
    21: .same(proto: "LABEL_KEYED_STRING_DICT"),
  ]
}

extension BlazeQuery_Attribute.Tristate: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO"),
    1: .same(proto: "YES"),
    2: .same(proto: "AUTO"),
  ]
}

extension BlazeQuery_Attribute.SelectorEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BlazeQuery_Attribute.protoMessageName + ".SelectorEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    16: .standard(proto: "is_default_value"),
    2: .standard(proto: "int_value"),
    3: .standard(proto: "string_value"),
    4: .standard(proto: "boolean_value"),
    5: .standard(proto: "tristate_value"),
    6: .standard(proto: "string_list_value"),
    7: .same(proto: "license"),
    8: .standard(proto: "string_dict_value"),
    9: .standard(proto: "fileset_list_value"),
    10: .standard(proto: "label_list_dict_value"),
    11: .standard(proto: "string_list_dict_value"),
    13: .standard(proto: "int_list_value"),
    15: .standard(proto: "label_dict_unary_value"),
    17: .standard(proto: "label_keyed_string_dict_value"),
    14: .standard(proto: "DEPRECATED_string_dict_unary_value"),
  ]

  fileprivate class _StorageClass {
    var _label: String? = nil
    var _isDefaultValue: Bool? = nil
    var _intValue: Int32? = nil
    var _stringValue: String? = nil
    var _booleanValue: Bool? = nil
    var _tristateValue: BlazeQuery_Attribute.Tristate? = nil
    var _stringListValue: [String] = []
    var _license: BlazeQuery_License? = nil
    var _stringDictValue: [BlazeQuery_StringDictEntry] = []
    var _filesetListValue: [BlazeQuery_FilesetEntry] = []
    var _labelListDictValue: [BlazeQuery_LabelListDictEntry] = []
    var _stringListDictValue: [BlazeQuery_StringListDictEntry] = []
    var _intListValue: [Int32] = []
    var _labelDictUnaryValue: [BlazeQuery_LabelDictUnaryEntry] = []
    var _labelKeyedStringDictValue: [BlazeQuery_LabelKeyedStringDictEntry] = []
    var _deprecatedStringDictUnaryValue: [Data] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _label = source._label
      _isDefaultValue = source._isDefaultValue
      _intValue = source._intValue
      _stringValue = source._stringValue
      _booleanValue = source._booleanValue
      _tristateValue = source._tristateValue
      _stringListValue = source._stringListValue
      _license = source._license
      _stringDictValue = source._stringDictValue
      _filesetListValue = source._filesetListValue
      _labelListDictValue = source._labelListDictValue
      _stringListDictValue = source._stringListDictValue
      _intListValue = source._intListValue
      _labelDictUnaryValue = source._labelDictUnaryValue
      _labelKeyedStringDictValue = source._labelKeyedStringDictValue
      _deprecatedStringDictUnaryValue = source._deprecatedStringDictUnaryValue
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stringDictValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._filesetListValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._labelListDictValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stringListDictValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._labelDictUnaryValue) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._labelKeyedStringDictValue) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._label) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._intValue) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._stringValue) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._booleanValue) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._tristateValue) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._stringListValue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._license) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._stringDictValue) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._filesetListValue) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._labelListDictValue) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._stringListDictValue) }()
        case 13: try { try decoder.decodeRepeatedInt32Field(value: &_storage._intListValue) }()
        case 14: try { try decoder.decodeRepeatedBytesField(value: &_storage._deprecatedStringDictUnaryValue) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._labelDictUnaryValue) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._isDefaultValue) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._labelKeyedStringDictValue) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._label {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._intValue {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stringValue {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._booleanValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._tristateValue {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
      } }()
      if !_storage._stringListValue.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._stringListValue, fieldNumber: 6)
      }
      try { if let v = _storage._license {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._stringDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stringDictValue, fieldNumber: 8)
      }
      if !_storage._filesetListValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._filesetListValue, fieldNumber: 9)
      }
      if !_storage._labelListDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._labelListDictValue, fieldNumber: 10)
      }
      if !_storage._stringListDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stringListDictValue, fieldNumber: 11)
      }
      if !_storage._intListValue.isEmpty {
        try visitor.visitRepeatedInt32Field(value: _storage._intListValue, fieldNumber: 13)
      }
      if !_storage._deprecatedStringDictUnaryValue.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._deprecatedStringDictUnaryValue, fieldNumber: 14)
      }
      if !_storage._labelDictUnaryValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._labelDictUnaryValue, fieldNumber: 15)
      }
      try { if let v = _storage._isDefaultValue {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      } }()
      if !_storage._labelKeyedStringDictValue.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._labelKeyedStringDictValue, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_Attribute.SelectorEntry, rhs: BlazeQuery_Attribute.SelectorEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._label != rhs_storage._label {return false}
        if _storage._isDefaultValue != rhs_storage._isDefaultValue {return false}
        if _storage._intValue != rhs_storage._intValue {return false}
        if _storage._stringValue != rhs_storage._stringValue {return false}
        if _storage._booleanValue != rhs_storage._booleanValue {return false}
        if _storage._tristateValue != rhs_storage._tristateValue {return false}
        if _storage._stringListValue != rhs_storage._stringListValue {return false}
        if _storage._license != rhs_storage._license {return false}
        if _storage._stringDictValue != rhs_storage._stringDictValue {return false}
        if _storage._filesetListValue != rhs_storage._filesetListValue {return false}
        if _storage._labelListDictValue != rhs_storage._labelListDictValue {return false}
        if _storage._stringListDictValue != rhs_storage._stringListDictValue {return false}
        if _storage._intListValue != rhs_storage._intListValue {return false}
        if _storage._labelDictUnaryValue != rhs_storage._labelDictUnaryValue {return false}
        if _storage._labelKeyedStringDictValue != rhs_storage._labelKeyedStringDictValue {return false}
        if _storage._deprecatedStringDictUnaryValue != rhs_storage._deprecatedStringDictUnaryValue {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_Attribute.Selector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BlazeQuery_Attribute.protoMessageName + ".Selector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "has_default_value"),
    3: .standard(proto: "no_match_error"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.entries) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hasDefaultValue_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._noMatchError) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try { if let v = self._hasDefaultValue_p {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._noMatchError {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_Attribute.Selector, rhs: BlazeQuery_Attribute.Selector) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs._hasDefaultValue_p != rhs._hasDefaultValue_p {return false}
    if lhs._noMatchError != rhs._noMatchError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_Attribute.SelectorList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BlazeQuery_Attribute.protoMessageName + ".SelectorList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "elements"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_Attribute.SelectorList, rhs: BlazeQuery_Attribute.SelectorList) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "rule_class"),
    3: .same(proto: "location"),
    4: .same(proto: "attribute"),
    5: .standard(proto: "rule_input"),
    15: .standard(proto: "configured_rule_input"),
    6: .standard(proto: "rule_output"),
    7: .standard(proto: "default_setting"),
    9: .standard(proto: "DEPRECATED_public_by_default"),
    10: .standard(proto: "DEPRECATED_is_skylark"),
    12: .standard(proto: "skylark_environment_hash_code"),
    13: .standard(proto: "instantiation_stack"),
    14: .standard(proto: "definition_stack"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._ruleClass == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attribute) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._ruleClass) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._location) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.ruleInput) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.ruleOutput) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.defaultSetting) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._deprecatedPublicByDefault) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._deprecatedIsSkylark) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._skylarkEnvironmentHashCode) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.instantiationStack) }()
      case 14: try { try decoder.decodeRepeatedStringField(value: &self.definitionStack) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.configuredRuleInput) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ruleClass {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 4)
    }
    if !self.ruleInput.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ruleInput, fieldNumber: 5)
    }
    if !self.ruleOutput.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ruleOutput, fieldNumber: 6)
    }
    if !self.defaultSetting.isEmpty {
      try visitor.visitRepeatedStringField(value: self.defaultSetting, fieldNumber: 7)
    }
    try { if let v = self._deprecatedPublicByDefault {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._deprecatedIsSkylark {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._skylarkEnvironmentHashCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    if !self.instantiationStack.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instantiationStack, fieldNumber: 13)
    }
    if !self.definitionStack.isEmpty {
      try visitor.visitRepeatedStringField(value: self.definitionStack, fieldNumber: 14)
    }
    if !self.configuredRuleInput.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configuredRuleInput, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_Rule, rhs: BlazeQuery_Rule) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._ruleClass != rhs._ruleClass {return false}
    if lhs._location != rhs._location {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.ruleInput != rhs.ruleInput {return false}
    if lhs.configuredRuleInput != rhs.configuredRuleInput {return false}
    if lhs.ruleOutput != rhs.ruleOutput {return false}
    if lhs.defaultSetting != rhs.defaultSetting {return false}
    if lhs._deprecatedPublicByDefault != rhs._deprecatedPublicByDefault {return false}
    if lhs._deprecatedIsSkylark != rhs._deprecatedIsSkylark {return false}
    if lhs._skylarkEnvironmentHashCode != rhs._skylarkEnvironmentHashCode {return false}
    if lhs.instantiationStack != rhs.instantiationStack {return false}
    if lhs.definitionStack != rhs.definitionStack {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_ConfiguredRuleInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfiguredRuleInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .standard(proto: "configuration_checksum"),
    3: .standard(proto: "configuration_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._configurationChecksum) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._configurationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._configurationChecksum {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._configurationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_ConfiguredRuleInput, rhs: BlazeQuery_ConfiguredRuleInput) -> Bool {
    if lhs._label != rhs._label {return false}
    if lhs._configurationChecksum != rhs._configurationChecksum {return false}
    if lhs._configurationID != rhs._configurationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_RuleSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuleSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
    2: .same(proto: "dependency"),
    3: .same(proto: "location"),
  ]

  public var isInitialized: Bool {
    if self._rule == nil {return false}
    if let v = self._rule, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.dependency) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dependency) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dependency.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dependency, fieldNumber: 2)
    }
    try { if let v = self._location {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_RuleSummary, rhs: BlazeQuery_RuleSummary) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.dependency != rhs.dependency {return false}
    if lhs._location != rhs._location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_PackageGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "contained_package"),
    3: .standard(proto: "included_package_group"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.containedPackage) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.includedPackageGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.containedPackage.isEmpty {
      try visitor.visitRepeatedStringField(value: self.containedPackage, fieldNumber: 2)
    }
    if !self.includedPackageGroup.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includedPackageGroup, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_PackageGroup, rhs: BlazeQuery_PackageGroup) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.containedPackage != rhs.containedPackage {return false}
    if lhs.includedPackageGroup != rhs.includedPackageGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_EnvironmentGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnvironmentGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "environment"),
    3: .same(proto: "default"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.environment) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.`default`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.environment.isEmpty {
      try visitor.visitRepeatedStringField(value: self.environment, fieldNumber: 2)
    }
    if !self.`default`.isEmpty {
      try visitor.visitRepeatedStringField(value: self.`default`, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_EnvironmentGroup, rhs: BlazeQuery_EnvironmentGroup) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.environment != rhs.environment {return false}
    if lhs.`default` != rhs.`default` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_SourceFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "location"),
    3: .same(proto: "subinclude"),
    4: .standard(proto: "package_group"),
    5: .standard(proto: "visibility_label"),
    6: .same(proto: "feature"),
    8: .same(proto: "license"),
    9: .standard(proto: "package_contains_errors"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._location) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.subinclude) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.packageGroup) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.visibilityLabel) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.feature) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._license) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._packageContainsErrors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.subinclude.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subinclude, fieldNumber: 3)
    }
    if !self.packageGroup.isEmpty {
      try visitor.visitRepeatedStringField(value: self.packageGroup, fieldNumber: 4)
    }
    if !self.visibilityLabel.isEmpty {
      try visitor.visitRepeatedStringField(value: self.visibilityLabel, fieldNumber: 5)
    }
    if !self.feature.isEmpty {
      try visitor.visitRepeatedStringField(value: self.feature, fieldNumber: 6)
    }
    try { if let v = self._license {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._packageContainsErrors {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_SourceFile, rhs: BlazeQuery_SourceFile) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._location != rhs._location {return false}
    if lhs.subinclude != rhs.subinclude {return false}
    if lhs.packageGroup != rhs.packageGroup {return false}
    if lhs.visibilityLabel != rhs.visibilityLabel {return false}
    if lhs.feature != rhs.feature {return false}
    if lhs._license != rhs._license {return false}
    if lhs._packageContainsErrors != rhs._packageContainsErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_GeneratedFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GeneratedFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "generating_rule"),
    3: .same(proto: "location"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._generatingRule == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._generatingRule) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._generatingRule {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._location {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_GeneratedFile, rhs: BlazeQuery_GeneratedFile) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._generatingRule != rhs._generatingRule {return false}
    if lhs._location != rhs._location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Target"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "rule"),
    3: .standard(proto: "source_file"),
    4: .standard(proto: "generated_file"),
    5: .standard(proto: "package_group"),
    6: .standard(proto: "environment_group"),
  ]

  fileprivate class _StorageClass {
    var _type: BlazeQuery_Target.Discriminator? = nil
    var _rule: BlazeQuery_Rule? = nil
    var _sourceFile: BlazeQuery_SourceFile? = nil
    var _generatedFile: BlazeQuery_GeneratedFile? = nil
    var _packageGroup: BlazeQuery_PackageGroup? = nil
    var _environmentGroup: BlazeQuery_EnvironmentGroup? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _rule = source._rule
      _sourceFile = source._sourceFile
      _generatedFile = source._generatedFile
      _packageGroup = source._packageGroup
      _environmentGroup = source._environmentGroup
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._rule, !v.isInitialized {return false}
      if let v = _storage._sourceFile, !v.isInitialized {return false}
      if let v = _storage._generatedFile, !v.isInitialized {return false}
      if let v = _storage._packageGroup, !v.isInitialized {return false}
      if let v = _storage._environmentGroup, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rule) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sourceFile) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._generatedFile) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._packageGroup) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._environmentGroup) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._rule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sourceFile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._generatedFile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._packageGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._environmentGroup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_Target, rhs: BlazeQuery_Target) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._sourceFile != rhs_storage._sourceFile {return false}
        if _storage._generatedFile != rhs_storage._generatedFile {return false}
        if _storage._packageGroup != rhs_storage._packageGroup {return false}
        if _storage._environmentGroup != rhs_storage._environmentGroup {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_Target.Discriminator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "RULE"),
    2: .same(proto: "SOURCE_FILE"),
    3: .same(proto: "GENERATED_FILE"),
    4: .same(proto: "PACKAGE_GROUP"),
    5: .same(proto: "ENVIRONMENT_GROUP"),
  ]
}

extension BlazeQuery_QueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.target) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.target) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.target, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_QueryResult, rhs: BlazeQuery_QueryResult) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_AllowedRuleClassInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllowedRuleClassInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
    2: .standard(proto: "allowed_rule_class"),
  ]

  public var isInitialized: Bool {
    if self._policy == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._policy) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedRuleClass) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._policy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.allowedRuleClass.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedRuleClass, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_AllowedRuleClassInfo, rhs: BlazeQuery_AllowedRuleClassInfo) -> Bool {
    if lhs._policy != rhs._policy {return false}
    if lhs.allowedRuleClass != rhs.allowedRuleClass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_AllowedRuleClassInfo.AllowedRuleClasses: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ANY"),
    2: .same(proto: "SPECIFIED"),
  ]
}

extension BlazeQuery_AttributeDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "mandatory"),
    4: .standard(proto: "allowed_rule_classes"),
    5: .same(proto: "documentation"),
    6: .standard(proto: "allow_empty"),
    7: .standard(proto: "allow_single_file"),
    9: .same(proto: "default"),
    10: .same(proto: "executable"),
    11: .same(proto: "configurable"),
    12: .same(proto: "nodep"),
    13: .standard(proto: "cfg_is_host"),
  ]

  fileprivate class _StorageClass {
    var _name: String? = nil
    var _type: BlazeQuery_Attribute.Discriminator? = nil
    var _mandatory: Bool? = nil
    var _allowedRuleClasses: BlazeQuery_AllowedRuleClassInfo? = nil
    var _documentation: String? = nil
    var _allowEmpty: Bool? = nil
    var _allowSingleFile: Bool? = nil
    var _default: BlazeQuery_AttributeValue? = nil
    var _executable: Bool? = nil
    var _configurable: Bool? = nil
    var _nodep: Bool? = nil
    var _cfgIsHost: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _type = source._type
      _mandatory = source._mandatory
      _allowedRuleClasses = source._allowedRuleClasses
      _documentation = source._documentation
      _allowEmpty = source._allowEmpty
      _allowSingleFile = source._allowSingleFile
      _default = source._default
      _executable = source._executable
      _configurable = source._configurable
      _nodep = source._nodep
      _cfgIsHost = source._cfgIsHost
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._name == nil {return false}
      if _storage._type == nil {return false}
      if let v = _storage._allowedRuleClasses, !v.isInitialized {return false}
      if let v = _storage._default, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._mandatory) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._allowedRuleClasses) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._documentation) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._allowEmpty) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._allowSingleFile) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._default) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._executable) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._configurable) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._nodep) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._cfgIsHost) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._mandatory {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._allowedRuleClasses {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._documentation {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._allowEmpty {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._allowSingleFile {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._default {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._executable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._configurable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._nodep {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._cfgIsHost {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_AttributeDefinition, rhs: BlazeQuery_AttributeDefinition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._mandatory != rhs_storage._mandatory {return false}
        if _storage._allowedRuleClasses != rhs_storage._allowedRuleClasses {return false}
        if _storage._documentation != rhs_storage._documentation {return false}
        if _storage._allowEmpty != rhs_storage._allowEmpty {return false}
        if _storage._allowSingleFile != rhs_storage._allowSingleFile {return false}
        if _storage._default != rhs_storage._default {return false}
        if _storage._executable != rhs_storage._executable {return false}
        if _storage._configurable != rhs_storage._configurable {return false}
        if _storage._nodep != rhs_storage._nodep {return false}
        if _storage._cfgIsHost != rhs_storage._cfgIsHost {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_AttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "int"),
    2: .same(proto: "string"),
    3: .same(proto: "bool"),
    4: .same(proto: "list"),
    5: .same(proto: "dict"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.list) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.dict) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._int) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._string) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._bool) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.list) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.dict) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._int {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._string {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bool {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    if !self.list.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.list, fieldNumber: 4)
    }
    if !self.dict.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dict, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_AttributeValue, rhs: BlazeQuery_AttributeValue) -> Bool {
    if lhs._int != rhs._int {return false}
    if lhs._string != rhs._string {return false}
    if lhs._bool != rhs._bool {return false}
    if lhs.list != rhs.list {return false}
    if lhs.dict != rhs.dict {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_AttributeValue.DictEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = BlazeQuery_AttributeValue.protoMessageName + ".DictEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public var isInitialized: Bool {
    if self._key == nil {return false}
    if self._value == nil {return false}
    if let v = self._value, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._key {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_AttributeValue.DictEntry, rhs: BlazeQuery_AttributeValue.DictEntry) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_RuleDefinition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuleDefinition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "attribute"),
    3: .same(proto: "documentation"),
    4: .same(proto: "label"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attribute) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attribute) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._documentation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.attribute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attribute, fieldNumber: 2)
    }
    try { if let v = self._documentation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_RuleDefinition, rhs: BlazeQuery_RuleDefinition) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs._documentation != rhs._documentation {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BlazeQuery_BuildLanguage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildLanguage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rule"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.rule) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rule.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rule, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: BlazeQuery_BuildLanguage, rhs: BlazeQuery_BuildLanguage) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
